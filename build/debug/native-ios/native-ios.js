CACHE={"resources/fonts/fontsheetSizeMap.json":"{}","spritesheets/map.json":"{\"resources/icons/ios114.png\":{},\"resources/icons/ios72.png\":{},\"resources/icons/android72.png\":{},\"resources/icons/android96.png\":{},\"resources/icons/metadata.json\":{},\"resources/splash/metadata.json\":{},\"resources/icons/ios57.png\":{},\"resources/splash/README.txt\":{},\"resources/icons/android36.png\":{},\"resources/splash/portrait480.png\":{},\"resources/icons/android48.png\":{},\"resources/fonts/metadata.json\":{},\"resources/splash/portrait1024.png\":{},\"resources/splash/portrait960.png\":{},\"resources/splash/portrait2048.png\":{},\"resources/splash/landscape768.png\":{},\"resources/splash/portrait1136.png\":{},\"resources/icons/icon512.png\":{},\"resources/icons/ios144.png\":{},\"resources/splash/landscape1536.png\":{}}"};
// Copyright (c) 2010
// Michael Carter (cartermichael@gmail.com)
// Martin Hunt (mghunt@gmail.com)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Initialization of js.io occurs in a closure, preventing local variables
// from entering the global scope.  During execution, the method `jsio` is
// added to the global scope.

;(function() {
	function init(cloneFrom) {
		// We expect this code to be minified before production use, so we may
		// write code slightly more verbosely than we otherwise would.
	
		// Should we parse syntax errors in the browser?
		var DEBUG = true;
	
		// Store a reference to the slice function for converting objects of
		// type arguments to type array.
		var SLICE = Array.prototype.slice;
	
		// js.io supports multiple JavaScript environments such as node.js and
		// most web browsers (IE, Firefox, WebKit).  The ENV object wraps 
		// any utility functions that contain environment-specific code (e.g.
		// reading a file using node's `fs` library or a browser's
		// `XMLHttpRequest`).  Running js.io in other JavaScript environments
		// is as easy as implementing an environment object that conforms to 
		// the abstract interface for an environment (provided below) and 
		// calling `jsio.setEnv()`.
		var ENV;
	
		// Checks if the last character in a string is `/`.
		var rexpEndSlash = /\/|\\$/;

		function getModuleDef (path) {
			path += '.js';
			return jsio.__modules[path] || new ModuleDef(path);
		}
	
		// Creates an object containing metadata about a module.
		function ModuleDef (path) {
			this.path = path;
			this.friendlyPath = path;
			util.splitPath(path, this);
		};

		ModuleDef.prototype.setBase = function (baseMod, basePath) {
			this.baseMod = baseMod;
			this.basePath = basePath;
		};
	
		// Utility functions
		var util = {
				// `util.bind` returns a function that, when called, will execute
				// the method passed in with the provided context and any additional
				// arguments passed to `util.bind`.
				//       util.bind(obj, 'f', a) -> function() { return obj.f(a); }
				//       util.bind(obj, g, a, b, c) -> function() { return g.call(g, a, b, c); }
				bind: function(context, method/*, args... */) {
					var args = SLICE.call(arguments, 2);
					return function() {
						method = (typeof method == 'string' ? context[method] : method);
						return method.apply(context, args.concat(SLICE.call(arguments, 0)));
					};
				},
			
				// `util.addEndSlash` accepts a string.  That string is returned with a `/`
				// appended if the string did not already end in a `/`.
				addEndSlash: function(str) {
					return rexpEndSlash.test(str) ? str : str + '/';
				},
			
				// `util.removeEndSlash` accepts a string.  It removes a trailing `/` if
				// one is found.
				removeEndSlash: function(str) {
					return str.replace(rexpEndSlash, '');
				},
			
				// `util.makeRelativePath` accepts two paths (strings) and returns the first path
				// made relative to the second.  Note: this function needs some work.  It currently
				// handles the most common use cases, but may fail in unexpected edge cases.
				// 
				//  - Simple case: if `path` starts with `relativeTo`, then we can strip `path` 
				// off the `relativeTo` part and we're done.
				//
				//         util.makeRelativePath('abc/def/', 'abc') -> 'def'
				//
				//  - Harder case: `path` starts with some substring of `relativeTo`.  We want to remove this substring and then add `../` for each remaining segment of `relativeTo`.
				//
				//         util.makeRelativePath('abc/def/', 'abc/hij') -> '../def'
				//
				makeRelativePath: function(path, relativeTo) {
					var len = relativeTo.length;
					if (path.substring(0, len) == relativeTo) {
						/* Note: we're casting a boolean to an int by adding len to it */
						return path.slice((path.charAt(len) == ENV.pathSep) + len);
					}
				
					var sA = util.removeEndSlash(path).split(ENV.pathSep),
						sB = util.removeEndSlash(relativeTo).split(ENV.pathSep),
						i = 0;
				
					/* Count how many segments match. */
					while(sA[i] == sB[i]) { ++i; }
				
					if (i) {
						/* If at least some segments matched, remove them.  The result is our new path. */
						path = sA.slice(i).join(ENV.pathSep);
					
						/* Prepend `../` for each segment remaining in `relativeTo`. */
						for (var j = sB.length - i; j > 0; --j) { path = '../' + path; }
					}
				
					return path;
				},
			
				// `buildPath` accepts an arbitrary number of string arguments to concatenate into a path.
				//     util.buildPath('a', 'b', 'c/', 'd/') -> 'a/b/c/d/'
				buildPath: function() {
					var args = Array.prototype.filter.call(arguments, function (x) { return x; });
					return util.resolveRelativePath(args.join('/'));
				},
			
				// `resolveRelativePath` removes relative path indicators.  For example:
				//     util.resolveRelativePath('a/../b') -> b
				resolveRelativePath: function(path) {
					/* If the path starts with a protocol, store it and remove it (add it
					   back later) so we don't accidently modify it. */
					var protocol = path.match(/^(\w+:\/\/)(.*)$/);
					if (protocol) { path = protocol[2]; }
				
					/* Remove multiple slashes and trivial dots (`/./ -> /`). */
					path = path.replace(/\/+/g, '/').replace(/\/\.\//g, '/');
				
					/* Loop to collapse instances of `../` in the path by matching a previous
					   path segment.  Essentially, we find substrings of the form `/abc/../`
					   where abc is not `.` or `..` and replace the substrings with `/`.
					   We loop until the string no longer changes since after collapsing
					   possible instances once, we may have created more instances that can
					   be collapsed.
					*/
					var o;
					while((o = path) != (path = path.replace(/(^|\/)(?!\.?\.\/)([^\/]+)\/\.\.\//g, '$1'))) {}
					/* Don't forget to prepend any protocol we might have removed earlier. */
					return protocol ? protocol[1] + path : path;
				},
			
				resolveRelativeModule: function (modulePath, directory) {
					var result = [],
						parts = modulePath.split('.'),
						len = parts.length,
						relative = (len > 1 && !parts[0]),
						i = relative ? 0 : -1;
				
					while(++i < len) { result.push(parts[i] ? parts[i] : '..'); }
					return util.buildPath(relative ? directory : '', result.join('/'));
				},
				resolveModulePath: function (modulePath, directory) {
					// resolve relative paths
					if (modulePath.charAt(0) == '.') {
						return [getModuleDef(util.resolveRelativeModule(modulePath, directory))];
					}
				
					// resolve absolute paths with respect to jsio packages/
					var pathSegments = modulePath.split('.');
					var baseMod = pathSegments[0];
					var pathString = pathSegments.join('/');
					
					if (jsioPath.cache.hasOwnProperty(baseMod)) {
						return [getModuleDef(util.buildPath(jsioPath.cache[baseMod], pathString))];
					}
				
					var defs = [];
					var paths = jsioPath.get();
					var len = paths.length;
					for (var i = 0; i < len; ++i) {
						var moduleDef = getModuleDef(util.buildPath(paths[i], pathString));
						moduleDef.setBase(baseMod, paths[i]);
						defs.push(moduleDef);
					}
					return defs;
				},
				splitPath: function(path, result) {
					if (!result) { result = {}; }
					var i = path.lastIndexOf('/') + 1;
					result.directory = path.substring(0, i);
					result.filename = path.substring(i);
					return result;
				}
			};
		
		// construct the top-level jsio object
		var jsio = util.bind(this, importer, null, null, null);

		jsio.__util = util;
		jsio.__init__ = init;

		var srcCache;
		jsio.setCache = function(cache) { srcCache = jsio.__srcCache = cache; }
		jsio.setCache(cloneFrom && cloneFrom.__srcCache || {});

		jsio.setCachedSrc = function(path, src) { srcCache[path] = { path: path, src: src }; }
		jsio.getCachedSrc = function(path) { return srcCache[path]; }

		jsio.__filename = 'jsio.js';
		jsio.__cmds = [];
		jsio.__jsio = jsio;
		jsio.__importer = importer;
		jsio.__modules = {preprocessors:{}};
		var jsioPath = {
				set: function(path) { jsioPath.value = (typeof path == 'string' ? [path] : path); },
				get: function() { return jsioPath.value.slice(0); },
				add: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) { return; }
					}
					v.push(path);
				},
				remove: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) {
							v.splice(i, 1);
						}
					}
				},
				value: [],
				cache: {}
			};
		
		jsio.path = jsioPath;
		jsio.addPath = util.bind(jsioPath, 'add');
		jsio.addCmd = util.bind(jsio.__cmds, 'push');
		
		jsio.setEnv = function(envCtor) {
			if (!envCtor && cloneFrom) {
				ENV = new cloneFrom.__env.constructor(util);
			} else {
				if (typeof envCtor == 'string') {
					envCtor = ({
							node: ENV_node,
							browser: ENV_browser
						})[envCtor] || ENV_browser;
				}

				ENV = new envCtor(util);
			}

			this.__env = ENV;
			this.__dir = ENV.getCwd();
			this.path.set(ENV.getPath());
		}
		
		if (cloneFrom) {
			jsio.setEnv();
		} else if (typeof process !== 'undefined' && process.version) {
			jsio.setEnv('node');
		} else if (typeof XMLHttpRequest != 'undefined' || typeof ActiveXObject != 'undefined') {
			jsio.setEnv('browser');
		}

		/*
		function ENV_abstract() {
			this.global = null;
			this.getCwd = function() {};
			this.getPath = function() {};
			this.eval = function(code, path) {};
			this.fetch = function(path) { return contentsOfPath; };
			this.log = function(args...) {};
		}
		*/
	
		function ENV_node() {
			var fs = require('fs');
			var path = require('path');
			
			this.name = 'node';
			this.global = GLOBAL;
			this.getCwd = process.cwd;
			this.pathSep = path.sep;

			this.log = function() {
				var msg;
				try {
					msg = Array.prototype.map.call(arguments, function(a) {
							if ((a instanceof Error) && a.message) {
								return 'Error:' + a.message + '\nStack:' + a.stack + '\nArguments:' + a.arguments;
							}
							return (typeof a == 'string' ? a : JSON.stringify(a));
						}).join(' ') + '\n';
				} catch(e) {
					msg = Array.prototype.join.call(arguments, ' ') + '\n';
				}

				process.stderr.write(msg);
				return msg;
			}
			
			this.getPath = function() {
				return path.relative(this.getCwd(), path.dirname(__filename) || '.');
			}
			
			if (process.compile) {
				this.eval = process.compile;
			} else {
				var vm = require('vm');
				this.eval = function (code, path) {
					try {
						return vm.runInThisContext(code, path);
					} catch (e) {
						this.log('In ' + path + ':\n' + e.message);
						throw e;
					}
				}
			}
			
			this.fetch = function (p) {
				p = path.resolve(this.getCwd(), p);

				try {
					var dirname = path.dirname(p);
					var filename = path.basename(p);
					var lowerFilename = filename.toLowerCase();
					var files = fs.readdirSync(dirname);
				} catch (e) {
					return false;
				}

				for (var i = 0, testName; testName = files[i]; ++i) {
					if (testName.toLowerCase() == lowerFilename && testName != filename) {
						throw "Invalid case when importing [" + p + "].  You probably meant" + testName;
					}
				}

				try {
					return fs.readFileSync(p, 'utf8');
				} catch(e) {
					return false;
				}
			}
			
			this.require = require;
		}
	
		function ENV_browser() {
			var XHR = window.XMLHttpRequest || function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
				cwd = null,
				path = null,
				JOIN = Array.prototype.join;
			
			this.name = 'browser';
			this.global = window;
			this.pathSep = "/";

			if (!this.global.jsio) { this.global.jsio = jsio; }
		
			if (window.console && console.log) {
				if (!console.log.apply || /Android|iPhone|iPad|iPod/.test(navigator.userAgent)) {
					this.log = function () {
						var args = JOIN.call(arguments, ' ');
						console.log(args);
						return args;
					}
				} else {
					this.log = function () {
						console.log.apply(console, arguments);
						return JOIN.call(arguments, ' ');
					}
				}
			} else {
				this.log = function () { return JOIN.call(arguments, ' '); }
			}

			this.getCwd = function() {
				if(!cwd) {
					var loc = window.location, path = loc.pathname;
					cwd = loc.protocol + '//' + loc.host + path.substring(0, path.lastIndexOf('/') + 1);
				}
				return cwd;
			}
		
			this.getPath = function() {
				if(!path) {
					try {
						var filename = new RegExp('(.*?)' + jsio.__filename + '(\\?.*)?$'),
							scripts = document.getElementsByTagName('script');
					
						for (var i = 0, script; script = scripts[i]; ++i) {
							var result = script.src.match(filename);
							if (result) {
								path = result[1];
								if (/^[A-Za-z]*:\/\//.test(path)) { path = util.makeRelativePath(path, this.getCwd()); }
								break;
							}
						}
					} catch(e) {}
				
					if(!path) { path = '.'; }
				}
				return path;
			}
		
			this.debugPath = function(path) { return path; }

			// IE6 won't return an anonymous function from eval, so use the function constructor instead
			var rawEval = typeof eval('(function(){})') == 'undefined'
				? function(src, path) { return (new Function('return ' + src))(); }
				: function(src, path) { var src = src + '\n//@ sourceURL=' + path; return window.eval(src); };

			// provide an eval with reasonable debugging
			this.eval = function(code, path, origCode) {
				try {
					return rawEval(code, this.debugPath(path));
				} catch(e) {
					if(e instanceof SyntaxError) {
						ENV.log("a syntax error is preventing execution of " + path);
						if (DEBUG && this.checkSyntax) {
							this.checkSyntax(origCode, path);
						}
					}
					throw e;
				}
			}
		
			this.checkSyntax = function(code, path) {
				try {
					var syntax = jsio('import util.syntax', {suppressErrors: true, dontExport: true}),
						result = syntax(code);
					syntax.display(result, path);
				} catch(e) {}
			}
		
			this.fetch = function(path) {
				var xhr = new XHR();
				try {
					xhr.open('GET', path, false);
					xhr.send(null);
				} catch(e) {
					ENV.log('e:', e);
					return false; // firefox file://
				}
			
				if (xhr.status == 404 || // all browsers, http://
					xhr.status == -1100 || // safari file://
					// XXX: We have no way to tell in opera if a file exists and is empty, or is 404
					// XXX: Use flash?
					//(!failed && xhr.status == 0 && !xhr.responseText && EXISTS)) // opera
					false)
				{
					return false;
				}
			
				return xhr.responseText;
			}
		};
	
		var preprocessorCheck = /^"use (.*?)"\s*;\s*\n/,
			preprocessorFunc = /^(.+)\(.+\)$/,
			failedFetch = {};
	
		function findModule(possibilities, opts) {
			var src;
			for (var i = 0, possible; possible = possibilities[i]; ++i) {
				var path = possible.path,
					cachedVersion = srcCache[path];
				
				if (cachedVersion) {
					possible.src = cachedVersion.src;
					possible.pre = true;
					return possible;
				}
			
				/*if (/^\.\//.test(path)) {
					// remove one path segment for each dot from the cwd 
					path = addEndSlash(ENV.getCwd()) + path;
				}*/
			
				src = ENV.fetch(path);
			
				if (src !== false) {
					possible.src = src;
					return possible;
				} else {
					failedFetch[path] = true;
				}
			}
		
			return false;
		}
	
		// load a module from a file
		function loadModule (fromDir, fromFile, modulePath, opts) {
			var possibilities = util.resolveModulePath(modulePath, fromDir);
			for (var i = 0, p; p = possibilities[i]; ++i) {
				var path = possibilities[i].path;
				if (!opts.reload && (path in jsio.__modules)) {
					return possibilities[i];
				}

				if (path in failedFetch) { possibilities.splice(i--, 1); }
			}
		
			if (!possibilities.length) {
				if (opts.suppressErrors) { return false; }
				var e = new Error('Module failed to load (again)');
				e.jsioLogged = true;
				throw e;
			}
		
			var moduleDef = findModule(possibilities, opts),
				match;
		
			if (!moduleDef) {
				if (opts.suppressErrors) { return false; }
				var paths = [];
				for (var i = 0, p; p = possibilities[i]; ++i) { paths.push(p.path); }
				throw new Error(
					"requested import (" + modulePath + ") not found\n"
					+ "\tlooked in:\n"
						+ "\t\t" + paths.join('\n\t\t') + "\n"
						+ "\tImport Stack:\n"
						+ "\t\t" + importStack.join("\n\t\t"));
			}
		
			// a (potentially) nicer way to refer to a module -- how it was referenced in code when it was first imported
			moduleDef.friendlyPath = modulePath;
			
			// cache the base module's path in the path cache so we don't have to
			// try out all paths the next time we see the same base module.
			if (moduleDef.baseMod && !(moduleDef.baseMod in jsioPath.cache)) {
				jsioPath.cache[moduleDef.baseMod] = moduleDef.basePath;
			}

			// don't apply the standard preprocessors to base.js.  If we're reloading
			// the source code, always apply them.  We also don't want to run them
			// if they've been run once -- moduleDef.pre is set to true already
			// if we're reading the code from the source cache.
			if (modulePath != 'base' && (opts.reload || !opts.dontPreprocess && !moduleDef.pre)) {
				moduleDef.pre = true;

				applyPreprocessors(fromDir, moduleDef, ["import", "cls"], opts);

				// the order here is somewhat arbitrary and might be overly restrictive (... or overly powerful)
				// while (moduleDef.src.charAt(0) == '"' && (match = moduleDef.src.match(preprocessorCheck))) {
				// 	moduleDef.src = moduleDef.src.substring(match[0].length - 1);
				// 	applyPreprocessors(fromDir, moduleDef, match[1].split(','), opts);
				// }
			}

			// any additional preprocessors?
			if (opts.preprocessors) {
				applyPreprocessors(fromDir, moduleDef, opts.preprocessors, opts);
			}

			return moduleDef;
		}
	
		function applyPreprocessors(path, moduleDef, names, opts) {
			for (var i = 0, len = names.length; i < len; ++i) {
				p = getPreprocessor(names[i]);

				// if we have a recursive import and p isn't a function, just
				// skip it (handles the case where a preprocessor imports
				// other modules).
				if (p && typeof p == 'function') {
					p(path, moduleDef, opts);
				}
			}
		}
		
		function getPreprocessor(name) {
			var module = jsio.__modules['preprocessors.' + name];
			return typeof name == 'function'
				? name
				: (module && module.exports
					|| jsio('import preprocessors.' + name, {dontExport: true, dontPreprocess: true}));
		}
	
		function execModuleDef(context, moduleDef) {
			var src = moduleDef.src;
			delete moduleDef.src;

			var code = "(function(_){with(_){delete _;return function $$" + moduleDef.friendlyPath.replace(/[\:\\\/.]/g, '_') + "(){" + src + "\n}}})";
			var fn = ENV.eval(code, moduleDef.path, src);
			fn = fn(context);
			fn.call(context.exports);
		};
		
		function resolveImportRequest(context, request, opts) {
			var cmds = jsio.__cmds,
				imports = [],
				result = false;
		
			for (var i = 0, imp; imp = cmds[i]; ++i) {
				if ((result = imp(context, request, opts, imports))) { break; }
			}
		
			if (result !== true) {
				throw new (typeof SyntaxError != 'undefined' ? SyntaxError : Error)(String(result || 'invalid jsio command: jsio(\'' + request + '\')'));
			}
		
			return imports;
		};
	
		function makeContext(ctx, modulePath, moduleDef, dontAddBase) {
			if (!ctx) { ctx = {}; }
			if (!ctx.exports) { ctx.exports = {}; }

			ctx.jsio = util.bind(this, importer, ctx, moduleDef.directory, moduleDef.filename);
			ctx.require = function(request, opts) {
				if (!opts) { opts = {}; }
				opts.dontExport = true;
				// opts.suppressErrors = true;
				
				try {
					var ret = ctx.jsio(request, opts);
					if (ret === false) {
						// need this to trigger require attempt due to suppresserrors = true
						throw "module failed to load";
					} else {
						return ret;
					}
				} catch(e) {
					ENV.log('Error loading request ' + request + ':');
					ENV.log(e);
				}
			};
			
			ctx.module = {id: modulePath, exports: ctx.exports};
			if (!dontAddBase && modulePath != 'base') {
				ctx.jsio('from base import *', {dontPreprocess: true});
				ctx.logging.__create(modulePath, ctx);
			}
		
			// TODO: FIX for "trailing ." case
			ctx.jsio.__jsio = jsio;
			ctx.jsio.__env = jsio.__env;
			ctx.jsio.__dir = moduleDef.directory;
			ctx.jsio.__filename = moduleDef.filename;
			ctx.jsio.path = jsioPath;
			return ctx;
		};
		
		var importStack = [];
		function importer(boundContext, fromDir, fromFile, request, opts) {
			opts = opts || {};
			fromDir = fromDir || './';
			fromFile = fromFile || '<initial file>';
		
			// importer is bound to a module's (or global) context -- we can override this
			// by using opts.exportInto
			var exportInto = opts.exportInto || boundContext || ENV.global;
		
			// parse the import request(s)
			var imports = resolveImportRequest(exportInto, request, opts),
				numImports = imports.length,
				retVal = numImports > 1 ? {} : null;
		
			// import each requested item
			for (var i = 0; i < numImports; ++i) {
				var item = imports[i];
				var modulePath = item.from;
				var modules = jsio.__modules;
				var path;
				var moduleDef;
				var err;
				
				try {
					moduleDef = loadModule(fromDir, fromFile, modulePath, opts);
				} catch(e) {
					err = e;
				}

				if (moduleDef) {
					path = moduleDef.path;
				} else if (jsio.__env.require) {
					path = modulePath;
					try {
						modules[path] = {exports: jsio.__env.require(modulePath)};
						err = null;
					} catch (e2) {
						if (!err) { err = e2; }
					}
				} else if (moduleDef == false) {
					return false;
				}

				if (err) {
					if (opts.suppressErrors) { return false; }
					if (!err.jsioLogged) {
						ENV.log(
							'\nError loading module:\n',
							'\t[[', request, ']]\n',
							'\trequested by:', fromDir + fromFile, '\n',
							'\tcurrent directory:', jsio.__env.getCwd(), '\n',
							'\t' + err, '\n',
							'\t' + err.stack);
						err.jsioLogged = true;
					}

					throw err;
				}
				
				if (moduleDef) {
					importStack.push(importStack.length + ' : ' + moduleDef.friendlyPath + ' (' + moduleDef.path + ')');
				}
				
				// eval any packages that we don't know about already
				if (!(path in modules)) {
					var newContext = makeContext(opts.context, modulePath, moduleDef, item.dontAddBase);

					modules[path] = moduleDef;

					moduleDef.exports = newContext.exports;
					if (item.dontUseExports) {
						var src = [';(function(){'], k = 1;
						for (var j in item['import']) {
							newContext.exports[j] = undefined;
							src[k++] = 'if(typeof '+j+'!="undefined"&&exports.'+j+'==undefined)exports.'+j+'='+j+';';
						}
						src[k] = '})();';
						moduleDef.src += src.join('');
					}

					execModuleDef(newContext, moduleDef);
					moduleDef.exports = newContext.exports;
				}
				
				importStack.pop();
			
				var module = modules[path].exports;
			
				// return the module if we're only importing one module
				if (numImports == 1) { retVal = module; }
			
				if (!opts.dontExport) {
					// add the module to the current context
					if (item.as) {
						// remove trailing/leading dots
						var as = item.as.match(/^\.*(.*?)\.*$/)[1],
							segments = as.split('.'),
							kMax = segments.length - 1,
							c = exportInto;
				
						// build the object in the context
						for(var k = 0; k < kMax; ++k) {
							var segment = segments[k];
							if (!segment) continue;
							if (!c[segment]) { c[segment] = {}; }
							c = c[segment];
						}
					
						c[segments[kMax]] = module;
				
						// there can be multiple module imports with this syntax (import foo, bar)
						if (numImports > 1) {
							retVal[as] = module;
						}
					} else if (item['import']) {
						// there can only be one module import with this syntax 
						// (from foo import bar), so retVal will already be set here
						if (item['import']['*']) {
							for (var k in modules[path].exports) { exportInto[k] = module[k]; }
						} else {
							for (var k in item['import']) { exportInto[item['import'][k]] = module[k]; }
						}
					}
				}
			}
		
			return retVal;
		}
	
		// DEFINE SYNTAX FOR JSIO('cmd')
	
		// from myPackage import myFunc
		// external myPackage import myFunc
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*(from|external)\s+([\w.$]+)\s+(import|grab)\s+(.*)$/);
			if(match) {
				imports.push({
					from: match[2],
					dontAddBase: match[1] == 'external',
					dontUseExports: match[3] == 'grab' || match[1] == 'external',
					'import': {}
				});
			
				match[4].replace(/\s*([\w.$*]+)(?:\s+as\s+([\w.$]+))?/g, function(_, item, as) {
					imports[0]['import'][item] = as || item;
				});
				return true;
			}
		});

		// import myPackage
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*import\s+(.*)$/);
			if (match) {
				match[1].replace(/\s*([\w.$]+)(?:\s+as\s+([\w.$]+))?,?/g, function(_, fullPath, as) {
					imports.push(
						as ? {
							from: fullPath,
							as: as
						} : {
							from: fullPath,
							as: fullPath
						});
				});
				return true;
			}
		});

		// CommonJS syntax
		jsio.addCmd(function(context, request, opts, imports) {
		
			//		./../b -> ..b
			// 		../../b -> ...b
			// 		../b -> ..b
			// 		./b -> .b
		
			var match = request.match(/^\s*[\w.0-9$\/\-]+\s*$/);
			if (match) {
			
				var req = util.resolveRelativePath(match[0]),
					isRelative = req.charAt(0) == '.';
			
				req = req
					// .replace(/^\//, '') // remove any leading slash
					.replace(/\.\.\//g, '.') // replace relative path indicators with dots
					.replace(/\.\//g, '')
					.replace(/\//g, '.'); // any remaining slashes are path separators

				imports[0] = { from: (isRelative ? '.' : '') + req };
				return true;
			}
		});
		
		jsio.install = function() {
			jsio('from base import *');
			GLOBAL['logger'] = logging.get('jsiocore');
		};

		jsio.eval = function (src, path) {
			path = ENV.getCwd() || '/';
			var moduleDef = new ModuleDef(path);
			moduleDef.src = src;
			applyPreprocessors(path, moduleDef, ["import", "cls"], {});
			execModuleDef(ENV.global, moduleDef);
		};
		
		jsio.clone = util.bind(null, init, jsio);

		return jsio;
	}

	var J = init(null, {});
	if (typeof exports != 'undefined') {
		module.exports = J;
	} else {
		jsio = J;
	}
})();
jsio.path.set(["sdk/jsio",".","sdk/gc/api/","sdk/","sdk/timestep/"]);jsio.path.cache={"preprocessors":"sdk/jsio","base":"sdk/jsio","util":"sdk/jsio","gc":"sdk/","std":"sdk/jsio","lib":"sdk/jsio","device":"sdk/timestep/","event":"sdk/timestep/","ui":"sdk/timestep/","platforms":"sdk/timestep/","math":"sdk/jsio","timer":"sdk/timestep/","animate":"sdk/timestep/","AudioManager":"sdk/timestep/","net":"sdk/jsio","src":"."};jsio.setCache({"sdk/jsio/base.js":{"path":"sdk/jsio/base.js","friendlyPath":"base","directory":"sdk/jsio/","filename":"base.js","baseMod":"base","basePath":"sdk/jsio","src":"/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n\nexports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\nif (!Array.isArray) {\n\tArray.isArray = function (arg) {\n\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\n\t}\n};\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1), \n        fToBind = this, \n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis,\n                               aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\n\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n\texports.isArray = Array.isArray;\n} else {\n\texports.isArray = function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\n/**\n * Class constructor.\n */\n\nexports.Class = function(name, parent, proto) {\n\treturn exports.__class__(function() { return this.init && this.init.apply(this, arguments); }, name, parent, proto);\n}\n\nexports.__class__ = function (cls, name, parent, proto) {\n\tvar clsProto = function () {};\n\tvar logger;\n\n\tif (typeof name != 'string') {\n\t\tproto = parent;\n\t\tparent = name;\n\t\tname = null;\n\t}\n\n\tif (name) {\n\t\tlogger = exports.logging.get(name);\n\t}\n\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\n\tif (parent) {\n\t\tif (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\t\tclsProto.prototype = {};\n\t\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\t\tfor (var item in p.prototype) {\n\t\t\t\t\tif (!(item in clsProto.prototype)) {\n\t\t\t\t\t\tclsProto.prototype[item] = p.prototype[item];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = parent[0];\n\t\t} else {\n\t\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\t\tclsProto.prototype = parent.prototype;\n\t\t}\n\t}\n\t\n\tvar supr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\t\n\tvar p = cls.prototype = new clsProto();\n\tp.constructor = cls;\n\tp.__parentClass__ = parent;\n\tif (name) { p.__class__ = name; }\n\tproto.call(p, logger || supr, logger && supr);\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.__class__(function ErrorCls() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}, function() {});\n\n/**\n * Merge two objects together.\n */\n\nexports.Class.defaults = \nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\n/**\n * Create a timer delay.\n */\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, args); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\n/**\n * Log constructor and default \"logger\".\n */\n\nexports.logging = (function() {\n\t\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5,\n\t\t\tNONE: 10\n\t\t},\n\t\tloggers = {}, // effectively globals - all loggers and a global production state\n\t\tproduction = false;\n\tvar gPrefix = '';\n\tlogging.setPrefix = function(prefix) { gPrefix = prefix + ' '; }\n\tlogging.setProduction = function(prod) { production = !!prod; }\n\tlogging.get = function(name) {\n\t\treturn loggers.hasOwnProperty(name) ? loggers[name]\n\t\t\t: (loggers[name] = new Logger(name));\n\t}\n\tlogging.set = function(name, _logger) {\n\t\tloggers[name] = _logger;\n\t}\n\t\n\tlogging.getAll = function() { return loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\t\n\tvar Logger = exports.__class__(\n\t\tfunction Logger(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._level = level || logging.LOG;\n\t\t},\n\t\tfunction () {\n\t\t\tthis.setLevel = function(level) { this._level = level; }\n\t\t\n\t\t\tfunction makeLogFunction(level, type) {\n\t\t\t\treturn function() {\n\t\t\t\t\tif (!production && level >= this._level) {\n\t\t\t\t\t\tvar prefix = type + ' ' + gPrefix + this._name,\n\t\t\t\t\t\t\tlistener = this._listener || exports.log;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t\t}\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tthis.setListener = function(listener) { this._listener = listener; }\n\t\t\tthis.debug = makeLogFunction(logging.DEBUG, \"DEBUG\");\n\t\t\tthis.log = makeLogFunction(logging.LOG, \"LOG\");\n\t\t\tthis.info = makeLogFunction(logging.INFO, \"INFO\");\n\t\t\tthis.warn = makeLogFunction(logging.WARN, \"WARN\");\n\t\t\tthis.error = makeLogFunction(logging.ERROR, \"ERROR\");\n\t\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n"},"sdk/gc/browser/launchClient.js":{"path":"sdk/gc/browser/launchClient.js","friendlyPath":"gc.browser.launchClient","directory":"sdk/gc/browser/","filename":"launchClient.js","baseMod":"gc","basePath":"sdk/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nif (DEBUG) {\n\t// prefix filenames in the debugger\n\tjsio.__env.debugPath = function(path) { return 'http://' + window.location.host + '/' + path; }\n}\n\n// shims\n\nif (!window.JSON) {\n\tjsio('import std.JSON').createGlobal();\n}\n\nif (!window.console) {\n\twindow.console = {};\n\twindow.console.log = window.console.info = window.console.error = window.console.warn = function () {};\n}\n\nif (!window.localStorage) {\n\twindow.localStorage = {\n\t\tgetItem: function() {},\n\t\tsetItem: function() {},\n\t\tremoveItem: function() {}\n\t}\n}\n\n// parsing options\njsio(\"import std.uri\");\nvar uri = new std.uri(window.location);\nvar mute = uri.hash('mute');\nCONFIG.isMuted = mute != undefined && mute != \"false\" && mute != \"0\" && mute != \"no\";\n\nif (DEBUG) {\n\t// device simulation\n\n\t// simulate device chrome, input, and userAgent\n\tvar sim_device = uri.query('device') || uri.hash('device');\n\tif (sim_device) {\n\t\t// hack to access SDK static resolutions file from a debug device\n\t\ttry {\n\t\t\tjsio(\"import preprocessors.import\");\n\t\t\tjsio(\"import preprocessors.cls\");\n\n\t\t\tjsio(\"import .simulateDevice\");\n\t\t\tvar resImport = \"import ..util.resolutions\";\n\t\t\tjsio.__jsio(resImport);\n\n\t\t\tsimulateDevice.simulate(util.resolutions.get(sim_device));\n\t\t} catch (e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n\n\tjsio(\"import ..debugging.connect\");\n\tdebugging.connect.connect(null, startApp);\n} else {\n\tstartApp();\n}\n\nfunction startApp (conn) {\n\n\t// setup timestep device API\n\n\tjsio(\"import device\");\n\tjsio(\"import platforms.browser.initialize\");\n\tdevice.init();\n\n\t// logging\n\n\tif (DEBUG) {\n\n\t\tjsio(\"import ..debugging.TimestepInspector\");\n\t\tconn.addClient(new debugging.TimestepInspector());\n\n\t\tvar initDebugging = function () {\n\t\t\tvar env = jsio.__env;\n\t\t\t\n\t\t\tvar originalSyntax = bind(env, env.checkSyntax);\n\t\t\tvar originalFetch = bind(env, env.fetch);\n\n\t\t\tenv.fetch = function(filename) {\n\t\t\t\tlogging.get('jsiocore').warn('LOADING EXTERNAL FILE:', filename);\n\t\t\t\treturn originalFetch.apply(this, arguments);\n\t\t\t}\n\t\t\t\n\t\t\tenv.checkSyntax = function(code, filename) {\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\txhr.open('POST', '/.syntax', false);\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\t\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t\tif (xhr.readyState != 4) { return; }\n\t\t\t\t\n\t\t\t\t\tif (xhr.status == 200 && xhr.responseText) {\n\t\t\t\t\t\tvar err;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar response = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\terr = response[1].stderr.replace(/^stdin:(\\d+):/mg, filename + ' line $1:');\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\terr = xhr.responseText;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\n\t\t\t\t\t\tdocument.body.innerHTML = '<pre style=\\'font: bold 12px Monaco, \"Bitstream Vera Sans Mono\", \"Lucida Console\", Terminal, monospace; color: #FFF;\\'>' + err + '</err>';\n\t\t\t\t\t} else if (xhr.status > 0) {\n\t\t\t\t\t\toriginalSyntax(code, filename);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\txhr.send('javascript=' + encodeURIComponent(code));\n\t\t\t}\n\t\t};\n\n\t\tif (device.isMobileBrowser) {\n\t\t\tconn.initLogProxy();\n\t\t\tconn.initRemoteEval();\n\t\t}\n\n\t\tinitDebugging();\n\t}\n\n\t// init sets up the GC object\n\tjsio(\"import gc.API\");\n\tGC.buildApp('launchUI');\n\n\tif (DEBUG) {\n\t\tconn.setApp(GC.app);\n\t}\n}\n","pre":true},"sdk/jsio/std/JSON.js":{"path":"sdk/jsio/std/JSON.js","friendlyPath":"std.JSON","directory":"sdk/jsio/std/","filename":"JSON.js","baseMod":"std","basePath":"sdk/jsio","src":"// Based on json2.js (version 2009-09-29) http://www.JSON.org/json2.js\n// exports createGlobal, stringify, parse, stringifyDate\n\n/**\n * if a global JSON object doesn't exist, create one\n */\nexports.createGlobal = function() {\n\tif(typeof JSON == 'undefined') { JSON = {}; }\n\tif(typeof JSON.stringify !== 'function') {\n\t\tJSON.stringify = exports.stringify;\n\t}\n\tif(typeof JSON.parse !== 'function') {\n\t\tJSON.parse = exports.parse;\n\t}\n};\n\n;(function() {\n\tvar cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tescapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tgap,\n\t\tindent,\n\t\tmeta = {\t// table of character substitutions\n\t\t\t'\\b': '\\\\b',\n\t\t\t'\\t': '\\\\t',\n\t\t\t'\\n': '\\\\n',\n\t\t\t'\\f': '\\\\f',\n\t\t\t'\\r': '\\\\r',\n\t\t\t'\"' : '\\\\\"',\n\t\t\t'\\\\': '\\\\\\\\'\n\t\t},\n\t\trep;\n\t\n\tfunction quote(string) {\n\t\t// quote the string if it doesn't contain control characters, quote characters, and backslash characters\n\t\t// otherwise, replace those characters with safe escape sequences\n\t\tescapable.lastIndex = 0;\n\t\treturn escapable.test(string)\n\t\t\t? '\"' + string.replace(escapable, function (a) {\n\t\t\t\t\tvar c = meta[a];\n\t\t\t\t\treturn typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t\t}) + '\"'\n\t\t\t: '\"' + string + '\"';\n\t}\n\t\n\t// Produce a string from holder[key].\n\tfunction str(key, holder) {\n\t\tvar mind = gap, value = holder[key];\n\t\t\n\t\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\tif (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n\t\t\tvalue = value.toJSON(key);\n\t\t}\n\t\t\n\t\t// If we were called with a replacer function, then call the replacer to\n\t\t// obtain a replacement value.\n\t\tif (typeof rep === 'function') { value = rep.call(holder, key, value); }\n\t\t\n\t\tswitch (typeof value) {\n\t\t\tcase 'string':\n\t\t\t\treturn quote(value);\n\t\t\tcase 'number':\n\t\t\t\t// JSON numbers must be finite\n\t\t\t\treturn isFinite(value) ? String(value) : 'null';\n\t\t\tcase 'boolean':\n\t\t\t\treturn String(value);\n\t\t\tcase 'object': // object, array, date, null\n\t\t\t\tif (value === null) { return 'null'; } // typeof null == 'object'\n\t\t\t\tif (value.constructor === Date) { return exports.stringifyDate(value); }\n\t\t\t\n\t\t\t\tgap += indent;\n\t\t\t\tvar partial = [];\n\t\t\t\t\n\t\t\t\t// Is the value an array?\n\t\t\t\tif (value.constructor === Array) {\n\t\t\t\t\tvar length = value.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tpartial[i] = str(i, value) || 'null';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Join all of the elements together, separated with commas, and wrap them in brackets.\n\t\t\t\t\tvar v = partial.length === 0 ? '[]' :\n\t\t\t\t\t\tgap ? '[\\n' + gap +\n\t\t\t\t\t\t\t\tpartial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\t\t\tmind + ']' :\n\t\t\t\t\t\t\t  '[' + partial.join(',') + ']';\n\t\t\t\t\tgap = mind;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rep && typeof rep === 'object') { // rep is an array\n\t\t\t\t\tvar length = rep.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tvar k = rep[i];\n\t\t\t\t\t\tif (typeof k === 'string') {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // iterate through all of the keys in the object.\n\t\t\t\t\tfor (var k in value) {\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Join all of the member texts together, separated with commas,\n\t\t\t\t// and wrap them in braces.\n\t\t\t\tvar v = partial.length === 0 ? '{}' :\n\t\t\t\t\tgap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\tmind + '}' : '{' + partial.join(',') + '}';\n\t\t\t\tgap = mind;\n\t\t\t\treturn v;\n\t\t}\n\t}\n\n\n\t/**\n\t * The stringify method takes a value and an optional replacer, and an optional\n\t * space parameter, and returns a JSON text. The replacer can be a function\n\t * that can replace values, or an array of strings that will select the keys.\n \t * A default replacer method can be provided. Use of the space parameter can\n\t * produce text that is more easily readable.\n\t */\n\texports.stringify = function (value, replacer, space) {\n\t\tgap = '';\n\t\tindent = '';\n\t\t\n\t\t// If the space parameter is a number, make an indent string containing that many spaces.\n\t\tif (typeof space === 'number') {\n\t\t\tfor (var i = 0; i < space; i += 1) {\n\t\t\t\tindent += ' ';\n\t\t\t}\n\t\t} else if (typeof space === 'string') {\n\t\t\tindent = space;\n\t\t}\n\t\t\n\t\t// If there is a replacer, it must be a function or an array.\n\t\trep = replacer;\n\t\tif (replacer && typeof replacer !== 'function' &&\n\t\t\t\t(typeof replacer !== 'object' ||\n\t\t\t\t typeof replacer.length !== 'number')) {\n\t\t\tthrow new Error('JSON stringify: invalid replacer');\n\t\t}\n\t\t\n\t\t// Make a fake root object containing our value under the key of ''.\n\t\t// Return the result of stringifying the value.\n\t\treturn str('', {'': value});\n\t};\n\t\n\texports.stringifyDate = function(d) {\n\t\tvar year = d.getUTCFullYear(),\n\t\t\tmonth = d.getUTCMonth() + 1,\n\t\t\tday = d.getUTCDate(),\n\t\t\thours = d.getUTCHours(),\n\t\t\tminutes = d.getUTCMinutes(),\n\t\t\tseconds = d.getUTCSeconds(),\n\t\t\tms = d.getUTCMilliseconds();\n\t\t\n\t\tif (month < 10) { month = '0' + month; }\n\t\tif (day < 10) { day = '0' + day; }\n\t\tif (hours < 10) { hours = '0' + hours; }\n\t\tif (minutes < 10) { minutes = '0' + minutes; }\n\t\tif (seconds < 10) { seconds = '0' + seconds; }\n\t\tif (ms < 10) { ms = '00' + ms; }\n\t\telse if (ms < 100) { ms = '0' + ms; }\n\n\t\treturn '\"' + year\n\t\t\t+ '-' + month\n\t\t\t+ '-' + day\n\t\t\t+ 'T' + hours\n\t\t\t+ ':' + minutes\n\t\t\t+ ':' + seconds\n\t\t\t+ '.' + ms\n\t\t\t+ 'Z\"';\n\t}\n\t\n\t/**\n\t * The parse method takes a text and an optional reviver function, and returns\n\t * a JavaScript value if the text is a valid JSON text.\n\t */\n\texports.parse = function (text, reviver) {\n\t\t// Parsing happens in four stages. In the first stage, we replace certain\n\t\t// Unicode characters with escape sequences. JavaScript handles many characters\n\t\t// incorrectly, either silently deleting them, or treating them as line endings.\n\t\tcx.lastIndex = 0;\n\t\tif (cx.test(text)) {\n\t\t\ttext = text.replace(cx, function (a) {\n\t\t\t\treturn '\\\\u' +\n\t\t\t\t\t('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t});\n\t\t}\n\t\t\n\t\t// In the second stage, we run the text against regular expressions that look\n\t\t// for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t\t// because they can cause invocation, and '=' because it can cause mutation.\n\t\t// But just to be safe, we want to reject all unexpected forms.\n\n\t\t// We split the second stage into 4 regexp operations in order to work around\n\t\t// crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t\t// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t\t// replace all simple value tokens with ']' characters. Third, we delete all\n\t\t// open brackets that follow a colon or comma or that begin the text. Finally,\n\t\t// we look to see that the remaining characters are only whitespace or ']' or\n\t\t// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n\t\tif (/^[\\],:{}\\s]*$/\n\t\t\t\t.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t\t\t\t.replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t\t\t\t.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')))\n\t\t{\n\t\t\tvar j = eval('(' + text + ')');\n\t\t\tif(!reviver) {\n\t\t\t\treturn j;\n\t\t\t} else {\n\t\t\t\t// In the optional fourth stage, we recursively walk the new structure, passing\n\t\t\t\t// each name/value pair to a reviver function for possible transformation.\n\t\t\t\tvar walk = function(holder, key) {\n\t\t\t\t\t// The walk method is used to recursively walk the resulting structure so\n\t\t\t\t\t// that modifications can be made.\n\t\t\t\t\tvar k, v, value = holder[key];\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tfor (k in value) {\n\t\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn reviver.call(holder, key, value);\n\t\t\t\t}\n\t\t\t\treturn walk({'': j}, '');\n\t\t\t}\n\t\t}\n\n\t\t// If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\tthrow new SyntaxError('JSON.parse');\n\t};\n}());","pre":true},"sdk/jsio/std/uri.js":{"path":"sdk/jsio/std/uri.js","friendlyPath":"std.uri","directory":"sdk/jsio/std/","filename":"uri.js","src":"var attrs = [ \n\t\"source\",\n\t\"protocol\",\n\t\"authority\",\n\t\"userInfo\",\n\t\"user\",\n\t\"password\",\n\t\"host\",\n\t\"port\",\n\t\"relative\",\n\t\"path\",\n\t\"directory\",\n\t\"file\",\n\t\"query\",\n\t\"anchor\"\n];\n\nvar sdk_jsio_std_uri=__class__;var URI = exports=sdk_jsio_std_uri(function sdk_jsio_std_uri(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tthis.init = function(url, isStrict) {\n\t\tif (url instanceof URI) {\n\t\t\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t\t\tthis['_' + attr] = url['_' + attr];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis._isStrict = isStrict;\n\t\t\n\t\tvar uriData = exports.parse(url, isStrict);\n\t\tfor (var attr in uriData) {\n\t\t\tthis['_' + attr] = uriData[attr];\n\t\t};\n\t}\n  \n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t(function(attr) {\n\t\t\tvar fNameSuffix = attr.charAt(0).toUpperCase() + attr.slice(1);\n\t\t\tthis['get' + fNameSuffix] = function() {\n\t\t\t\treturn this['_' + attr];\n\t\t\t};\n\t\t\tthis['set' + fNameSuffix] = function(val) {\n\t\t\t\tthis['_' + attr] = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}).call(this, attr);\n\t};\n\t\n\tthis.query = function(key) { return exports.parseQuery(this._query)[key]; }\n\tthis.hash = function(key) { return exports.parseQuery(this._anchor)[key]; }\n\t\n\tthis.addHash = function(kvp) {\n\t\tvar hash = exports.parseQuery(this._anchor);\n\t\tfor (var i in kvp) { hash[i] = kvp[i]; }\n\t\tthis._anchor = exports.buildQuery(hash);\n\t\treturn this;\n\t}\n\t\n\tthis.push = function(path) {\n\t\tif (path) {\n\t\t\tthis._path = (this._path + '/' + path).replace(/\\/\\/+/g, '/');\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.addQuery = function(kvp) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tfor (var i in kvp) { query[i] = kvp[i]; }\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\t\n\tthis.removeQuery = function(keys) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tif (isArray(keys)) {\n\t\t\tfor (var i = 0, n = keys.length; i < n; ++i) {\n\t\t\t\tdelete query[keys[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tdelete query[keys];\n\t\t}\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\n\tthis.toJSON = function() { return this.toString(false); }\n\n\tthis.toString = function(onlyBase) {\n\t\t// XXX TODO: This is vaguely reasonable, but not complete. fix it...\n\t\tvar a = this._protocol ? this._protocol + \"://\" : \"\"\n\t\tvar b = this._host ? this._host + ((this._port || 80) == 80 ? \"\" : \":\" + this._port) : \"\";\n\t\t\n\t\tif (onlyBase) {\n\t\t\treturn a + b;\n\t\t}\n\t\t\n\t\tvar c = this._path;\n\t\tvar d = this._query ? '?' + this._query : '';\n\t\tvar e = this._anchor ? '#' + this._anchor : '';\n\t\treturn a + b + c + d + e;\n\t};\n});\n\nexports.relativeTo = function(url, base) {\n\tvar url = String(url);\n\tif (base && !/^http(s?):\\/\\//.test(url)) {\n\t\tvar baseURI = new exports(base)\n\t\t\t.setAnchor('')\n\t\t\t.setQuery('')\n\t\t\t.setFile('')\n\t\t\t.toString(url.charAt(0) == '/');\n\n\t\turl = exports.resolveRelative(baseURI + url);\n\t}\n\n\treturn new URI(url);\n}\n\nexports.resolveRelative = function(url) {\n\tvar prevUrl;\n\t\n\t// remove ../ with preceeding folder\n\twhile((prevUrl = url) != (url = url.replace(/(^|\\/)([^\\/]+)\\/\\.\\.\\//g, '/'))) {};\n\t\n\t// remove ./ if it isn't preceeded by a .\n\treturn url.replace(/[^.]\\.\\//g, '');\n}\n\nexports.buildQuery = function(kvp) {\n\tvar pairs = [];\n\tfor (var key in kvp) {\n\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(kvp[key]));\n\t}\n\treturn pairs.join('&');\n}\n\nexports.parseQuery = function(str) {\n\tvar pairs = str.split('&'),\n\t\tn = pairs.length,\n\t\tdata = {};\n\tfor (var i = 0; i < n; ++i) {\n\t\tvar pair = pairs[i].split('='),\n\t\t\tkey = decodeURIComponent(pair[0]);\n\t\tif (key) { data[key] = decodeURIComponent(pair[1]); }\n\t}\n\treturn data;\n}\n\n// Regexs are based on parseUri 1.2.2\n// Original: (c) Steven Levithan <stevenlevithan.com>\n// Original: MIT License\n\nvar strictRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar looseRegex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar queryStringRegex = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\nexports.parse = function(str, isStrict) {\n\tvar regex = isStrict ? strictRegex : looseRegex;\n\tvar result = {};\n\tvar match = regex.exec(str);\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\tresult[attr] = match[i] || \"\";\n\t}\n\t\n\tvar qs = result['queryKey'] = {};\n\tresult['query'].replace(queryStringRegex, function(check, key, val) {\n\t\tif (check) {\n\t\t\tqs[key] = val;\n\t\t}\n\t});\n\t\n\treturn result;\n}\n\nexports.isSameDomain = function(urlA, urlB) {\n\tvar a = exports.parse(urlA);\n\tvar b = exports.parse(urlB);\n\treturn ((a.port == b.port ) && (a.host == b.host) && (a.protocol == b.protocol));\n};\n","pre":true},"sdk/jsio/preprocessors/import.js":{"path":"sdk/jsio/preprocessors/import.js","friendlyPath":"preprocessors.import","directory":"sdk/jsio/preprocessors/","filename":"import.js","src":"var importExpr = /^(\\s*)(import\\s+[^=+*\"'\\r\\n;\\/]+|from\\s+[^=+\"'\\r\\n;\\/]+)(;|\\/|$)/gm;\n\nfunction replace(raw, p1, p2, p3) {\n\tif (!/\\/\\//.test(p1)) {\n\t\treturn p1 + 'jsio(\"' + p2 + '\")' + p3;\n\t}\n\treturn raw;\n}\n\nexports = function (path, moduleDef, opts) {\n\tmoduleDef.src = moduleDef.src.replace(importExpr, replace);\n}\n","pre":true},"sdk/jsio/preprocessors/cls.js":{"path":"sdk/jsio/preprocessors/cls.js","friendlyPath":"preprocessors.cls","directory":"sdk/jsio/preprocessors/","filename":"cls.js","src":"\n// var F = exports = Class\n// exports = Class\nvar classExport = /^(.*?)exports[ \\t]*=[ \\t]*Class\\(/gm;\n\n// var F = Class\n// exports.F = Class\n// var F = exports.F = Class\nvar class2Export = /^(.*?[ \\t]+)?([a-zA-Z0-9\\.$]+)[ \\t]*=[ \\t]*Class\\(/gm;\n\nfunction replacer(base, prefix, name) {\n\treturn name + '=__class__;' + (prefix || '') + name + '=' + name + '(function ' + name.replace(/[\\.]/g, '_') + '(){return this.init&&this.init.apply(this,arguments)},';\n}\n\nexports = function(path, moduleDef, opts) {\n\tvar moduleCtor = moduleDef.path.replace(/(^[.\\/]+|\\.([^.]+?)$)/g, '').replace(/[\\:\\\\\\/\\-\\.]/g, '_');\n\tmoduleDef.src = moduleDef.src\n\t\t.replace(classExport, 'var ' + moduleCtor + '=__class__;$1exports=' + moduleCtor + '(function ' + moduleCtor + '(){return this.init&&this.init.apply(this,arguments)},')\n\t\t.replace(class2Export, replacer);\n}\n","pre":true},"sdk/gc/browser/simulateDevice.js":{"path":"sdk/gc/browser/simulateDevice.js","friendlyPath":".simulateDevice","directory":"sdk/gc/browser/","filename":"simulateDevice.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.Enum\");\n\n// TODO: add isMobileNative and isMobileBrowser into resolutions.js (don't need to do a lookup) and remove these Enums\nvar mobile = new lib.Enum('ipad', 'iphone5', 'iphone', 'ios', 'nexus');\nvar mobileBrowser = new lib.Enum('iphone-browser', 'ipad-browser', 'nexus-s-browser');\n\nexports.simulate = function(params) {\n\tif (params.userAgent) {\n\t\tvar navigator = window.navigator;\n\t\tvar shim = window.navigator = {};\n\t\tfor (var i in navigator) {\n\t\t\tshim[i] = navigator[i];\n\t\t}\n\n\t\tshim.userAgent = params.userAgent;\n\t}\n\n\twindow.devicePixelRatio = params.devicePixelRatio || 1;\n\n\tjsio(\"import device\");\n\n\tvar deviceName = params.name.toLowerCase();\n\t\n\tdevice.simulating = params;\n\tdevice.simulatingMobileNative = deviceName in mobile;\n\tdevice.simulatingMobileBrowser = deviceName in mobileBrowser;\n\t\n\tif (device.simulatingMobileBrowser) {\n\t\tdevice.isMobileBrowser = true;\n\t\tdevice.setUseDOM(true);\n\t}\n\n\tif (device.simulatingMobileNative) {\n\t\tdevice.setUseDOM(false);\n\t}\n\n}\n","pre":true},"sdk/jsio/lib/Enum.js":{"path":"sdk/jsio/lib/Enum.js","friendlyPath":"lib.Enum","directory":"sdk/jsio/lib/","filename":"Enum.js","baseMod":"lib","basePath":"sdk/jsio","src":"exports = function() {\n\tif (arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\tvar obj = arguments[0];\n\t\t\tfor (var i in obj) {\n\t\t\t\tif (!(obj[i] in obj)) {\n\t\t\t\t\tobj[obj[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else if (typeof arguments[0] != 'string') {\n\t\t\tkeys = arguments[0];\n\t\t}\n\t}\n\t\n\tif (!keys) { var keys = arguments; }\n\tvar obj = {};\n\tfor(var i = 0, len = keys.length; i < len; ++i) {\n\t\tif (keys[i]) {\n\t\t\tobj[keys[i]] = i + 1;\n\t\t}\n\t\tobj[i + 1] = keys[i];\n\t}\n\treturn obj;\n}","pre":true},"sdk/timestep/device.js":{"path":"sdk/timestep/device.js","friendlyPath":"device","directory":"sdk/timestep/","filename":"device.js","baseMod":"device","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module device;\n *\n * Namespace for the current device. Determines what device we're running using\n * navigator.userAgent. This namespace exposes various properties about the\n * current device, such as screen size, mobile/browser, pixel ratios, etc.\n *\n * Using device.get('...') imports device-specific implementations from\n *   timestep.env.* by default, or from packages registered using\n *   registerDevice().\n * Using device.importUI('...') imports rendering classes for DOM or canvas.\n *\n * @doc http://doc.gameclosure.com/api/device.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/device.md\n */\n\njsio(\"import event.Emitter as Emitter\");\n\nif (typeof navigator == 'undefined' || !navigator.userAgent) {\n\tlogger.warn('> Timestep was unable to determine your device! Please check that navigator.userAgent is defined.');\n\texports = {isUnknown: true};\n}\n\nvar ua = navigator.userAgent;\n\n/**\n * @namespace\n */\n\nvar _devices = {}\nexports.registerDevice = function(name, path) {\n\t_devices[name] = path;\n}\n\nexports.get = function (module) {\n\tvar path = _devices[exports.name] || 'platforms.browser';\n\treturn jsio('import ' + path + '.' + module, {dontExport: true, suppressErrors: true});\n};\n\nexports.importUI = function (module) {\n\treturn jsio('import ui.backend.' + (exports.useDOM ? 'dom' : 'canvas') + '.' + module, {dontExport: true, suppressErrors: true});\n};\n\nexports.isMobileNative = exports.isMobile = /TeaLeaf/.test(ua);\n\nlogger.log(exports.isMobile ? 'on mobile device' : 'in web browser');\n\nexports.screen = new Emitter();\n\nvar devicePixelRatio = window.devicePixelRatio || 1;\n\n// @deprecated\nexports.devicePixelRatio = devicePixelRatio;\n\nexports.screen.devicePixelRatio = devicePixelRatio;\nexports.screen.width = window.screen.width * devicePixelRatio;\nexports.screen.height = window.screen.height * devicePixelRatio;\n\n// This is stubbed out unless available on the current device.\nexports.hideAddressBar = function() {};\n\nexports.defaultFontFamily = 'Helvetica';\n\nif ('ontouchstart' in window && (!/BlackBerry/.test(ua))) {\n\texports.events = {\n\t\tstart: 'touchstart',\n\t\tmove: 'touchmove',\n\t\tend: 'touchend'\n\t};\n} else {\n\texports.events = {\n\t\tstart: 'mousedown',\n\t\tmove: 'mousemove',\n\t\tend: 'mouseup'\n\t};\n}\n\nexports.isMobileBrowser = false;\nexports.isUIWebView = false;\nexports.isSafari = /Safari/.test(ua);\n\nif (exports.isMobile) {\n\texports.name = 'tealeaf';\n\texports.width = navigator.width;\n\texports.height = navigator.height;\n\texports.isAndroid = /Android/.test(ua);\n\tif (!exports.isAndroid) {\n\t\texports.isIPad = /iPad/.test(ua);\n\t\texports.isIPhone = /iPhone/.test(ua);\n\n\t\t// Until we support more platforms, if it's not\n\t\t// Android then it's assumed to be an iOS device\n\t\texports.isIOS = true;\n\t}\n} else {\n\tif (/(iPod|iPhone|iPad)/i.test(ua)) {\n\t\texports.name = 'browser';\n\t\texports.isMobileBrowser = true;\n\t\texports.isIOS = true;\n\t\texports.isUIWebView = !exports.isSafari;\n\n\t\texports.screen.defaultOrientation = 'portrait';\n\t\texports.screen.browserChrome = {\n\t\t\tportrait: {top: 20 * devicePixelRatio, bottom: 44 * devicePixelRatio},\n\t\t\tlandscape: {top: 20 * devicePixelRatio, bottom: 32 * devicePixelRatio}\n\t\t};\n\n\t} else if (/Mobile Safari/.test(ua) || /Android/.test(ua) || /BlackBerry/.test(ua)) {\n\t\texports.name = 'browser';\n\t\texports.isMobileBrowser = true;\n\t\texports.isAndroid = true;\n\n\t\texports.screen.width = window.outerWidth;\n\t\texports.screen.height = window.outerHeight - 1;\n\n\t\texports.screen.defaultOrientation = 'portrait';\n\t\texports.screen.browserChrome = {\n\t\t\tportrait: {top: 0, bottom: 0},\n\t\t\tlandscape: {top: 0, bottom: 0}\n\t\t};\n\t} else {\n\t\t// All other browsers\n\t\texports.height = 600;\n\t\texports.width = 800;\n\n\t\texports.name = 'browser';\n\t\texports.canResize = false;\n\t}\n}\n\nexports.useDOM = false;\nexports.setUseDOM = function (useDOM) {\n\tif (exports.useDOM != useDOM) {\n\t\texports.useDOM = useDOM;\n\n\t\tjsio(\"import ui.View as View\");\n\t\tvar backing = exports.importUI('ViewBacking');\n\t\tView.setDefaultViewBacking(backing);\n\t}\n}\n\nexports.getDimensions = function(isLandscape) {\n\tvar dMin = Math.min(exports.width, exports.height),\n\t\tdMax = Math.max(exports.width, exports.height);\n\n\treturn isLandscape\n\t\t? {height: dMin, width: dMax}\n\t\t: {height: dMax, width: dMin};\n}\n\n/**\n * Initialize the device. Called from somewhere else.\n */\n\nexports.init = function() {\n\tjsio(\"import ui.init\");\n\texports.get('initialize').init();\n\texports.screen.width = exports.width;\n\texports.screen.height = exports.height;\n}\n\n/**\n * Global device accessibility controls. Muting, click, color, font changing, etc.\n */\n\nGLOBAL.ACCESSIBILITY = new (Class(Emitter, function (supr) {\n\tthis.muted = false;\n\n\tthis.mute = function (flag) {\n\t\tthis.muted = flag;\n\t\tthis.publish('MuteChange');\n\t};\n}));\n\nif (GLOBAL.ONACCESSIBLE) {\n\tGLOBAL.ONACCESSIBLE();\n}\n","pre":true},"sdk/timestep/event/Emitter.js":{"path":"sdk/timestep/event/Emitter.js","friendlyPath":"event.Emitter","directory":"sdk/timestep/event/","filename":"Emitter.js","baseMod":"event","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class event.Emitter;\n * Namespace shim to bring in PubSub from jsio.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.emitter\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import lib.PubSub as exports\");\n","pre":true},"sdk/jsio/lib/PubSub.js":{"path":"sdk/jsio/lib/PubSub.js","friendlyPath":"lib.PubSub","directory":"sdk/jsio/lib/","filename":"PubSub.js","src":"/**\n * Summary: inherit from lib.PubSub if a class wants publish/subscribe ability\n * Methods:\n *  - publish(signal, args...) - all subscribers to signal will be called\n *     with the list of arguments provided.\n *  - subscribe(signal, ctx, method, args...) - register a bound method\n *     to a signal.  Any args that are passed in will be the first args\n *     when the method is invoked during a publish.\n *  Usage notes: There is one special signal '__any'.  Any subscribers to\n *     '__any' will be called on every publish with the first publish\n *     argument being the signal itself (after any args passed in during\n *     the corresponding subscribe). \n *     Calling the super constructor is not required for descendants of \n *     lib.PubSub. \n */\n\nvar ctx = jsio.__env.global,\n\tSLICE = Array.prototype.slice;\n\nvar sdk_jsio_lib_PubSub=__class__;exports=sdk_jsio_lib_PubSub(function sdk_jsio_lib_PubSub(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\tthis.init = function () {};\n\t\n\tthis.publish = function (signal) {\n\t\tif (this._subscribers) {\n\t\t\tvar args = SLICE.call(arguments, 1);\n\t\t\tif (this._subscribers.__any) {\n\t\t\t\tvar anyArgs = [signal].concat(args),\n\t\t\t\t\tsubs = this._subscribers.__any.slice(0);\n\t\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\t\tsub.apply(ctx, anyArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!this._subscribers[signal]) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t\n\t\t\tvar subs = this._subscribers[signal].slice(0);\n\t\t\tfor (var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\tsub.apply(ctx, args);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tthis.subscribe = function (signal, ctx, method) {\n\t\tvar cb;\n\t\tif (arguments.length == 2) {\n\t\t\tcb = ctx;\n\t\t} else {\n\t\t\tcb = bind.apply(GLOBAL, SLICE.call(arguments, 1));\n\t\t\tcb._ctx = ctx; // references for unsubscription\n\t\t\tcb._method = method;\n\t\t}\n\t\t\n\t\tvar s = this._subscribers || (this._subscribers = {});\n\t\t(s[signal] || (s[signal] = [])).push(cb);\n\t\treturn this;\n\t};\n\t\n\tthis.subscribeOnce = function (signal, ctx, method) {\n\t\tvar args = arguments,\n\t\t\tcb = bind(this, function () {\n\t\t\t\tthis.unsubscribe(signal, cb);\n\t\t\t\tif (args.length == 2) {\n\t\t\t\t\tctx.apply(GLOBAL, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tbind.apply(GLOBAL, SLICE.call(args, 1))\n\t\t\t\t\t\t.apply(GLOBAL, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\tif (args.length === 3) {\n\t\t\tcb._ctx = ctx;\n\t\t\tcb._method = method;\n\t\t}\n\t\t\n\t\treturn this.subscribe(signal, cb);\n\t};\n\t\n\t// If no method is specified, all subscriptions with a callback context\n\t// of ctx will be removed.\n\n\tthis.unsubscribe = function (signal, ctx, method) {\n\t\tif (!this._subscribers || !this._subscribers[signal]) {\n\t\t\treturn this;\n\t\t}\n\t\tvar subs = this._subscribers[signal];\n\t\tfor (var i = 0, c; c = subs[i]; ++i) {\n\t\t\tif (c == ctx || c._ctx == ctx && (!method || c._method == method)) {\n\t\t\t\tsubs.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * EventEmitter-style API\n\t * http://nodejs.org/api/events.html\n\t */\n\n\tthis.listeners = function (type) {\n\t\tthis._subscribers = (this._subscribers ? this._subscribers : {});\n\t\treturn (this.hasOwnProperty.call(this._subscribers, type))\n\t\t\t? this._subscribers[type]\n\t\t\t: (this._subscribers[type] = []);\n\t};\n\n\tthis.addListener = this.on = function (type, f) {\n\t\tif (this.listeners(type).length + 1 > this._maxListeners && this._maxListeners !== 0) {\n\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\tconsole.warn(\"Possible EventEmitter memory leak detected. \" + this._subscribers[type].length + \" listeners added. Use emitter.setMaxListeners() to increase limit.\");\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"newListener\", type, f);\n\t\treturn this.subscribe(type, this, f);\n\t};\n\n\tthis.once = function (type, f) {\n\t\treturn this.subscribeOnce(type, this, f);\n\t};\n\n\tthis.removeListener = function (type, f) {\n\t\tthis.unsubscribe(type, this, f);\n\t\treturn this;\n\t};\n\n\tthis.removeAllListeners = function (type) {\n\t\tif (this._subscribers) {\n\t\t\tfor (var k in this._subscribers) {\n\t\t\t\tif (type == null || type == k) {\n\t\t\t\t\tdelete this._subscribers[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.emit = function (type) {\n\t\tthis.publish.apply(this, arguments);\n\t\treturn this.listeners(type).length > 0;\n\t};\n\n\tthis._maxListeners = 10;\n\n\tthis.setMaxListeners = function (_maxListeners) {\n\t\tthis._maxListeners = _maxListeners;\n\t};\n\n\tthis.hasListeners = function (type) {\n\t\treturn this._subscribers && this._subscribers[type] && this._subscribers[type].length;\n\t};\n});\n\n","pre":true},"sdk/timestep/platforms/browser/doc.js":{"path":"sdk/timestep/platforms/browser/doc.js","friendlyPath":".doc","directory":"sdk/timestep/platforms/browser/","filename":"doc.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"import lib.Enum as Enum\");\njsio(\"import std.js as JS\");\njsio(\"from util.browser import $\");\n\njsio(\"import device\");\n\nvar SCALING = Enum('FIXED', 'RESIZE', 'MANUAL');\nvar defaultScalingMode = device.isMobileBrowser || device.simulating ? SCALING.RESIZE : SCALING.FIXED;\n\n/**\n * @extends lib.PubSub\n */\nDocument=__class__;var Document=Document(function Document(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\tthis.init = function() {\n\t\tif (!$) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar doc = GLOBAL.document,\n\t\t\tbody = doc && doc.body;\n\t\t\n\t\tthis._el = $({\n\t\t\tparent: body,\n\t\t\tstyle: {\n \t\t\t\tposition: 'absolute',\n\t\t\t\toverflow: 'hidden',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%'\n\t\t\t}\n\t\t});\n\t\t\n\t\tdevice.screen.subscribe('Resize', this, 'onResize');\n\t\t\n\t\tif (exports.postCreateHook) { exports.postCreateHook(this); }\n\t\tthis.setScalingMode(defaultScalingMode);\n\t}\n\t\n\tthis.unsubscribeResize = function () {\n\t\tdevice.screen.unsubscribe('Resize', this, 'onResize');\n\t}\n\t\n\tthis.setEngine = function (engine) {\n\t\tif (engine == this._engine) { return; }\n\t\t\n\t\tthis._engine = engine;\n\t\tthis._canvas = this._engine.getCanvas();\n\t\tthis.appendChild(this._canvas);\n\n\t\tif (this._canvas.getContext) {\n\t\t\tvar ctx = this._canvas.getContext(window.WebGLRenderingContext ? 'webgl' : '2d');\n\t\t\tif (ctx.setParentNode) {\n\t\t\t\tctx.setParentNode(this._el);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.getElement = function () {\n\t\treturn this._el;\n\t};\n\t\n\tthis.setScalingMode = function(scalingMode, opts) {\n\t\tthis._scalingMode = scalingMode;\n\t\t\n\t\tvar el = this._el,\n\t\t\ts = el.style;\n\t\t\n\t\tswitch (scalingMode) {\n\t\t\tcase SCALING.FIXED:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\twidth: device.width,\n\t\t\t\t\t\theight: device.height\n\t\t\t\t\t});\n\t\t\t\ts.width = opts.width + 'px';\n\t\t\t\ts.height = opts.height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\tresizeCanvas: true\n\t\t\t\t\t});\n\t\t\t\t// fall through:\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\ts.margin = '0px';\n\t\t\t\ts.width = '100%';\n\t\t\t\ts.height = '100%';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._scalingOpts = opts;\n\t\tthis.onResize();\n\t\tsetTimeout(bind(this, 'onResize'), 1000);\n\t}\n\t\n\tthis.onResize = function() {\n\t\tvar el = this._el;\n\t\tvar s = this._el.style;\n\t\t\n\t\tel.className = device.screen.orientation;\n\t\tlogger.log('resize', device.width, device.height);\n\t\t\n\t\tvar width = device.width;\n\t\tvar height = device.height;\n\t\tvar mode = this._scalingMode;\n\t\tvar opts = this._scalingOpts;\n\t\t\n\t\tif (mode == SCALING.FIXED) {\n\t\t\twidth = opts.width;\n\t\t\theight = opts.height;\n\t\t}\n\t\t\n\t\t// enforce maxWidth/maxHeight\n\t\t// if maxWidth/maxHeight is met, switch a RESIZE scaling mode to FIXED (center the document on the screen)\n\t\tif (opts.maxWidth && width > opts.maxWidth) {\n\t\t\twidth = opts.maxWidth;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tif (opts.maxHeight && height > opts.maxHeight) {\n\t\t\theight = opts.maxHeight;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tswitch (mode) {\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\tbreak; // do nothing\n\t\t\tcase SCALING.FIXED:\n\t\t\t\t// try to center the container\n\t\t\t\tel.style.top = Math.round(Math.max(0, (window.innerHeight - height) / 2)) + 'px';\n\t\t\t\tel.style.left = Math.round(Math.max(0, (window.innerWidth - width) / 2)) + 'px';\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\t// if we have a canvas element, scale it\n\t\t\t\tif (opts.resizeCanvas && this._canvas\n\t\t\t\t\t\t&& (this._canvas.width != width || this._canvas.height != height)) {\n\t\t\t\t\tthis._canvas.width = width;\n\t\t\t\t\tthis._canvas.height = height;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// make sure to force a render immediately (should we use needsRepaint instead?)\n\t\tthis._setDim(width, height);\n\t\tif (this._engine) { this._engine.render(); }\n\t}\n\t\n\tthis._setDim = function(width, height) {\n\t\tif (this.width != width || this.height != height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.publish('Resize', width, height);\n\t\t}\n\t}\n\t\n\tthis.setColors = function(bgColor, engineColor) {\n\t\tif (this._el) {\n\t\t\tthis._el.style.background = engineColor;\n\t\t\tdocument.documentElement.style.background = document.body.style.background = bgColor;\n\t\t}\n\t}\n\t\n\tthis.appendChild = function(el) {\n\t\tthis._el.appendChild(el);\n\t}\n\t\n\tthis.getOffset = function() {\n\t\treturn {\n\t\t\tx: this._el.offsetLeft,\n\t\t\ty: this._el.offsetTop\n\t\t};\n\t}\n});\n\nexports = new Document();\nexports.SCALING = SCALING;\n\nexports.setDocStyle = function() {\n\tvar doc = GLOBAL.document,\n\t\tbody = doc && doc.body;\n\t\n\tif (body) {\n\t\tvar docStyle = {\n\t\t\theight: '100%',\n\t\t\tmargin: '0px',\n\t\t\tpadding: '0px'\n\t\t};\n\t\n\t\t$.style(document.documentElement, docStyle);\n\t\t$.style(document.body, docStyle);\n\t}\n}\n\nexports.defaultParent = null;\nexports.postCreateHook = null;\n","pre":true},"sdk/jsio/std/js.js":{"path":"sdk/jsio/std/js.js","friendlyPath":"std.js","directory":"sdk/jsio/std/","filename":"js.js","src":"var SLICE = Array.prototype.slice;\n\nexports.vargs = function(args, n) { return SLICE.call(args, n || 0); }\nexports.isArray = function(input) { return Object.prototype.toString.call(input) === '[object Array]'; }\n\nexports.shallowCopy = function(input) {\n\tif (exports.isArray(input)) {\n\t\treturn input.slice(0);\n\t} else {\n\t\tvar out = {};\n\t\tfor (var key in input) {\n\t\t\tif (input.hasOwnProperty(key)) {\n\t\t\t\tout[key] = input[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn out;\n}\n\nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\nexports.curry = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function() { this[method].apply(ctx, args.concat(SLICE.call(arguments))); }\n\t\t\t\t: function() { method.apply(this, args.concat(SLICE.call(arguments))); }\n\tf.curried = true;\n\treturn f;\n}\n\nexports.unbind = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function(ctx) { ctx[method].apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\t\t\t\t: function(ctx) { method.apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\tf.unbound = true;\n\treturn f;\n}\n\n","pre":true},"sdk/jsio/util/browser.js":{"path":"sdk/jsio/util/browser.js","friendlyPath":"util.browser","directory":"sdk/jsio/util/","filename":"browser.js","src":"if (jsio.__env.name == 'browser') {\n\tjsio('external .sizzle import Sizzle');\n\tjsio('import math.geom.Rect');\n\t\n\tfunction isWindow(el) {\n\t\treturn el && !$.isElement(el) && $.isElement(el.document);\n\t}\n\t\n\tvar singleId = /^#([\\w-]+)$/;\n\t\n\tvar $ = exports.$ = function(selector, win) {\n\t\tswitch(typeof selector) {\n\t\t\tcase 'object':\n\t\t\t\tif ($.isElement(selector)) {\n\t\t\t\t\treturn $.remove(selector);\n\t\t\t\t} else if ($.isElement(selector.document && selector.document.body)) {\n\t\t\t\t\treturn $.size(selector);\n\t\t\t\t}\n\t\t\t\treturn $.create(selector);\n\t\t\tcase 'string':\n\t\t\t\tif (singleId.test(selector)) { return $.id(selector.substring(1), win); }\n\t\t\t\treturn Sizzle.apply(GLOBAL, arguments);\n\t\t}\n\t}\n\t\n\tvar DOM2 = typeof HTMLElement === \"object\";\n\t$.isElement = DOM2\n\t\t? function(el) { return el && el instanceof HTMLElement; }\n\t\t: function(el) { return el && typeof el.nodeType == 'number' && typeof el.nodeName == 'string' };\n\t\n\t$.id = function(id, win) { return typeof id == 'string' ? (win || window).document.getElementById(id) : id; }\n\n\t$.apply = function(el, params) {\n\t\tif (params.attrs) {\n\t\t\tfor(attr in params.attrs) {\n\t\t\t\tel.setAttribute(attr, params.attrs[attr]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (params.id) { el.id = params.id; }\n\t\tif (params.style) { $.style(el, params.style); }\n\t\tif (params.src) { el.src = params.src; }\n\t\tif (params['class'] || params['className']) {\n\t\t\tel.className = params['class'] || params['className'];\n\t\t}\n\t\t\n\t\tvar parent = params.parent || params.parentNode;\n\t\tif (parent && params.first) {\n\t\t\t$.insertBefore(parent, el, parent.firstChild);\n\t\t} else if (params.before) {\n\t\t\t$.insertBefore(params.before.parentNode || parent, el, params.before);\n\t\t} else if (params.after) {\n\t\t\t$.insertAfter(params.after.parentNode || parent, el, params.after);\n\t\t} else if (parent) {\n\t\t\tparent.appendChild(el);\n\t\t}\n\t\t\n\t\tif ('html' in params) { el.innerHTML = params.html; }\n\t\tif ('text' in params) { $.setText(el, params.text); }\n\t\t\n\t\tif (params.children) {\n\t\t\tvar c = params.children;\n\t\t\tfor (var i = 0, n = c.length; i < n; ++i) {\n\t\t\t\tel.appendChild($.isElement(c[i]) ? c[i] : $(c[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn el;\n\t}\n\t\n\t$.insertBefore = function(parentNode, el, beforeNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (beforeNode && beforeNode.parentNode == parentNode) {\n\t\t\tparentNode.insertBefore(el, beforeNode);\n\t\t} else {\n\t\t\tparentNode.appendChild(el);\n\t\t}\n\t}\n\t\n\t$.insertAfter = function(parentNode, el, afterNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (!afterNode || afterNode.parentNode != parentNode) {\n\t\t\t$.insertBefore(parentNode, el, parentNode.firstChild);\n\t\t} else if (!afterNode.nextSibling) {\n\t\t\tparentNode.appendChild(el);\n\t\t} else {\n\t\t\tparentNode.insertBefore(el, afterNode.nextSibling);\n\t\t}\n\t}\n\n\t$.create = function(params) {\n\t\tvar doc = ((params && params.win) || window).document;\n\t\tif (!params || typeof params == 'string') {\n\t\t\treturn doc.createElement(params || 'div');\n\t\t};\n\n\t\treturn $.apply(params.el || doc.createElement(params.tag || params.tagName || 'div'), params);\n\t}\n\n\t$.show = function(el, how) { $.id(el).style.display = how || 'block'; }\n\t$.hide = function(el) { $.id(el).style.display = 'none'; }\n\n\t// accepts an array or a space-delimited string of classNames\n\t$.addClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tif (typeof classNames == \"string\") {\n\t\t\tclassNames = classNames.split(' ');\n\t\t}\n\t\n\t\tvar current = ' ' + el.className + ' ';\n\t\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\t\tvar c = classNames[i];\n\t\t\tif (current.indexOf(' ' + c + ' ') == -1) {\n\t\t\t\tcurrent += c + ' ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tel.className = current.replace(/^\\s+|\\s+$/g, '');\n\t\treturn $;\n\t}\n\t\n\t$.getTag = function(from, tag) { return from.getElementsByTagName(tag); }\n\n\t$.removeClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tel.className = (' ' + el.className + ' ')\n\t\t\t.replace(' ', '  ')\n\t\t\t.replace(new RegExp('( ' + classNames.replace('\\s+', ' | ').replace('-','\\-') + ' )', 'g'), ' ')\n\t\t\t.replace(/\\s+/, ' ')\n\t\t\t.replace(/^\\s+|\\s+$/g, '');\n\t}\n\n\tfunction ieGetAlpha(el) {\n\t\ttry {\n\t\t\treturn el.filters.item(\"alpha\");\n\t\t} catch(e) {}\n\t\n\t\ttry {\n\t\t\treturn el.filters.item(\"progid:DXImageTransform.Microsoft.Alpha\");\n\t\t} catch(e) {}\n\t\n\t\treturn null;\n\t}\n\n\t$.style = function(el, style) {\n\t\tif(el instanceof Array) {\n\t\t\tfor(var i = 0, o; o = el[i]; ++i) { $.style(o, style); }\n\t\t\treturn;\n\t\t}\n\t\n\t\tel = $.id(el);\n\t\tvar s = el.style;\n\t\tfor(prop in style) {\n\t\t\tswitch(prop) {\n\t\t\t\tcase 'styleFloat':\n\t\t\t\tcase 'cssFloat':\n\t\t\t\tcase 'float':\n\t\t\t\t\ts.styleFloat = s.cssFloat = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opacity':\n\t\t\t\t\ts.opacity = style[prop];\n\t\t\t\t\tif(el.filters) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar alpha = ieGetAlpha();\n\t\t\t\t\t\t\tvar opacity = style[prop] == 1 ? 99.99 : style[prop] * 100;\n\t\t\t\t\t\t\tif(!alpha) {\n\t\t\t\t\t\t\t\t// TODO: this might destroy any existing filters?\n\t\t\t\t\t\t\t\ts.filter = \"alpha(opacity=\" + opacity + \")\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talpha.Opacity = opacity;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'borderRadius':\n\t\t\t\t\ts.borderRadius = s.MozBorderRadius = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boxSizing':\n\t\t\t\t\ts.MsBoxSizing = s.MozBoxSizing = s.WebkitBoxSizing = style[prop];\n\t\t\t\tdefault:\n\t\t\t\t\ts[prop] = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t$.onEvent = function(el, name, f) {\n\t\tif (typeof f != 'function') {\n\t\t\tf = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 2));\n\t\t}\n\t\n\t\tvar handler = f;\n\t\n\t\tel = $.id(el);\n\t\tif(el.addEventListener) { \n\t\t\tel.addEventListener(name, handler, false);\n\t\t} else {\n\t\t\thandler = function(e) {\n\t\t\t\tvar evt = e || window.event;\n\t\t\t\t// TODO: normalize the event object\n\t\t\t\tf(evt);\n\t\t\t};\n\t\t\n\t\t\tel.attachEvent('on' + name, handler);\n\t\t}\n\t\n\t\treturn bind($, 'removeEvent', el, name, handler);\n\t};\n\n\t$.removeEvent = function(el, name, f) {\n\t\tel = $.id(el);\n\t\tif (el.addEventListener) {\n\t\t\tel.removeEventListener(name, f, false);\n\t\t} else {\n\t\t\tel.detachEvent('on' + name, f);\n\t\t}\n\t}\n\n\t$.stopEvent = function(e) {\n\t\tif (e) {\n\t\t\te.cancelBubble = true;\n\t\t\tif(e.stopPropagation) e.stopPropagation();\n\t\t\tif(e.preventDefault) e.preventDefault();\n\t\t}\n\t}\n\n\t$.setText = function(el, text) {\n\t\tel = $.id(el);\n\t\ttext = String(text);\n\t\tif ('textContent' in el) {\n\t\t\tel.textContent = text;\n\t\t} else if ('innerText' in el) {\n\t\t\tel.innerText = text.replace(/\\n/g, ' ');\n\t\t} else {\n\t\t\tel.innerHTML = '';\n\t\t\tel.appendChild(document.createTextNode(text));\n\t\t}\n\t}\n\n\t$.setValue = function(el, value) {\n\t\tel = $.id(el);\n\t\tif ('value' in el) {\n\t\t\tel.value = value;\n\t\t} else if ('value' in el.firstChild) {\n\t\t\tel.firstChild.value = value;\n\t\t}\n\t};\n\n\t$.remove = function(el) {\n\t\tel = $.id(el);\n\t\tif(el && el.parentNode) {\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t}\n\n\t$.cursorPos = function(ev, el) {\n\t\tvar offset = $.pos(el);\n\t\toffset.top = ev.clientY - offset.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n\t\toffset.left = ev.clientX - offset.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft);\n\t\treturn offset;\n\t}\n\n\t$.pos = function(el) {\n\t\tvar parent = el;\n\t\tvar offset = {top: 0, left: 0};\n\t\twhile(parent && parent != document.body) {\n\t\t\toffset.left += parent.offsetLeft;\n\t\t\toffset.top += parent.offsetTop;\n\t\t\twhile(parent.offsetParent != parent.parentNode) {\n\t\t\t\toffset.top -= parent.scrollTop; offset.left -= parent.scrollLeft;\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t\tparent = parent.offsetParent;\n\t\t}\n\t\treturn offset;\n\t}\n\t\n\t$.size = function(el) {\n\t\tif ($.isElement(el)) {\n\t\t\treturn {width: el.offsetWidth, height: el.offsetHeight};\n\t\t} else if (el.document) {\n\t\t\tvar doc = el.document.documentElement || el.document.body;\n\t\t\treturn new math.geom.Rect(\n\t\t\t\tdoc.offsetTop,\n\t\t\t\tdoc.offsetLeft,\n\t\t\t\tel.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\t\tel.innerHeight || (doc.clientHeight || doc.clientHeight)\n\t\t\t);\n\t\t}\n\t}\n\t\n\t$.insertCSSFile = function(filename) {\n\t\tdocument.getElementsByTagName('head')[0].appendChild($({\n\t\t\ttag: 'link',\n\t\t\tattrs: {\n\t\t\t\trel: 'stylesheet',\n\t\t\t\ttype: 'text/css',\n\t\t\t\thref: filename\n\t\t\t}\n\t\t}));\n\t}\n}\n","pre":true},"sdk/jsio/util/sizzle.js":{"path":"sdk/jsio/util/sizzle.js","friendlyPath":".sizzle","directory":"sdk/jsio/util/","filename":"sizzle.js","src":"/*!\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nSizzle = (function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tvar origContext = context = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context);\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it'll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\t\t\tvar ret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tvar ret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray(set);\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow \"Syntax error, unrecognized expression: \" + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function(results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = false;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName(\"*\");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\n\t\tisXMLFilter = set && set[0] && isXML(set[0]);\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow \"Syntax error, unrecognized expression: \" + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}\n\t},\n\trelative: {\n\t\t\"+\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag && !isXML ) {\n\t\t\t\tpart = part.toUpperCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t\">\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t\"~\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( chunker.exec(match[3]).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toUpperCase() === \"BUTTON\";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'only':\n\t\t\t\tcase 'first':\n\t\t\t\t\twhile ( (node = node.previousSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == 'first') return true;\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase 'last':\n\t\t\t\t\twhile ( (node = node.nextSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'nth':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( \"sourceIndex\" in document.documentElement ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( document.createRange ) {\n\tsortOrder = function( a, b ) {\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.selectNode(a);\n\t\taRange.collapse(true);\n\t\tbRange.selectNode(b);\n\t\tbRange.collapse(true);\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\troot = form = null; // release memory in IE\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute(\"href\", 2);\n\t\t};\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t// Safari can't handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don't work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tfor ( var prop in oldSizzle ) {\n\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n\tvar div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n\n\t// Opera can't find a second classname (in 9.6)\n\tif ( div.getElementsByClassName(\"e\").length === 0 )\n\t\treturn;\n\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\n\tdiv.lastChild.className = \"e\";\n\n\tif ( div.getElementsByClassName(\"e\").length === 1 )\n\t\treturn;\n\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function(match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\tdiv = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ){\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ) {\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== \"HTML\";\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = \"\", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\nreturn Sizzle;\n\n})();\n","pre":true},"sdk/jsio/math/geom/Rect.js":{"path":"sdk/jsio/math/geom/Rect.js","friendlyPath":"math.geom.Rect","directory":"sdk/jsio/math/geom/","filename":"Rect.js","baseMod":"math","basePath":"sdk/jsio","src":"jsio(\"import lib.Enum\");\njsio(\"import .Point\");\njsio(\"import .Line\");\njsio(\"import .intersect\");\n\n/**\n * Model a rectangle.\n */\n\nvar sdk_jsio_math_geom_Rect=__class__;var Rect = exports=sdk_jsio_math_geom_Rect(function sdk_jsio_math_geom_Rect(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0: // init\n\t\t\t\tthis.width = this.height = this.x = this.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1: // copy\n\t\t\t\tthis.width = a.width;\n\t\t\t\tthis.height = a.height;\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tbreak;\n\t\t\tcase 2: // (x, y), (width, height)\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b.x;\n\t\t\t\tthis.height = b.y;\n\t\t\t\tbreak;\n\t\t\tcase 3: // (x, y), width, height\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b;\n\t\t\t\tthis.height = c;\n\t\t\t\tbreak;\n\t\t\tcase 4: // x, y, width, height\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.width = c;\n\t\t\t\tthis.height = d;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize negative height and width dimensions by adjusting the position\n\t * of the rect.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tif (this.width < 0) {\n\t\t\tthis.x -= this.width;\n\t\t\tthis.width = -this.width;\n\t\t}\n\t\t\n\t\tif (this.height < 0) {\n\t\t\tthis.y -= this.height;\n\t\t\tthis.height = -this.height;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generate the intersection of a rectange with another rectangle.\n\t */\n\n\tthis.intersectRect = function (rect) {\n\t\tif (intersect.isRectAndRect(this, rect)) {\n\t\t\tvar x1 = this.x;\n\t\t\tvar y1 = this.y;\n\t\t\tvar x2 = this.x + this.width;\n\t\t\tvar y2 = this.y + this.height;\n\n\t\t\tthis.x = Math.max(x1, rect.x),\n\t\t\tthis.y = Math.max(y1, rect.y),\n\t\t\tthis.width = Math.min(x2, rect.x + rect.width) - this.x;\n\t\t\tthis.height = Math.min(y2, rect.y + rect.height) - this.y;\n\t\t} else {\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\t\n\t/**\n\t * Generate the union of a rectange with another rectangle.\n\t */\n\t\n\tthis.unionRect = function(rect) {\n\t\tthis.normalize();\n\t\tif (rect.normalize) { rect.normalize(); }\n\t\t\n\t\tvar x2 = this.x + this.width,\n\t\t\ty2 = this.y + this.height;\n\t\t\n\t\tvar rx2 = rect.x + rect.width,\n\t\t\try2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = this.x < rect.x ? this.x : rect.x;\n\t\tthis.y = this.y < rect.y ? this.y : rect.y;\n\t\t\n\t\tthis.width = (x2 > rx2 ? x2 : rx2) - this.x;\n\t\tthis.height = (y2 > ry2 ? y2 : ry2) - this.y;\n\t};\n\n\t/**\n\t * Get a point for the given corner.\n\t */\n\t\n\tthis.getCorner = function(i) {\n\t\tswitch(i) {\n\t\t\tcase CORNERS.TOP_LEFT:\n\t\t\t\treturn new Point(this.x, this.y);\n\t\t\tcase CORNERS.TOP_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y);\n\t\t\tcase CORNERS.BOTTOM_LEFT:\n\t\t\t\treturn new Point(this.x, this.y + this.height);\n\t\t\tcase CORNERS.BOTTOM_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y + this.height);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a line corresponding to the given side.\n\t */\n\t\n\tthis.getSide = function(i) {\n\t\tswitch(i) {\n\t\t\tcase SIDES.TOP:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_LEFT), this.getCorner(CORNERS.TOP_RIGHT));\n\t\t\tcase SIDES.RIGHT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_RIGHT), this.getCorner(CORNERS.BOTTOM_RIGHT));\n\t\t\tcase SIDES.BOTTOM:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_RIGHT), this.getCorner(CORNERS.BOTTOM_LEFT));\n\t\t\tcase SIDES.LEFT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_LEFT), this.getCorner(CORNERS.TOP_LEFT));\n\t\t}\n\t}\n\n\t/**\n\t * Return the center point of a rectangle.\n\t */\n\t\n\tthis.getCenter = function() {\n\t\treturn new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t}\n});\n\nvar SIDES = Rect.SIDES = lib.Enum('TOP', 'BOTTOM', 'LEFT', 'RIGHT');\nvar CORNERS = Rect.CORNERS = lib.Enum('TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_RIGHT', 'BOTTOM_LEFT');\n","pre":true},"sdk/jsio/math/geom/Point.js":{"path":"sdk/jsio/math/geom/Point.js","friendlyPath":".Point","directory":"sdk/jsio/math/geom/","filename":"Point.js","src":"/**\n * @package math.geom.Point;\n * Models a Point in 2D space.\n */\n\nvar sdk_jsio_math_geom_Point=__class__;var Point = exports=sdk_jsio_math_geom_Point(function sdk_jsio_math_geom_Point(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.x = a || 0;\n\t\t\t\tthis.y = b || 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Rotates this point around the origin by a value in radians.\n\t */\n\t\n\tthis.rotate = function(r) {\n\t\tvar x = this.x,\n\t\t\ty = this.y,\n\t\t\tcosr = Math.cos(r),\n\t\t\tsinr = Math.sin(r);\n\t\t\n\t\tthis.x = x * cosr - y * sinr;\n\t\tthis.y = x * sinr + y * cosr;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Translate this point by two scalars or by another point.\n\t */\n\t\n\tthis.translate = this.add = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x += x;\n\t\t\tthis.y += y;\n\t\t} else {\n\t\t\tthis.x += x.x;\n\t\t\tthis.y += x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Subtract this point by two scalars or by another point.\n\t */\n\t\n\tthis.subtract = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x -= x;\n\t\t\tthis.y -= y;\n\t\t} else {\n\t\t\tthis.x -= x.x;\n\t\t\tthis.y -= x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Scale this number.\n\t */\n\n\tthis.scale = function(sx, sy) {\n\t\t//if no scaleY specified\n\t\tif(sy === undefined) sy = sx;\n\n\t\tthis.x *= sx;\n\t\tthis.y *= sy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the magnitude of this point at a constant angle.\n\t */\n\t\n\tthis.setMagnitude = function(m) {\n\t\tvar theta = this.getAngle();\n\t\tthis.x = m * Math.cos(theta);\n\t\tthis.y = m * Math.sin(theta);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalize this point to the unit circle.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tvar m = this.getMagnitude();\n\t\tthis.x /= m;\n\t\tthis.y /= m;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add magnitude to this point.\n\t */\n\t\n\tthis.addMagnitude = function(m) {\n\t\treturn this.setMagnitude(this.getMagnitude() + m);\n\t};\n\n\tthis.getMagnitude = function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\n\tthis.getSquaredMagnitude = function() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t};\n\n\tthis.getDirection = this.getAngle = function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t};\n\t\n});\n\n/*\n */\nPoint.getPolarR = function(x, y) { \n\tthrow \"notImplemented\";\n}\n\n/*\n\t### Class Method: Point.getPolarTheta (x, y)\n\t1. `x {number}`\n\t2. `y {number}`\n\t3. Return: `{number}`\n*/\nPoint.getPolarTheta = function(x, y) { \n\tvar val = Math.atan2(y,x) + (Math.PI * 2); \n\treturn val > Math.PI * 2 ? val % (Math.PI * 2) : val;\n}\n\n/*\n\t### Class Method: Point.add (a, b, c, d)\n\t### Class Method: Point.translate (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.add = Point.translate = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).add(b);\n\t\tcase 3: return new Point(a).add(b, c);\n\t\tcase 4: return new Point(a, b).add(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.subtract (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.subtract = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).subtract(b);\n\t\tcase 3: return new Point(a).subtract(b, c);\n\t\tcase 4: return new Point(a, b).subtract(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.scale (a, b, c) \n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.scale = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).scale(b);\n\t\tcase 3: return new Point(a, b).scale(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.setMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n*/\nPoint.setMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).setMagnitude(c);\n\t\tcase 3: return new Point(a, b).setMagnitude(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.addMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.addMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: pt = new Point(a); break;\n\t\tcase 3: pt = new Point(a, b); b = c; break;\n\t}\n\t\n\treturn pt.addMagnitude(b);\n}\n\n/*\n\t### Class Method: Point.getMagnitude (a, b)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. Return: `{Point}`\n */\nPoint.getMagnitude = function(a, b) { return new Point(a, b).getMagnitude(); }\n\n/*\n\t### Class Method: Point.rotate (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.rotate = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).rotate(b);\n\t\tcase 3: return new Point(a, b).rotate(c);\n\t}\n}\n","pre":true},"sdk/jsio/math/geom/Line.js":{"path":"sdk/jsio/math/geom/Line.js","friendlyPath":".Line","directory":"sdk/jsio/math/geom/","filename":"Line.js","src":"jsio(\"import .Point\");\n\nvar sdk_jsio_math_geom_Line=__class__;exports=sdk_jsio_math_geom_Line(function sdk_jsio_math_geom_Line(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.start = new Point();\n\t\t\t\tthis.end = new Point();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.start = new Point(a.start);\n\t\t\t\tthis.end = new Point(a.end);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b, c);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tthis.start = new Point(a, b);\n\t\t\t\tthis.end = new Point(c, d);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.getMagnitude = \n\tthis.getLength = function() {\n\t\tvar dx = this.end.x - this.start.x,\n\t\t\tdy = this.end.y - this.start.y;\n\t\t\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n});\n","pre":true},"sdk/jsio/math/geom/intersect.js":{"path":"sdk/jsio/math/geom/intersect.js","friendlyPath":".intersect","directory":"sdk/jsio/math/geom/","filename":"intersect.js","src":"jsio(\"import .Point\");\njsio(\"import .Line\");\njsio(\"import .Rect\");\n\n/**\n * @package math.geom.intersect\n */\nvar intersect = exports;\n\nintersect.pointAndRect = intersect.ptAndRect = function (pt, rect) {\n\tvar x = pt.x,\n\t\t\ty = pt.y;\n\treturn (x >= rect.x &&\n\t\t\t\t\tx <= rect.x + rect.width &&\n\t\t\t\t\ty >= rect.y &&\n\t\t\t\t\ty <= rect.y + rect.height);\n};\n\nintersect.rectAndPoint = intersect.rectAndPt = function (rect, pt) {\n\treturn intersect.pointAndRect(pt, rect);\n};\n\nintersect.pointAndCircle = intersect.ptAndCirc = function(pt, circle) {\n\tvar dx = pt.x - circle.x,\n\t\t\tdy = pt.y - circle.y;\n\treturn dx * dx + dy * dy < circle.radius * circle.radius;\n};\n\nintersect.circleAndPoint = intersect.circAndPt = function (circle, pt) {\n\treturn intersect.pointAndCircle(pt, circle);\n};\n\nintersect.isRectAndRect = function (rect1, rect2) {\n\treturn !((rect1.y + rect1.height < rect2.y) ||\n\t\t\t\t\t (rect2.y + rect2.height < rect1.y) ||\n\t\t\t\t\t (rect1.x + rect1.width < rect2.x) ||\n\t\t\t\t\t (rect2.x + rect2.width < rect1.x));\n};\n\nintersect.circleAndRect = function(circle, rect) {\n\tif (intersect.pointAndRect(circle, rect)) {\n\t\treturn true;\n\t}\n\treturn (intersect.lineAndCircle(rect.getSide(1), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(2), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(3), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(4), circle));\n};\n\nintersect.rectAndCircle = function(rect, circle) {\n\treturn intersect.circleAndRect(circle, rect);\n};\n\nintersect.lineAndCircle = function (line, circle) {\n\tvar vec = intersect.pointToLine(circle, line);\n\treturn vec.getMagnitude() < circle.radius;\n};\n\nintersect.circleAndLine = function (circle, line) {\n\treturn intersect.lineAndCircle(line, circle);\n};\n\n// returns line from pt to nearest pt on line\nintersect.pointToLine = intersect.ptToLine = function (pt, line) {\n\tvar dx = (line.end.x - line.start.x),\n\t\t\tdy = (line.end.y - line.start.y),\n\t\t\tu = ((pt.x - line.start.x) * dx\t// TODO can we abstract this from 2D to 2D/3D?\n\t\t\t\t\t + (pt.y - line.start.y) * dy) / (dx * dx + dy * dy);\n\n\tvar i;\n\tif (u < 0) {\n\t\ti = new Point(line.start);\n\t} else if (u > 1) {\n\t\ti = new Point(line.end);\n\t} else {\n\t\ti = new Point(line.start.x + u * dx, line.start.y + u * dy);\n\t}\n\treturn new Line(i, pt);\n};\n\n// returns rectangle of intersection\nintersect.rectAndRect = function (rect1, rect2) {\n\tjsio(\"import .Rect\");\n\treturn (intersect.rectAndRect = function(rect1, rect2) {\n\t\tif (rect1 === true) { return new Rect(rect2); }\n\t\tif (rect2 === true) { return new Rect(rect2); }\n\n\t\tif (intersect.isRectAndRect(rect1, rect2)) {\n\t\t\tvar x1 = Math.max(rect1.x, rect2.x),\n\t\t\t\t\ty1 = Math.max(rect1.y, rect2.y),\n\t\t\t\t\tx2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width),\n\t\t\t\t\ty2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n\t\t\treturn new Rect(x1, y1, x2 - x1, y2 - y1);\n\t\t}\n\t\treturn null;\n\t})(rect1, rect2);\n}\n","pre":true},"sdk/timestep/platforms/browser/Audio.js":{"path":"sdk/timestep/platforms/browser/Audio.js","friendlyPath":".Audio","directory":"sdk/timestep/platforms/browser/","filename":"Audio.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package timestep.env.browser.Audio;\n *\n * Audio implementation using the <audio> element for browsers.\n */\n\nexports = function (opts) {\n\tvar defaults = {\n\t\tautoplay: false,\n\t\tpreload: 'auto',\n\t\tvolume: 1.0,\n\t\tloop: 0,\n\t\tsrc: ''\n\t};\n\t\n\topts = merge(opts, defaults);\n\tvar el = document.createElement('Audio');\n\t\n\tel.autoplay = opts.autoplay;\n\tel.preload = opts.preload;\n\tel.volume = opts.volume;\n\tel.loop = opts.loop;\n\tel.src = opts.src;\n\t\n\treturn el;\n};","pre":true},"sdk/timestep/platforms/browser/Canvas.js":{"path":"sdk/timestep/platforms/browser/Canvas.js","friendlyPath":".Canvas","directory":"sdk/timestep/platforms/browser/","filename":"Canvas.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use import\";\n\n/**\n * @package timestep.env.browser.Canvas;\n *\n * Canvas implementation for browsers. Wraps a Context2D.\n */\n\njsio(\"import .Context2D\");\n\nvar sdk_timestep_platforms_browser_Canvas=__class__;exports=sdk_timestep_platforms_browser_Canvas(function sdk_timestep_platforms_browser_Canvas(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {width: 300, height: 200});\n\t\tvar ctx = new Context2D(opts);\n\t\tvar el = this._el = ctx.getElement();\n\t\tel.getContext = function() { return ctx; }\n\t\tel.complete = true;\n\t\treturn el;\n\t}\n});\n","pre":true},"sdk/timestep/platforms/browser/Context2D.js":{"path":"sdk/timestep/platforms/browser/Context2D.js","friendlyPath":".Context2D","directory":"sdk/timestep/platforms/browser/","filename":"Context2D.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package timestep.env.browser.Context2D;\n *\n * Generates a rendering context by creating our own Canvas element.\n */\n\njsio(\"import device\");\njsio(\"import .FontRenderer\");\n\nfunction setter(name) {\n\treturn (function(val) {\n\t\treturn (this[name] = val);\n\t});\n}\n\nfunction getter(name) {\n\treturn (function(val) {\n\t\treturn this[name];\n\t});\n}\n\nexports = function (opts) {\n\tvar parentNode = opts && opts.parent,\n\t\tel = opts && opts.el || document.createElement('canvas');\n\t\n\t//if (!parentNode) {\n\t//\tel.style.cssText = 'position: absolute; top: 0px; left: 0px; z-index: 1';\n\t//}\n\t\n\tel.width = opts.width;\n\tel.height = opts.height;\n\t\n\tvar ctx = el.getContext('2d');\n\tctx.font = '11px ' + device.defaultFontFamily;\n\tctx.getElement = function() { return el; }\n\t\n\tctx.reset = function() {}\n\t\n\tctx.clear = function() {\n\t\t//el.width = el.width;\n\t\tthis.clearRect(0, 0, el.width, el.height);\n\t};\n\t\n\tctx.clipRect = function(x, y, w, h) {\n\t\tctx.beginPath();\n\t\tctx.rect(x, y, w, h);\n\t\tctx.clip();\n\t}\n\t\n\tctx.swap = function() {};\n\tctx.execSwap = function() {};\n\t\n\tctx.circle = function(x, y, radius) {\n\t\tthis.beginPath();\n\t\tthis.arc(x, y, radius, 0, 2 * Math.PI, true);\n\t}\n\n\tvar _lastPointSprite = {\n\t\timg: null,\n\t\tcolor: null,\n\t\tcanvas: null\n\t};\n\n\tctx.drawPointSprites = function(x1, y1, x2, y2) {\n\t\tvar sprite = this.pointSprite;\n\t\tif (!sprite || !sprite.complete) { return; }\n\n\t\tvar width = sprite.width;\n\t\tvar height = sprite.height;\n\t\tvar canvas = _lastPointSprite.canvas || (_lastPointSprite.canvas = document.createElement('canvas'));\n\n\t\tif (sprite != _lastPointSprite.img || this.strokeStyle != _lastPointSprite.color) {\n\t\t\t_lastPointSprite.img = sprite;\n\t\t\t_lastPointSprite.color = this.strokeStyle;\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\tctx.fillStyle = this.strokeStyle;\n\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\tctx.globalCompositeOperation = 'destination-in';\n\t\t\tctx.drawImage(sprite, 0, 0);\n\t\t}\n\n\t\t// Add points to the buffer so there are drawing points every X pixels\n\t\tvar dx = x2 - x1;\n\t\tvar dy = y2 - y1;\n\t\tvar count = Math.ceil(Math.sqrt(dx * dx + dy * dy) / this.pointSpriteStep);\n\t\tif (count < 1) { count = 1; }\n\n\t\tvar d = this.lineWidth;\n\t\tfor (var i = 0; i < count; ++i) {\n\t\t\tvar x = x1 + dx * i / count;\n\t\t\tvar y = y1 + dy * i / count;\n\t\t\tthis.drawImage(canvas, 0, 0, width, height, x - d / 2, y - d / 2, d, d);\n\t\t}\n\t}\n\t\n\tctx.roundRect = function(x, y, width, height, radius) {\n\t\tthis.beginPath();\n\t\tthis.moveTo(x,y+radius);\n\t\tthis.lineTo(x,y+height-radius);\n\t\tthis.quadraticCurveTo(x,y+height,x+radius,y+height);\n\t\tthis.lineTo(x+width-radius,y+height);\n\t\tthis.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);\n\t\tthis.lineTo(x+width,y+radius);\n\t\tthis.quadraticCurveTo(x+width,y,x+width-radius,y);\n\t\tthis.lineTo(x+radius,y);\n\t\tthis.quadraticCurveTo(x,y,x,y+radius);\n\t}\n\n\tctx.loadIdentity = function() {\n\t\tthis.setTransform(1, 0, 0, 1, 0, 0);\n\t}\n\t\n\tctx.measureText = FontRenderer.wrapMeasureText(ctx.measureText);\n\tctx.fillText = FontRenderer.wrapFillText(ctx.fillText);\n\tctx.strokeText = FontRenderer.wrapStrokeText(ctx.strokeText);\n\n\tctx.filters = {}\n\tctx.setFilters = function(filters) {\n\t\tfor (var name in filters) {\n\t\t\tthis.filters[name]  = filters[name];\n\t\t}\n\t}\n\n\tctx.clearFilters = function() {\n\t\tfor (var name in this.filters) {\n\t\t\tdelete this.filters[name];\n\t\t}\n\t}\n\t\n\treturn ctx;\n};\n","pre":true},"sdk/timestep/platforms/browser/FontRenderer.js":{"path":"sdk/timestep/platforms/browser/FontRenderer.js","friendlyPath":".FontRenderer","directory":"sdk/timestep/platforms/browser/","filename":"FontRenderer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package env.browser.FontRenderer;\n *\n * Render fonts or custom fonts on a Canvas context.\n */\n\njsio(\"import ui.resource.Font as Font\");\njsio(\"import ui.Engine as Engine\");\njsio(\"import .FontBuffer as FontBuffer\");\n\n\nvar _customFonts = {},\n\t_customFontInfo = {},\n\t_fontMap = {},\n\t_buffers = [],\n\t_fontBuffer = false;\n\nfunction loadCustomFontImage(customFont, index) {\n\tvar image = new Image();\n\n\timage.onload = function() {\n\t\timage.onload = null;\n\t\tcustomFont.imagesLoaded++;\n\t\tcustomFont.loaded = (customFont.imagesLoaded === customFont.imagesTotal);\n\t}\n\timage.src = 'resources/fonts/' + customFont.filename + index + '.png';\n\n\treturn image;\n}\n\nfunction findVerticalInfo(dimensions) {\n\t// A..Z, a..z, all\n\tvar ranges = [{start: 0x41, end: 0x5A}, {start: 0x61, end: 0x7A}, {start: 0x20, end: 0xFF}];\n\tvar range;\n\tvar dimension;\n\tvar found = false;\n\tvar baseline = 0;\n\tvar bottom = 0;\n\tvar i;\n\n\tfor (i = 0; i < ranges.length; i++) {\n\t\trange = ranges[i];\n\t\tfor (j = range.start; j <= range.end; j++) {\n\t\t\tdimension = dimensions[j];\n\t\t\tif (dimension) {\n\t\t\t\tbaseline = Math.max(baseline, dimension.h);\n\t\t\t\tbottom = Math.max(bottom, dimension.h);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tbaseline: baseline,\n\t\tbottom: bottom\n\t};\n}\n\nfunction findHorizontalInfo(dimensions) {\n\t// a..z, A..Z\n\tvar ranges = [{start: 0x61, end: 0x7A}, {start: 0x41, end: 0x5A}, {start: 0x20, end: 0xFF}];\n\tvar range;\n\tvar dimension;\n\tvar width = 0;\n\tvar count = 0;\n\tvar i, j;\n\n\tfor (i = 0; i < ranges.length; i++) {\n\t\trange = ranges[i];\n\t\tfor (j = range.start; j <= range.end; j++) {\n\t\t\tdimension = dimensions[j];\n\t\t\tif (dimension) {\n\t\t\t\twidth += dimension.w;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count !== 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\twidth: width / count\n\t};\n}\n\nfunction loadingCustomFont (customFont) {\n\tif (customFont.imagesLoaded !== -1) {\n\t \treturn !customFont.loaded;\n\t}\n\n\tvar settings = customFont.settings,\n\t\tfilename = settings.filename,\n\t\timages,\n\t\timage,\n\t\tinfo,\n\t\ti, j;\n\n\tif (_customFontInfo[filename]) {\n\t\tinfo = _customFontInfo[filename];\n\t\tcustomFont.dimensions = info.dimensions;\n\t\tcustomFont.horizontal = info.horizontal;\n\t\tcustomFont.vertical = info.vertical;\n\t} else {\n\t\t// Load from legacy .js extension or newer .json extension.\n\t\tvar basename = 'resources/fonts/' + filename;\n\t\tvar json = CACHE[basename + '.json'];\n\t\tif (json == null) {\n\t\t\tjson = CACHE[basename + '.js'];\n\t\t\tif (json) {\n\t\t\t\tjson = json.replace(/^\\s*exports\\s*=\\s*|;\\s*$/g, '');\n\t\t\t} else {\n\t\t\t\tlogger.warn('Could not load font', customFont.name, 'from cached path', basename);\n\t\t\t}\n\t\t}\n\t\tcustomFont.dimensions = JSON.parse(json);\n\t\tcustomFont.horizontal = findHorizontalInfo(customFont.dimensions);\n\t\tcustomFont.vertical = findVerticalInfo(customFont.dimensions);\n\n\t\t_customFontInfo[filename] = {\n\t\t\tdimensions: customFont.dimensions,\n\t\t\thorizontal: customFont.horizontal,\n\t\t\tvertical: customFont.vertical\n\t\t};\n\t}\n\n\tcustomFont.images = [];\n\tcustomFont.imagesLoaded = 0;\n\n\timages = customFont.images;\n\n\tswitch (customFont.type) {\n\t\tcase 'color':\n\t\t\tfor (i = 0; i < settings.count; i++) {\n\t\t\t\timages[i] = [];\n\t\t\t\timages[i].push(loadCustomFontImage(customFont, '_0_' + i));\n\t\t\t\tcustomFont.imagesTotal++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'composite':\n\t\t\tfor (i = 1; i < 3; i++) {\n\t\t\t\timages[i - 1] = [];\n\t\t\t\tfor (j = 0; j < settings.count; j++) {\n\t\t\t\t\timages[i - 1].push(loadCustomFontImage(customFont, '_' + i + '_' + j));\n\t\t\t\t\tcustomFont.imagesTotal++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n(function() {\n\tvar manifest = window.CONFIG;\n\tif (manifest && manifest.fonts) {\n\t\tvar fonts = manifest.fonts,\n\t\t\tfont,\n\t\t\tcustomFont,\n\t\t\ti = fonts.length;\n\n\t\twhile (i) {\n\t\t\tfont = fonts[--i];\n\t\t\tcustomFont = {\n\t\t\t\tfilename: font.filename,\n\t\t\t\tsettings: font,\n\t\t\t\timagesLoaded: -1,\n\t\t\t\timagesTotal: 0,\n\t\t\t\tloaded: false,\n\t\t\t\ttype: 'color'\n\t\t\t};\n\t\t\t_customFonts[font.contextName + ' color'] = customFont;\n\t\t\tloadingCustomFont(customFont);\n\n\t\t\tcustomFont = {\n\t\t\t\t// The difference between color- and composite-filename is in the suffix!!!\n\t\t\t\tfilename: font.filename,\n\t\t\t\tsettings: font,\n\t\t\t\timagesLoaded: -1,\n\t\t\t\timagesTotal: 0,\n\t\t\t\tloaded: false,\n\t\t\t\ttype: 'composite'\n\t\t\t}\n\t\t\t_customFonts[font.contextName + ' composite'] = customFont;\n\t\t\tloadingCustomFont(customFont);\n\t\t}\n\t}\n})();\n\nfunction getCanvas() {\n\treturn document.createElement('canvas');\n}\n\nfunction getBuffers(srcBuffers, customFont, color, type) {\n\tvar key = customFont.filename + '_' + color + '_' + type,\n\t\tdstBuffers = [],\n\t\ti;\n\n\tif (!_buffers[key]) {\n\t\t_buffers[key] = {\n\t\t\tbuffers: dstBuffers\n\t\t}\n\t\tfor (i = 0; i < srcBuffers.length; i++) {\n\t\t\tvar canvas = getCanvas(),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\twidth = srcBuffers[i].width,\n\t\t\t\theight = srcBuffers[i].height;\n\n\t\t\tdstBuffers[i] = canvas;\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tctx.save();\n\t\t\tctx.fillStyle = color;\n\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\tctx.globalCompositeOperation = 'destination-in';\n\t\t\tctx.drawImage(srcBuffers[i], 0, 0);\n\t\t\tctx.restore();\n\t\t}\n\t}\n\t\n\t_buffers[key].lastUsed = +new Date();\n\treturn _buffers[key].buffers;\n}\n\nfunction measure(fontInfo, text) {\n\tvar customFont = fontInfo.customFont;\n\tvar dimensions = customFont.dimensions;\n\tvar scale = fontInfo.scale;\n\tvar outline = (customFont.settings.outline || 0) * scale;\n\tvar tracking = (customFont.settings.tracking || 0) * scale;\n\tvar width = 0;\n\tvar i, j;\n\n\tif (dimensions) {\n\t\tfor (i = 0, j = text.length; i < j; i++) {\n\t\t\tcharacter = text.charCodeAt(i);\n\t\t\tswitch (character) {\n\t\t\t\tcase 9: // tab...\n\t\t\t\t\twidth += customFont.horizontal.width * 4 * scale;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 32: // space...\n\t\t\t\t\twidth += customFont.horizontal.width * scale;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (dimensions[character]) {\n\t\t\t\t\t\tcharacter = dimensions[character];\n\t\t\t\t\t\twidth += (character.ow - 2) * scale;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidth += tracking - outline;\n\t\t}\n\t}\n\n\treturn {\n\t\twidth: width + 2 * scale\n\t};\n}\n\nfunction renderCustomFont(ctx, x, y, text, color, fontInfo, index) {\n\tvar customFont = fontInfo.customFont,\n\t\tsrcBuffers = customFont.images[index],\n\t\tdimensions = customFont.dimensions,\n\t\tscale = fontInfo.scale,\n\t\twidth = measure(fontInfo, text).width,\n\t\toutline = (customFont.settings.outline || 0) * scale,\n\t\ttracking = (customFont.settings.tracking || 0) * scale;\n\n\tswitch (ctx.textBaseline) {\n\t\tcase 'alphabetic':\n\t\t\ty -= customFont.vertical.baseline * scale;\n\t\t\tbreak;\n\t\tcase 'middle':\n\t\t\ty -= (customFont.vertical.bottom / 2) * scale;\n\t\t\tbreak;\n\t\tcase 'bottom':\n\t\t\ty -= customFont.vertical.bottom * scale;\n\t\t\tbreak;\n\t}\n\n\tswitch (ctx.textAlign) {\n\t\tcase 'center':\n\t\t\tx -= width / 2;\n\t\t\tbreak;\n\t\tcase 'right':\n\t\t\tx -= width;\n\t\t\tbreak;\n\t}\n\n\tvar buffer = false,\n\t\tbufferX = x,\n\t\tbufferY = y,\n\t\tcharacter,\n\t\ti, j;\n\n\tif (buffer) {\n\t\tx = buffer.x;\n\t\ty = buffer.y;\n\t\tctx = buffer.ctx;\n\t}\n\n\tif (customFont.type === 'composite') {\n\t\tsrcBuffers = getBuffers(srcBuffers, customFont, color, index);\n\t}\n\n\tif (!buffer || buffer.refresh) {\n\t\tfor (i = 0, j = text.length; i < j; i++) {\n\t\t\tcharacter = text.charCodeAt(i);\n\t\t\tswitch (character) {\n\t\t\t\tcase 9: // tab...\n\t\t\t\t\tx += customFont.horizontal.width * 4 * scale + tracking - outline;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 32: // space...\n\t\t\t\t\tx += customFont.horizontal.width * scale + tracking - outline;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (dimensions[character]) {\n\t\t\t\t\t\tcharacter = dimensions[character];\n\t\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\t\tsrcBuffers[character.i],\n\t\t\t\t\t\t\tcharacter.x,\n\t\t\t\t\t\t\tcharacter.y,\n\t\t\t\t\t\t\tcharacter.w,\n\t\t\t\t\t\t\tcharacter.h, \n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty + (character.oh - 1) * scale,\n\t\t\t\t\t\t\t(character.w - 2) * scale,\n\t\t\t\t\t\t\t(character.h - 2) * scale\n\t\t\t\t\t\t);\n\t\t\t\t\t\tx += (character.ow - 2) * scale + tracking - outline;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buffer) {\n\t\tthis.drawImage(\n\t\t\tbuffer.ctx.canvas,\n\t\t\tbuffer.x,\n\t\t\tbuffer.y,\n\t\t\tbuffer.width,\n\t\t\tbuffer.height,\n\t\t\tbufferX,\n\t\t\tbufferY,\n\t\t\tbuffer.width,\n\t\t\tbuffer.height\n\t\t);\n\t}\n};\n\n\n\nexports.findFontInfo = function(ctx) {\n\tvar font = Font.parse(ctx.font);\n\tvar name = font.getName();\n\tif (name && _customFonts[name]) {\n\t\tcustomFont = _customFonts[name];\n\t\tfont.customFont = customFont;\n\t\tfont.scale = font.getSize() / customFont.settings.size;\n\t\treturn font;\n\t}\n\n\treturn false;\n}\n\nexports.wrapMeasureText = function(origMeasureText) {\n\treturn function(text) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origMeasureText.apply(this, arguments);\n\t\t}\n\n\t\treturn measure(fontInfo, text);\n\t}\n};\n\nexports.wrapFillText = function(origFillText) {\n\treturn function(text, x, y) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origFillText.apply(this, arguments);\n\t\t}\n\t\tif (loadingCustomFont(fontInfo.customFont)) {\n\t\t\treturn;\n\t\t}\n\n\t\trenderCustomFont(this, x, y, text + '', this.fillStyle, fontInfo, 0);\n\t}\n};\n\nexports.wrapStrokeText = function(origStrokeText) {\n\treturn function(text, x, y) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origStrokeText.apply(this, arguments);\n\t\t}\n\t\tif (loadingCustomFont(fontInfo.customFont)) {\n\t\t\treturn;\n\t\t}\n\n\t\trenderCustomFont(this, x, y, text + '', this.strokeStyle, fontInfo, 1);\n\t}\n};\n\nexports.getFontBuffer = function() {\n\treturn _fontBuffer;\n};\n\n","pre":true},"sdk/timestep/ui/resource/Font.js":{"path":"sdk/timestep/ui/resource/Font.js","friendlyPath":"ui.resource.Font","directory":"sdk/timestep/ui/resource/","filename":"Font.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.resource.Font;\n * Font string parser, a la CSS Font strings. Exports a Font object class.\n * This class is purely informational.\n *\n * @doc http://doc.gameclosure.com/api/ui-text.html#class-ui.resource.font\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/text.md\n */\n\njsio(\"import device\");\n\nvar _cache = {},\n\tweights = 'normal|bold|bolder|lighter|[1-9]00',\n\tstyles = 'normal|italic|oblique',\n\tunits = 'px|pt|pc|in|cm|mm|%',\n\tname = '([\\\\w\\\"\\'\\\\- ]+(?:,|$))+',\n\tfontParser = new RegExp(\n\t\t'^ *'\n\t\t\t+ '(?:(' + weights + ') *)?'\n\t\t\t+ '(?:(' + styles + ') *)?'\n\t\t\t+ '([\\\\d\\\\.]+)(' + units + ')'\n\t\t\t+ '('+ name + ')',\n\t\t\t'i'\n\t),\n\tsizeParser = new RegExp('([\\\\d\\\\.]+)(' + units + ')', 'i'),\n\tTO_PT = {\n\t\t'pt': 1,\n\t\t'px': 3 / 4,\n\t\t'in': 3 / 4 * 96,\n\t\t'mm': 3 / 4 * 96 / 25.4,\n\t\t'cm': 3 / 4 * 96 / 2.54\n\t},\n\tTO_PX = {\n\t\t'pt': 4 / 3,\n\t\t'px': 1,\n\t\t'in': 96,\n\t\t'mm': 96 / 25.4,\n\t\t'cm': 96 / 2.54\n\t};\n\nfunction parseSize(sizeStr, unit) {\n\tvar match = sizeStr.match(sizeParser);\n\tif (!match) { throw 'invalid font size'; }\n\treturn {\n\t\tvalue: parseFloat(match[1]),\n\t\tunit: match[2]\n\t};\n}\n\nfunction toPx(size) {\n\treturn {\n\t\tvalue: size.value * TO_PX[size.unit],\n\t\tunit: 'px'\n\t};\n}\n\nfunction toPt(size) {\n\treturn {\n\t\tvalue: size.value * TO_PT[size.unit],\n\t\tunit: 'pt'\n\t};\n}\n\nfunction parseFont(fontStr) {\n\tvar match = fontStr.match(fontParser);\n\tif (!match) { throw 'invalid font string'; }\n\t\n\tvar res = {};\n\tres.weight = match[1] || 'normal';\n\tres.style = match[2] || 'normal';\n\tres.size = {\n\t\tvalue: parseFloat(match[3]),\n\t\tunit: match[4]\n\t};\n\tres.names = match[5]\n\t\t.split(',')\n\t\t.map(function (str) {\n\t\t\treturn str.replace(/[\\-_]/g, ' ')\n\t\t\t\t.replace(/\\s+/g, ' ')\n\t\t\t\t.replace(/['\"]/g, '')\n\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t});\n\n\tres.name = res.names[0];\n\treturn res;\n};\n\nvar sdk_timestep_ui_resource_Font=__class__;var Font = exports=sdk_timestep_ui_resource_Font(function sdk_timestep_ui_resource_Font(){return this.init&&this.init.apply(this,arguments)},function(){\n\t\n\tvar defaults = {\n\t\tname: device.defaultFontFamily,\n\t\tsize: 20,\n\t\tunit: 'px',\n\t\tstyle: '',\n\t\tweight: ''\n\t};\n\n\tthis.init = function(opts) {\n\t\tif (typeof opts === 'string') {\n\t\t\t_cache[opts] = this;\n\t\t\tthis._string = opts;\n\t\t\topts = parseFont(opts);\n\t\t} else {\n\t\t\topts = merge(opts, defaults);\n\t\t}\n\t\t\n\t\tif (typeof opts.size == 'string') {\n\t\t\topts.size = parseSize(opts.size);\n\t\t}\n\t\t\n\t\tthis._name = opts.name;\n\t\tthis._style = opts.style;\n\t\tthis.size = opts.size;\n\t\tthis.sizePx = toPx(this.size).value;\n\t\tthis.sizePt = toPt(this.size).value;\n\t\tthis._weight = opts.weight;\n\n\t\tthis._isBold = /bold/i.test(this._weight);\n\t};\n\t\n\tthis.getSize = function() { return this.sizePx; }\n\n\tthis.getName = function () { return this._name; }\n\tthis.getWeight = function () { return this._weight; }\n});\n\nexports.parse = function(str) {\n\tif (str in _cache) {\n\t\treturn _cache[str];\n\t} else {\n\t\treturn new Font(str);\n\t}\n}\n","pre":true},"sdk/timestep/ui/Engine.js":{"path":"sdk/timestep/ui/Engine.js","friendlyPath":"ui.Engine","directory":"sdk/timestep/ui/","filename":"Engine.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.Engine\n *\n * This is the game engine for timestep. It is built on a scene graph composed\n * of \"views\", and has canvas and DOM rendering backends.\n *\n * Responsibilities for the application engine includes initializing the canvas,\n * input and key listeners, game loop, animation tick, the view hierarchy and\n * rendering the scene graph.\n *\n * Not to be confused with GC.Application, the superclass exposed to games which\n * controls the game loop. A single ui.Engine is instantiated for\n * games which resides at GC.app.engine.\n *\n * @doc http://doc.gameclosure.com/api/appengine.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/appengine.md\n */\n\njsio(\"import event.Emitter as Emitter\");\n\njsio(\"import event.input.dispatch as dispatch\");\n\njsio(\"import timer\");\njsio(\"import ui.backend.ReflowManager as ReflowManager\");\n\njsio(\"import device\");\n\nvar _timers = [];\ntimer.onTick = function (dt) {\n\tvar i = _timers.length;\n\twhile (i--) {\n\t\t_timers[i](dt);\n\t}\n}\n\nvar __instance = null;\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_Engine=__class__;var Application = exports=sdk_timestep_ui_Engine(function sdk_timestep_ui_Engine(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function(opts) {\n\t\tif (!__instance) {\n\t\t\tjsio(\"import .StackView\");\n\n\t\t\t__instance = this;\n\t\t}\n\n\t\tvar canvas = opts && opts.canvas;\n\t\tif (typeof canvas == 'string' && GLOBAL.document && document.getElementById) {\n\t\t\tcanvas = document.getElementById(canvas);\n\t\t}\n\n\t\tthis._opts = opts = merge(opts, {\n\t\t\tkeyListenerEnabled: true,\n\t\t\twidth: canvas && canvas.width || device.width,\n\t\t\theight: canvas && canvas.height || device.height,\n\t\t\tview: null,\n\t\t\tdtFixed: 0,\n\t\t\tdtMinimum: 0,\n\t\t\tclearEachFrame: true,\n\t\t\talwaysRepaint: true,\n\t\t\trepaintOnEvent: true,\n\t\t\tmergeMoveEvents: false,\n\t\t\tcontinuousInputCheck: !device.isMobileBrowser && !device.isMobile,\n\t\t\tshowFPS: false\n\t\t});\n\n\t\t_timers.push(bind(this, this._tick));\n\n\t\tthis._doubleBuffered = true;\n\t\tthis._countdown = null;\n\n\t\tif (!device.useDOM) {\n\t\t\tvar Canvas = device.get('Canvas');\n\t\t\tthis._rootElement = new Canvas({\n\t\t\t\tel: canvas, // use an existing canvas if one was provided, but wrap the 2D context\n\t\t\t\twidth: opts.width,\n\t\t\t\theight: opts.height,\n\t\t\t\toffscreen: false\n\t\t\t});\n\n\t\t\tthis._ctx = this._rootElement.getContext('2d');\n\t\t\tthis._ctx.font = '11px ' + device.defaultFontFamily;\n\t\t}\n\n\t\tthis._view = opts.view || new StackView();\n\t\tthis._view.style.update({\n\t\t\twidth: opts.width,\n\t\t\theight: opts.height\n\t\t});\n\n\t\tif (device.useDOM) {\n\t\t\tthis._rootElement = this._view.getBacking().getElement();\n\t\t}\n\n\t\t// __root is a pointer to the Engine instance that a view\n\t\t// is currently attached to.  If __root is null, the view\n\t\t// is not currently in a view hierarchy.\n\t\tthis._view.__root = this;\n\t\t\n\t\tthis._events = [];\n\n\t\tif (dispatch.KeyListener) {\n\t\t\tthis._keyListener = new dispatch.KeyListener();\n\t\t}\n\n\t\tthis._inputListener = new dispatch.InputListener({\n\t\t\tel: this._rootElement,\n\t\t\tkeyListener: this._keyListener\n\t\t});\n\n\t\tthis._reflowMgr = ReflowManager.get();\n\n\t\tthis._tickBuffer = 0;\n\t\tthis._onTick = [];\n\n\t\t// configure auto-layout in the browser (expand\n\t\t// to fill the viewport)\n\t\tif (device.name == 'browser') {\n\t\t\tif (canvas) {\n\t\t\t\tdevice.width = canvas.width;\n\t\t\t\tdevice.height = canvas.height;\n\t\t\t\tdevice.screen.width = canvas.width;\n\t\t\t\tdevice.screen.height = canvas.height;\n\t\t\t} else {\n\t\t\t\tvar doc = device.get('doc');\n\t\t\t\tif (doc) {\n\t\t\t\t\tdoc.setEngine(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.updateOpts(this._opts);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\tthis._opts = merge(opts, this._opts);\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(this._opts.keyListenerEnabled);\n\t\t}\n\n\t\tif (this._opts.showFPS) {\n\t\t\tif (!this._applicationFPS) {\n\t\t\t\tjsio(\"import ui.backend.debug.FPSView as FPSView\");\n\t\t\t\tthis._applicationFPS = new FPSView({application: this});\n\t\t\t}\n\t\t\t\n\t\t\tthis._renderFPS = bind(this._applicationFPS, this._applicationFPS.render);\n\t\t\tthis._tickFPS = bind(this._applicationFPS, this._applicationFPS.tick);\n\t\t} else {\n\t\t\tthis._renderFPS = function() {};\n\t\t\tthis._tickFPS = function() {};\n\t\t}\n\t};\n\n\tthis.supports = function(key) { return this._opts[key]; }\n\n\t/* @internal */\n\tthis.getInput = function() { return this._inputListener; }\n\tthis.getKeyListener = function() { return this._keyListener; }\n\n\tthis.getEvents = function() { return this._events; }\n\n\t// deprecating getCanvas...\n\tthis.getElement = \n\tthis.getCanvas = function() { return this._rootElement; }\n\t\n\tthis.getViewCtor = function() { return View; }\n\tthis.getView = function() { return this._view; }\n\tthis.setView = function(view) { this._view = view; return this; }\n\n\tthis.show = function() {\n\t\tthis._rootElement.style.display = 'block';\n\t\treturn this;\n\t};\n\n\tthis.hide = function() {\n\t\tthis._rootElement.style.display = 'none';\n\t\treturn this;\n\t};\n\t\n\tthis.pause = function() {\n\t\tthis.stopLoop();\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(false);\n\t\t}\n\t};\n\n\tthis.resume = function() {\n\t\tthis.startLoop();\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(true);\n\t\t}\n\t};\n\n\tthis.stepFrame = function(n) {\n\t\tthis.pause();\n\t\tn = n || 1;\n\t\tthis._countdown = n;\n\t\tthis.resume();\n\t};\n\n\tthis.startLoop = function(dtMin) {\n\t\tif (this._running) { return; }\n\t\tthis._running = true;\n\t\t\n\t\tthis.now = 0;\n\t\ttimer.start(dtMin || this._opts.dtMinimum);\n\t\treturn this;\n\t};\n\n\tthis.stopLoop = function() {\n\t\tif (!this._running) { return; }\n\t\tthis._running = false;\n\t\t\n\t\ttimer.stop();\n\t\treturn this;\n\t};\n\n\tthis.isRunning = function () {\n\t\treturn this._running;\n\t};\n\n\tthis.doOnTick = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tthis._onTick.push(cb);\n\t};\n\n\tthis._tick = function(dt) {\n\t\t//if the countdown is defined\n\t\tif (this._countdown !== null) {\n\t\t\tthis._countdown--;\n\n\t\t\t//if below zero, stop timer\n\t\t\tif (this._countdown === -1) {\n\t\t\t\tthis.pause();\n\t\t\t\tthis._countdown = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._needsRepaint = false;\n\t\tif (this._ctx) {\n\t\t\tvar el = this._ctx.getElement();\n\t\t\tvar s = this._view.style;\n\t\t\tif (el && (s.width != el.width / s.scale || s.height != el.height / s.scale)) {\n\t\t\t\ts.width = el.width / s.scale;\n\t\t\t\ts.height = el.height / s.scale;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, cb; cb = this._onTick[i]; ++i) { cb(dt); }\n\n\t\tvar events = this._inputListener.getEvents();\n\t\tvar n = events.length;\n\n\t\tthis._events = events;\n\t\tif (this._opts._mergeMoveEvents) {\n\t\t\tvar hasMove = false;\n\t\t\tfor (var i = n - 1; i >= 0; --i) {\n\t\t\t\tif (events[i].type == dispatch.eventTypes.MOVE) {\n\t\t\t\t\tif (!hasMove) { \n\t\t\t\t\t\thasMove = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevents.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, evt; evt = events[i]; ++i) {\n\t\t\tevt.srcApp = this;\n\t\t\tdispatch.dispatchEvent(this._view, evt);\n\t\t}\n\n\t\tif (!device.useDOM) {\n\t\t\tif (i > 0) {\n\t\t\t\tif (this._opts.repaintOnEvent) { this.needsRepaint(); }\n\t\t\t} else if (this._opts.continuousInputCheck) {\n\t\t\t\tvar prevMove = dispatch._evtHistory['input:move'];\n\t\t\t\tif (prevMove) {\n\t\t\t\t\tdispatch.dispatchEvent(this._view, new dispatch.InputEvent(prevMove.id, prevMove.type, prevMove.srcPt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._opts.dtFixed) {\n\t\t\tthis._tickBuffer += dt;\n\t\t\twhile (this._tickBuffer >= this._opts.dtFixed) {\n\t\t\t\tthis._tickBuffer -= this._opts.dtFixed;\n\t\t\t\tthis.now += this._opts.dtFixed;\n\t\t\t\tthis.__tick(this._opts.dtFixed);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.__tick(dt);\n\t\t}\n\n\t\tthis._reflowMgr.startReflow(this._ctx);\n\t\tthis._reflowMgr.setInRender(true);\n\n\t\tvar doRepaint = this._opts.alwaysRepaint || this._needsRepaint;\n\t\tif (!doRepaint && this._doubleBuffered && this._doubleBufferedState > 0) {\n\t\t\t// even if we don't repaint, we need to paint at least 1 more time\n\t\t\t// for devices that use multiple buffers (like the ios, I think...)\n\t\t\t--this._doubleBufferedState;\n\t\t\tthis.render(dt);\n\t\t} else if (doRepaint) {\n\t\t\tthis._doubleBufferedState = 3;\n\t\t\tthis.render(dt);\n\t\t}\n\n\t\tthis._reflowMgr.setInRender(false);\n\t};\n\n\tthis.render = function(dt) {\n\t\tif (this._opts.clearEachFrame) {\n\t\t\tthis._ctx && this._ctx.clear();\n\t\t}\n\n\t\tthis._view.__view.wrapRender(this._ctx, {});\n\t\tthis.publish('Render', this._ctx);\n\n\t\tif (this._ctx) {\n\t\t\tif (DEBUG) {\n\t\t\t\tthis._renderFPS(this._ctx, dt);\n\t\t\t}\n\n\t\t\tthis._ctx.swap();\n\t\t}\n\t};\n\n\tthis.needsRepaint = function() {\n\t\tthis._needsRepaint = true;\n\t\treturn this;\n\t};\n\n\tthis.__tick = function(dt) {\n\t\tthis._tickFPS(dt);\n\t\tthis.publish('Tick', dt);\n\t\tthis._view.__view.wrapTick(dt, this);\n\t};\n\n\tvar log_counter = 0;\n\n});\n\nexports.get = function() { return __instance; };\n","pre":true},"sdk/timestep/event/input/dispatch.js":{"path":"sdk/timestep/event/input/dispatch.js","friendlyPath":"event.input.dispatch","directory":"sdk/timestep/event/input/","filename":"dispatch.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module event.input.dispatch;\n * This namespace includes functions to dispatch touch events starting from the\n * root application view, which are traced through the hierarchy to each view's\n * individual InputHandler proxy. Additionally, this namespace includes those\n * functions actually in timestep.input, like InputListener and KeyListener classes.\n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import device\");\njsio(\"import lib.Enum\");\n\nexports.eventTypes = new lib.Enum('START', 'MOVE', 'SELECT', 'SCROLL', 'CLEAR');\nexports.VERTICAL_AXIS = 2;\nexports.HORIZONTAL_AXIS = 1;\n\n/**\n * capture/bubble event, starting from root Application view\n *  - publish <inputTypeCapture> on the way down (e.g. onInputStartCapture)\n *  - call callbacks (e.g. onInputStart) and publish <inputType> (e.g. onInputstart)\n *    on the way up, checking evt.cancelled to see if someone has cancelled the event\n */\nexports.dispatchEvent = function(root, evt) {\n\t// if (evt.type == input.eventTypes.MOVE) { var now = +new Date(); }\n\t// store the root in case an event listener wants the top-most view?\n\tevt.root = root;\n\t\n\t// SHOULD_HANDLE = LOCALIZE = 0;\n\n\t// grab the bottom-most view whose bounding box contains the evt.srcPt\n\t// also updates the evt object with a trace of localized points and views\n\texports.traceEvt(root, evt, evt.srcPt);\n\n\t// if (now) { logger.log('TRACED A', LOCALIZE, SHOULD_HANDLE) }\n\t\n\t// once we've traced the event, we know how deep it goes\n\tvar depth = evt.depth;\n\t\n\texports._evtHistory[evt.type] = evt;\n\t\n\tvar signal = exports._evtCb[evt.type] || exports.getEvtCbName(evt.type);\n\t\n\tfor (var i = depth - 1; i >= 0; --i) {\n\t\tvar view = evt.trace[i],\n\t\t\tpt = evt.pt[view.uid];\n\t\tview.publish(signal + 'Capture', evt, pt, i == 0);\n\t\tif (evt.cancelled) { return; }\n\t}\n\t\n\tvar cbName = 'on' + signal;\n\tfor (var i = 0; i < depth; ++i) {\n\t\tvar view = evt.trace[i];\n\t\tif (view.__input.canHandleEvents) {\n\t\t\tvar pt = evt.pt[view.uid];\n\t\t\tif (view[cbName]) { view[cbName](evt, pt, i == 0); }\n\t\t\tview.publish(signal, evt, pt, i == 0);\n\t\t\tview._onEventPropagate(evt, pt, i == 0);\n\t\t\tif (evt.cancelled) { break; }\n\t\t}\n\t}\n}\n\n/**\n * Trace an event recursively down to the view on which the event is triggered.\n */\nexports.traceEvt = function(view, evt, pt) {\n\t// var now = +new Date();\n\tvar localPt = view.style.localizePoint(new Point(pt));\n\tvar inputHandler = view.getInput();\n\tif (!inputHandler.containsEvent(evt, localPt)) { return false; }\n\n\tvar canHandleEvents = view.getInput().canHandleEvents;\n\tif (canHandleEvents) {\n\t\tevt.depth++;\n\t\tevt.trace.unshift(view);\n\t\tevt.pt[view.uid] = localPt;\n\t}\n\t\n\tvar subviews = view.getSubviews();\n\tfor (var i = subviews.length - 1; i >= 0; --i) {\n\t\tif (subviews[i].style.visible && exports.traceEvt(subviews[i], evt, localPt)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif (canHandleEvents) {\n\t\tevt.target = view;\n\t\treturn true;\n\t}\n}\n\nexports._evtHistory = {};\nexports._activeInputOver = {};\n\nexports.clearOverState = function (id) {\n\tif (id) {\n\t\tvar evt = exports._activeInputOver[id];\n\t\tif (evt) {\n\t\t\tdelete exports._activeInputOver[id];\n\t\t\tvar trace = evt.trace;\n\t\t\tif (trace) {\n\t\t\t\tfor (var i = 0, view; view = trace[i]; ++i) {\n\t\t\t\t\tview.__input.onLeave(id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var id in exports._activeInputOver) {\n\t\t\texports.clearOverState(id);\n\t\t}\n\t}\n}\n\nexports._isDragging = false;\nexports.isDragging = function() { return exports._isDragging; }\n\nexports._evtCb = {};\nexports.getEvtCbName = function(evtType) {\n\tvar name = exports.eventTypes[evtType];\n\treturn (exports._evtCb[evtType] = 'Input' + name.charAt(0) + name.substring(1).toLowerCase());\n}\n\n/**\n * Aliases for children of the timestep.input \"package\".\n */\n\nexports.InputListener = device.get('Input');\nexports.KeyListener = device.get('KeyListener');\n\njsio(\"import .InputEvent as exports.InputEvent\");\n","pre":true},"sdk/timestep/event/input/InputEvent.js":{"path":"sdk/timestep/event/input/InputEvent.js","friendlyPath":".InputEvent","directory":"sdk/timestep/event/input/","filename":"InputEvent.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class event.input.InputEvent;\n * This class represents an input event.\n * \n * It assumes a tree structure of View objects.  The top (root) of the\n * tree is typically the main Application view.  \n * \n * Events are assigned a root and a target.  View::dispatchEvent\n * computes the root and target from the event location (x, y).\n *\n * Propogation has two phases: capturing and bubbling.  Users \n * can mostly ignore capturing as the primary hooks are in the \n * bubbling.  Bubbling is defined as calling event handlers on\n * each view starting with 'target' and then continuing up \n * superview pointers until reaching 'root'.  Views can listen\n * to the event bubbling by adding methods such as:\n * \"input:start\" -> \"function onInputStart(evt)\"\n * \"input:drag\" -> \"function onDrag(dragEvt, moveEvt, delta)\"\n *\n * Other code can hook into a view's events by calling:\n *   myView.subscribe('input:start', function() { alert('Mouse Down'); });\n *   myView.subscribe('input:end', this, 'onChildViewClick');\n *\n * Propogation of events can be cancelled by calling evt.cancel().\n *\n * Note that onDrag is a special event that receives not only\n * a move event from an 'input:move' event, but also a custom\n * dragEvt object that contains extra data such as the start\n * position of the drag.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.input.inputevent\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import timer\");\n\nvar sdk_timestep_event_input_InputEvent=__class__;var InputEvent = exports=sdk_timestep_event_input_InputEvent(function sdk_timestep_event_input_InputEvent(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.cancelled = false; // If true, this event will not propogate\n\tthis.depth = 0; // Number of levels of the tree from root to target (inclusive)\n\t\n\t// Note that under normal usage:\n\t//   this.depth == this.trace.length\n\t//   this.root = this.trace[this.trace.length - 1]\n\t//   this.target = this.trace[0]\n\t\n\tthis.init = function(id, evtType, x, y, root, target) {\n\t\t// unique ID for a particular input - the ID should be constant for a given input\n\t\t// for example, the mouse should always have the same ID.  Each finger (touch)\n\t\t// should have the same ID throughout the touch start/move/end process\n\t\tthis.id = id; \n\t\t\n\t\t// string evtType, e.g. 'input:start'\n\t\tthis.type = evtType;\n\t\t\n\t\t// localized point coordinates, indexed by a view's uid (View::uid)\n\t\t// @internal --at least for now, concerns over performance.\n\t\tthis.point = this.pt = {};\n\t\t\n\t\t// raw (x, y) coordinates\n\t\tthis.srcPoint = this.srcPt = new Point(x, y);\n\t\t\n\t\t// list of View nodes from target to root\n\t\tthis.trace = [];\n\t\t\n\t\t// Top-most view where event is dispatched (e.g. the tree root)\n\t\tthis.root = root || null;\n\t\t\n\t\t// time of dispatch\n\t\tthis.when = timer.now;\n\t\t\n\t\t// Bottom-most view where the event occurred\n\t\tthis.target = target || null;\n\t}\n\t\n\tthis.cancel = function() {\n\t\tthis.cancelled = true;\n\t}\n\n\tthis.clone = function() {\n\t\treturn new InputEvent(this.id, this.type, this.srcPt.x, this.srcPt.y, this.root, this.target);\n\t}\n});\n","pre":true},"sdk/timestep/timer.js":{"path":"sdk/timestep/timer.js","friendlyPath":"timer","directory":"sdk/timestep/","filename":"timer.js","baseMod":"timer","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module timer\n *\n * Implements an independent, singleton timer for use by the environment.\n * The Application Engine binds to this to generate the rendering tick.\n */\n\njsio(\"import device\");\n\nvar Timer = device.get('Timer');\n\nvar MAX_TICK = 10000; // ticks over 10 seconds will be considered too large to process\nexports.now = 0;\nexports.frames = 0;\nexports.reset = function() { this._last = null; }\nexports.tick = function(dt) {\n\ttry {\n\t\tif (dt > MAX_TICK) {\n\t\t\texports.onLargeTick(dt, MAX_TICK);\n\t\t\tdt = 1;\n\t\t}\n\t\t\n\t\texports.now += dt;\n\t\texports.frames++;\n\t\texports.onTick(dt);\n\t\tok = true;\n\t} finally {\n\t\tif (exports.debug && !ok) {\n\t\t\tapp.stopLoop()\n\t\t}\n\t}\n}\n\n/**\n * If our computer falls asleep, dt might be an insanely large number. \n * If we're running a simulation of sorts, we don't want the computer\n * to freeze while computing 1000s of simulation steps, so just drop\n * this tick.  Anyone who is interested can listen for a call to 'onLargeTick'\n */\nexports.onLargeTick = function(largeDt, threshold) {\n\tlogger.warn('Dropping large tick: ' + largeDt + '; Threshold is set at: ' + threshold);\n}\n\nexports.onTick = function(dt) {}\n\nexports.debug = false;\n\n\n// TODO: <jsio>('from iOS import start as exports.start, stop as exports.stop');\n\nexports.start = function(minDt) {\n\tthis.reset();\n\tthis.isRunning = true;\n\tdevice.get('Timer').start(exports.tick, minDt);\n}\n\nexports.stop = function() {\n\tthis.reset();\n\tthis.isRunning = false;\n\tdevice.get('Timer').stop();\n}\n\nexports.getTickProgress = function() {\n\tvar now = +new Date;\n\treturn (-(Timer.last || now) + now);\n}\n","pre":true},"sdk/timestep/ui/backend/ReflowManager.js":{"path":"sdk/timestep/ui/backend/ReflowManager.js","friendlyPath":"ui.backend.ReflowManager","directory":"sdk/timestep/ui/backend/","filename":"ReflowManager.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar DEBUG = false;\n\nif (DEBUG) {\n\tvar _debug = {\n\t\tspace: '',\n\t\tstepIn: function () { this.space += ' '; return true; },\n\t\tstepOut: function () { this.space = this.space.slice(0, this.space.length - 1); return true; },\n\t\tlog: function () { logger.log.apply(logger, [this.space].concat(Array.prototype.slice.call(arguments, 0))); return true; }\n\t};\n\tlogger.log(\"===== CREATING REFLOW MANAGER\");\n}\n\n// max reflows for any view in a given tick\nvar MAX_REFLOW_THRESHOLD = 6;\n\nvar _pool = new (Class(function () {\n\tthis._pool = [];\n\n\tthis.recycle = function (item) {\n\t\titem.count = 0;\n\t\titem.view = null;\n\t\tthis._pool.push(item);\n\t}\n\n\tthis.get = function (view) {\n\t\tvar item = this._pool.pop() || {};\n\t\titem.view = view;\n\n\t\titem.iter = 0;\n\t\titem.count = 0;\n\t\treturn item;\n\t}\n}));\n\n/**\n * The ReflowManager is the controller for view layout.  It hooks into\n * the render cycle in two places:\n *  1. at the start of a render to reflow any views that we know\n *     need layout.  This is signalled by calling calls to needsReflow\n *     on a view between render cycles that result in a call to \n *     `ReflowMgr.add`.\n *  2. during render, if the view hasn't ever been rendered, the \n *     ReflowManager is notified to initiate the buildView call\n *     and handle any reflow logic before the view's first render.\n * The ReflowManager uses a queue-like structure to resolve the reflow \n * constraints. Views notify the ReflowManager through the add(view) \n * method, which then adds the view to the queue.  During a reflow cycle,\n * the ReflowManager tracks how many iterations through the queue each \n * view actually gets reflowed.  If the number of reflows exceeds the\n * MAX_REFLOW_THRESHOLD, reflow stops for that view, preventing infinite\n * loops when reflow cycles occur.\n */\n\nvar sdk_timestep_ui_backend_ReflowManager=__class__;var ReflowManager = exports=sdk_timestep_ui_backend_ReflowManager(function sdk_timestep_ui_backend_ReflowManager(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tthis._pending = {};\n\t\tthis._iter = 0;\n\t}\n\n\tthis.setInRender = function (isInRender) {\n\t\tthis._isInRender = isInRender;\n\t}\n\n\tthis.add = function (view) {\n\t\tvar uid = view.uid;\n\t\tvar item = this._pending[uid] || (this._pending[uid] = _pool.get(view));\n\n\t\titem.needsReflow = true;\n\n\t\t// increment count once per reflow iteration\n\t\tif (item.iter != this._iter) {\n\t\t\titem.count++;\n\t\t\titem.iter = this._iter;\n\t\t}\n\n\t\tDEBUG && _debug.log('adding view', uid, view.style.width + 'x' + view.style.height, view.getTag());\n\n\t\tif (this._isInRender && !this._isInReflow) {\n\t\t\tthis.startReflow(this._lastCtx);\n\t\t}\n\t}\n\n\tthis._reflow = function (ctx, item) {\n\t\titem.needsReflow = false;\n\n\t\tvar view = item.view;\n\t\tvar style = view.style;\n\t\tif (!style.__firstRender) {\n\t\t\tstyle.__firstRender = true;\n\n\t\t\tDEBUG && _debug.log('calling buildView for', view.uid, '(' + view.style.width + 'x' + view.style.height + ')') && _debug.stepIn();\n\t\t\tview.buildView(ctx);\n\t\t\tDEBUG && _debug.stepOut();\n\t\t}\n\n\t\tif (view.hasListeners('Resize')) {\n\t\t\tvar w = style.width;\n\t\t\tvar h = style.height;\n\t\t\tif (style.__cachedWidth != w || style.__cachedHeight != h) {\n\t\t\t\tstyle.__cachedWidth = w;\n\t\t\t\tstyle.__cachedHeight = h;\n\t\t\t\tview.publish('Resize');\n\t\t\t}\n\t\t}\n\n\t\tif (view.__layout) { view.__layout.reflow(); }\n\t\tview.reflow(false);\n\t}\n\n\tthis.startReflow = function (ctx) {\n\t\tthis._lastCtx = ctx;\n\t\tthis._isInReflow = true;\n\t\tthis._iter = 0;\n\t\tvar count;\n\n\t\tDEBUG && _debug.stepIn();\n\n\t\t// as long as we reflowed some views, keep looping\n\t\tdo {\n\t\t\t++this._iter; // what iteration are we on? only increment a view's count once per iteration\n\n\t\t\tcount = 0;\n\t\t\tfor (var uid in this._pending) {\n\t\t\t\tvar item = this._pending[uid];\n\t\t\t\tif (item.count > MAX_REFLOW_THRESHOLD) {\n\t\t\t\t\tlogger.warn('reflow loop detected for view', item.view.uid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (item.needsReflow) {\n\t\t\t\t\tDEBUG && _debug.log('starting reflow for view', item.view.uid, '(' + item.count + ' times)') && _debug.stepIn();\n\t\t\t\t\tthis._reflow(ctx, item);\n\t\t\t\t\tDEBUG && _debug.stepOut();\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDEBUG && count && _debug.log('iteration', this._iter, 'reflowed', count, 'views');\n\t\t} while (count);\n\n\t\t// recyle items\n\t\tfor (var uid in this._pending) {\n\t\t\t_pool.recycle(this._pending[uid]);\n\t\t}\n\n\t\tthis._pending = {};\n\t\tthis._isInReflow = false;\n\n\t\tDEBUG && _debug.stepOut();\n\t}\n\n});\n\nvar _instance = null;\nexports.get = function () {\n\treturn (_instance || (_instance = new ReflowManager()));\n}\n","pre":true},"sdk/timestep/ui/StackView.js":{"path":"sdk/timestep/ui/StackView.js","friendlyPath":".StackView","directory":"sdk/timestep/ui/","filename":"StackView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.StackView;\n * Implements a view which can switch out one of several child views to display at the front.\n *\n * @doc http://doc.gameclosure.com/api/ui-stackview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/stackview.md\n */\n\njsio(\"import ui.View as View\");\njsio(\"import animate\");\n\n/**\n * @extends ui.View\n */\nvar sdk_timestep_ui_StackView=__class__;exports=sdk_timestep_ui_StackView(function sdk_timestep_ui_StackView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\tthis.init = function (opts) {\n\t\topts = merge(opts, {\n\t\t\tlayout: 'box'\n\t\t});\n\t\tsupr(this, 'init', [opts]);\n\t\tthis.stack = [];\n\t};\n\n\tthis.getStack = function() { return this.stack; };\n\n\tthis.getCurrentView = function() {\n\t\tif (!this.stack.length) { return null; }\n\t\treturn this.stack[this.stack.length - 1];\n\t};\n\n\tthis.push = function(view, dontAnimate, reverse) {\n\t\t// don't animate the first (base) view of a stackview unless explicitly asked to\n\t\tif (!this.stack[0] && dontAnimate !== false) {\n\t\t\tdontAnimate = true;\n\t\t}\n\n\t\tvar current = this.getCurrentView();\n\t\tif (current) { this._hide(current, dontAnimate); }\n\t\tview.style.width = this.style.width / view.style.scale;\n\t\tview.style.height = this.style.height / view.style.scale;\n\t\tthis.stack.push(view);\n\t\tthis._show(view, dontAnimate, reverse);\n\t\treturn view;\n\t};\n\n\tthis._hide = function(view, dontAnimate, reverse) {\n\t\tview.publish('ViewWillDisappear');\n\t\tif (!dontAnimate) {\n\t\t\tthis.getInput().blockEvents = true;\n\t\t\tanimate(view)\n\t\t\t\t.then({x: (reverse ? 1 : -1) * this.style.width})\n\t\t\t\t.then(bind(this, function () {\n\t\t\t\t\tthis.removeSubview(view);\n\t\t\t\t\tview.publish('ViewDidDisappear');\n\t\t\t\t\tthis.getInput().blockEvents = false;\n\t\t\t\t}));\n\t\t} else {\n\t\t\tthis.removeSubview(view);\n\t\t\tview.publish('ViewDidDisappear');\n\t\t}\n\t};\n\n\tthis._show = function(view, dontAnimate, reverse) {\n\t\tview.publish('ViewWillAppear');\n\t\tview.style.visible = true;\n\t\tif (!dontAnimate) {\n\t\t\tview.style.x = (reverse ? -1 : 1) * this.style.width;\n\t\t\tthis.addSubview(view);\n\t\t\tanimate(view)\n\t\t\t\t.then({x: 0})\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidAppear'));\n\t\t} else {\n\t\t\tthis.addSubview(view);\n\t\t\tview.style.x = 0;\n\t\t\tview.publish('ViewDidAppear');\n\t\t}\n\t};\n\n\tthis.hasView = function(view) {\n\t\treturn this.stack.indexOf(view) >= 0;\n\t};\n\n\tthis.remove = function(view) {\n\t\tvar i = this.stack.indexOf(view);\n\t\tif (i >= 0) {\n\t\t\tthis.stack.splice(i, 1);\n\t\t}\n\t}\n\n\tthis.pop = function(dontAnimate, reverse) {\n\t\tif (!this.stack.length) { return false; }\n\t\tvar view = this.stack.pop();\n\t\t//reverse by default\n\t\tthis._hide(view, dontAnimate, (reverse === false) ? false : true);\n\n\t\tif (this.stack.length) {\n\t\t\tthis._show(this.stack[this.stack.length - 1], dontAnimate, true);\n\t\t}\n\n\t\treturn view;\n\t};\n\n\tthis.popAll = function(dontAnimate) {\n\t\twhile (this.stack[1]) {\n\t\t\tthis.pop(dontAnimate);\n\t\t}\n\t};\n});\n","pre":true},"sdk/timestep/ui/View.js":{"path":"sdk/timestep/ui/View.js","friendlyPath":"ui.View","directory":"sdk/timestep/ui/","filename":"View.js","baseMod":"ui","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.View;\n * The View base class.\n *\n * @doc http://doc.gameclosure.com/api/ui-view.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/view.md\n */\n\njsio(\"import device\");\njsio(\"import event.Emitter as Emitter\");\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import math.geom.Circle as Circle\");\n\njsio(\"import .backend.canvas.ViewBacking\");\n\njsio(\"import ui.backend.ReflowManager as ReflowManager\");\nvar _reflowMgr = ReflowManager.get();\n\njsio(\"import event.input.dispatch as dispatch\");\njsio(\"import event.input.InputHandler as InputHandler\");\n\njsio(\"import animate\");\n\njsio(\"import util.setProperty\");\n\n\nvar KeyListener = device.get('KeyListener');\n\nEventScheduler=__class__;var EventScheduler=EventScheduler(function EventScheduler(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tthis._queue = [];\n\t}\n\n\tthis.add = function (f) {\n\t\tthis._queue.push(f);\n\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\twhile ((f = this._queue.shift())) {\n\t\t\t\tf();\n\t\t\t}\n\t\t\tthis._running = false;\n\t\t}\n\t}\n});\n\nvar scheduler = new EventScheduler();\n\n/**\n * This singleton class controls the focus of the current application. Only one\n * view can be focused at a given time.\n *\n * This doesn't correspond to native and isn't being used.\n */\nvar FocusMgr = new (Class(function() {\n\tthis.init = function(opts) {\n\t\tthis._keyListener = KeyListener && (new KeyListener());\n\t\tthis._target = null;\n\t\tthis._canChange = true;\n\t};\n\n\t/**\n\t * Focus the target, unfocusing the last target with focus.\n\t */\n\tthis.focus = function (target) {\n\t\tif (this._target != target && this._canChange) {\n\t\t\tif (this._target && this._target.onBlur) {\n\t\t\t\tthis._target.onBlur(this);\n\t\t\t}\n\n\t\t\tthis._target = target;\n\t\t\tif (target && target.onFocus) {\n\t\t\t\tthis._target.onFocus(this);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.blur = function(target) {\n\t\ttarget.onBlur && target.onBlur(this);\n\t\tthis._target = false;\n\t};\n\n\t/**\n\t * Return the keylistener used by the focus manager.\n\t */\n\tthis.getKeyListener = function() {\n\t\treturn this._keyListener;\n\t};\n\n\tthis.get = function() {\n\t\treturn this;\n\t};\n}));\n\n/**\n * Unique ID counter for all views.\n */\nvar UID = 0;\n\nvar _BackingCtor = null;\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_View=__class__;var View = exports=sdk_timestep_ui_View(function sdk_timestep_ui_View(){return this.init&&this.init.apply(this,arguments)},Emitter, function() {\n\t/**\n\t * circle: boolean, default false - if true, use circular bounds for the view rather than rectangular and center the view at the origin\n\t * infinite: boolean, default false - if true, no bounding shape at all (e.g. infinite scroll plane)\n\t * clip: boolean, default false - if true, always clip to the region\n\t * canHandleEvents: boolean, default true - if false, this view is ignored for event handling\n\t * parent: object, if provided, sets the initial superview\n\t */\n\tthis.init = function (opts) {\n\t\tif (!opts) { opts = {}; }\n\n\t\tthis.uid = ++UID;\n\t\tthis.__input = new InputHandler(this, opts);\n\n\t\t// set with View.setDefaultViewBacking();\n\t\tthis.__view = this.style = new (opts.Backing || _BackingCtor)(this, opts);\n\n\t\tthis._filters = {};\n\n\t\tthis.__view._view = this;\n\n\t\tthis.updateOpts(opts);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\topts = opts || {};\n\t\tif (this._opts) {\n\t\t\tfor (var key in opts) {\n\t\t\t\tthis._opts[key] = opts[key];\n\t\t\t}\n\t\t} else {\n\t\t\tthis._opts = opts;\n\t\t}\n\n\t\tif (opts.tag) { this.tag = opts.tag; }\n\t\tif (opts.filters) { this._filters = opts.filters; }\n\n\t\tif (opts.circle) {\n\t\t\tthis._circle = opts.circle;\n\t\t}\n\t\tif (opts.infinite) {\n\t\t\tthis._infinite = opts.infinite;\n\t\t}\n\n\t\tthis.style.update(opts);\n\n\t\tif (opts.superview) {\n\t\t\topts.superview.addSubview(this);\n\t\t}\n\t\t//opts.parent is deprecated, use opts.superview instead\n\t\tif (opts.parent) {\n\t\t\topts.parent.addSubview(this);\n\t\t}\n\n\t\treturn opts;\n\t};\n\n\t// --- filters ---\n\n\t/**\n\t * Returns an array of filters attached to this view.\n\t */\n\tthis.getFilters = function() { return this._filters; };\n\n\t/**\n\t * Adds a filter to this view. Only one filter of each type can exist on a view.\n\t */\n\tthis.addFilter = function(filter) { this._filters[filter.getType()] = filter; };\n\n\t/**\n\t * Remove a named filter from this view.\n\t */\n\tthis.removeFilter = function(type) { delete this._filters[type]; };\n\n\t// --- render/tick setters ---\n\n\t/**\n\t * Adds a hook to determine when the \"render\" property is set.\n\t */\n\tutil.setProperty(this, 'render', {\n\t\t\tvalue: undefined,\n\t\t\tcb: function() { this.__view && (this.__view.hasJSRender = true); }\n\t\t});\n\n\t/**\n\t * Adds a hook to determine when the \"tick\" property is set.\n\t */\n\tutil.setProperty(this, 'tick', {\n\t\t\tvalue: undefined,\n\t\t\tcb: function() { this.__view && (this.__view.hasJSTick = true); }\n\t\t});\n\n\t// --- animation component ---\n\n\t/**\n\t * Get an animation group from this view.\n\t */\n\tthis.getAnimation = function(groupID) {\n\t\treturn animate(this, groupID);\n\t};\n\n\t/**\n\t * @deprecated\n\t * Return an animation object for this view.\n\t */\n\tthis.animate = function(style, duration, easing) { return this.getAnimation().then(style, duration, easing); };\n\n\t// --- ui focus/blur component ---\n\n\t/**\n\t * Indicate to the focus manager singleton this element is focused.\n\t */\n\tthis.focus = function() { FocusMgr.get().focus(this); return this; };\n\n\t/**\n\t * Indicate to the focus manager singleton this element is blurred.\n\t */\n\tthis.blur = function() { FocusMgr.get().blur(this); return this; };\n\n\t/**\n\t * Triggered when focus is given to this view.\n\t */\n\tthis.onFocus = function() { this._isFocused = true; };\n\n\t/**\n\t * Indicate to the focus manager singleton this element is blurred.\n\t */\n\tthis.onBlur = function() { this._isFocused = false; };\n\n\t// --- input component ---\n\n\t/**\n\t * Returns a boolean indicating we are currently dragging this view.\n\t */\n\tthis.isDragging = function() { return this.__input.isDragging(); };\n\n\t/**\n\t * Start responding to touch input by dragging this view.\n\t */\n\tthis.startDrag = function(opts) { this.__input.startDrag(opts); };\n\n\t/**\n\t * Return the InputHandler for this view.\n\t */\n\tthis.getInput = function() { return this.__input; };\n\n\t/**\n\t * Returns a boolean indicating if a touch is on this view.\n\t */\n\tthis.isInputOver = function() { return !!this.__input.overCount; };\n\n\t/**\n\t * Returns a number indicating how many touches are on this view.\n\t */\n\tthis.getInputOverCount = function() { return this._inputOverCount; };\n\n\t/**\n\t * Renamed to setHandleEvents, canHandleEvents is deprecated.\n\t * @param {boolean} ignoreEvents Pass events through. Default is true.\n\t * @param {boolean=} ignoreSubviews Optional, defaults to false in InputHandler. Ignore events in childen as well.\n\t */\n\tthis.setHandleEvents = this.canHandleEvents = function (handleEvents, ignoreSubviews) {\n\t\tthis.__input.canHandleEvents = handleEvents;\n\t\t\n\t\tif (typeof ignoreEvents === 'boolean') {\n\t\t\tthis.__input.blockEvents = ignoreSubviews;\n\t\t}\n\t};\n\n\t// TODO: think about refactoring internal components and exposing them differently...\n\tthis.setIsHandlingEvents = function (canHandleEvents) { this.__input.canHandleEvents = canHandleEvents; };\n\tthis.isHandlingEvents = function () { return this.__input.canHandleEvents; };\n\n\tthis.needsRepaint = function() { this._needsRepaint = true; }\n\tthis.needsReflow = function(force) {\n\t\tif (this.style.__firstRender || force) {\n\t\t\t_reflowMgr.add(this);\n\t\t\tthis._needsRepaint = true;\n\t\t}\n\t};\n\n\t/**\n\t * Consumes an event targeting this view.\n\t * NOTE: Does no actual propagation.\n\t */\n\tthis._onEventPropagate = function(evt, pt, atTarget) {\n\t\tif (atTarget) {\n\t\t\tvar id = evt.id;\n\t\t\tvar lastEvt;\n\t\t\tvar i;\n\n\t\t\tswitch(evt.type) {\n\t\t\t\tcase dispatch.eventTypes.SELECT:\n\t\t\t\tcase dispatch.eventTypes.CLEAR:\n\t\t\t\t\tdispatch._evtHistory[dispatch.eventTypes.MOVE] = null;\n\t\t\t\t\tlastEvt = dispatch._activeInputOver[id];\n\t\t\t\t\tif (lastEvt) {\n\t\t\t\t\t\tdispatch.clearOverState(id);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase dispatch.eventTypes.START:\n\t\t\t\tcase dispatch.eventTypes.MOVE:\n\t\t\t\t\t// translate input:move events into two higher-level events:\n\t\t\t\t\t//   input:over and input:out\n\n\t\t\t\t\tvar target = evt.trace[0];\n\t\t\t\t\tvar view = null;\n\n\t\t\t\t\t// fire input:out events first, start with deepest node and work out\n\t\t\t\t\tlastEvt = dispatch._activeInputOver[id];\n\t\t\t\t\tif (lastEvt && target != lastEvt.trace[0]) {\n\t\t\t\t\t\tvar trace = lastEvt.trace;\n\t\t\t\t\t\tfor (i = 0, view; view = trace[i]; ++i) {\n\t\t\t\t\t\t\tif (!(view.uid in evt.pt)) {\n\t\t\t\t\t\t\t\tview.__input.onLeave(id, target == view);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!lastEvt || target != lastEvt.trace[0]) {\n\t\t\t\t\t\t// fire input:over events second, start with outermost node and go to target\n\t\t\t\t\t\tvar trace = evt.trace;\n\t\t\t\t\t\tfor (i = evt.depth - 1; i >= 0; --i) {\n\t\t\t\t\t\t\ttrace[i].__input.onEnter(id, target == view);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update current mouse trace\n\t\t\t\t\t\tdispatch._activeInputOver[id] = evt;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.localizePoint = function (pt) {\n\t\tvar list = this.getParents();\n\t\tvar i = 0;\n\t\tlist.push(this);\n\t\twhile (list[++i]) { pt = list[i].__view.localizePoint(pt); }\n\t\treturn pt;\n\t};\n\n\t// --- view hierarchy component ---\n\n\t/**\n\t * Return the subview at the given index.\n\t */\n\tthis.getSubview = function (i) {\n\t\treturn this.__view.getSubviews()[i];\n\t};\n\n\t/**\n\t * Returns an array of all subviews.\n\t */\n\tthis.getSubviews = function () {\n\t\treturn this.__view.getSubviews();\n\t};\n\n\t/**\n\t * Returns the superview of this view.\n\t */\n\tthis.getSuperview = function () {\n\t\treturn this.__view.getSuperview();\n\t};\n\n\tthis.connectEvent = function (src, name /*, args */) {\n\t\tif (!this.__subs) {\n\t\t\tthis.__subs = [];\n\n\t\t\tthis.on('ViewAdded', bind(this, '_connectEvents'));\n\t\t\tthis.on('ViewRemoved', bind(this, '_disconnectEvents'));\n\n\t\t\tif (this.__root) {\n\t\t\t\tthis._connectEvents();\n\t\t\t}\n\t\t}\n\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tthis.__subs.push([src, args]);\n\t\tif (this.__root) {\n\t\t\tsrc.on.apply(src, args);\n\t\t}\n\t}\n\n\tfunction compareSubscription (args, sub) {\n\t\t// note that args and sub may not be the same length\n\t\t// return true if all items in args match items in sub\n\t\t// (we don't care if sub has extra arguments)\n\t\tfor (var i = 0, n = args.length; i < n; ++i) {\n\t\t\tif (args[i] != sub[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tthis.disconnectEvent = function (src, name /*, args */) {\n\t\tif (this.__subs) {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t\tfor (var i = 0, sub; sub = this.__subs[i]; ++i) {\n\t\t\t\tif (sub[0] == src && compareSubscription(args, sub[1])) {\n\t\t\t\t\tsub[0].removeListener.apply(sub[0], sub[1]);\n\t\t\t\t\tthis.__subs.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis._connectEvents = function () {\n\t\tfor (var i = 0, args; args = this.__subs[i]; ++i) {\n\t\t\targs[0].on.apply(args[0], args[1]);\n\t\t}\n\t}\n\n\tthis._disconnectEvents = function () {\n\t\tfor (var i = 0, args; args = this.__subs[i]; ++i) {\n\t\t\targs[0].removeListener.apply(args[0], args[1]);\n\t\t}\n\t}\n\n\t/**\n\t * Add a subview.\n\t */\n\tthis.addSubview = function (view) {\n\t\tif (this.__view.addSubview(view)) {\n\t\t\tview.needsRepaint();\n\t\t\tview.needsReflow();\n\n\t\t\t// if successful, clear any residual input over count\n\t\t\tview.__input.resetOver();\n\n\t\t\tthis.publish('SubviewAdded', view);\n\t\t\tif (this.__root) {\n\t\t\t\tvar root = this.__root;\n\t\t\t\tvar viewCreated = view;\n\t\t\t\tscheduler.add(bind(this, function recurse(view) {\n\t\t\t\t\tview.__root = root;\n\t\t\t\t\tview.emit('ViewAdded', viewCreated);\n\t\t\t\t\tvar subviews = view.getSubviews();\n\t\t\t\t\tfor (var i = 0, subview; subview = subviews[i]; ++i) {\n\t\t\t\t\t\trecurse(subview);\n\t\t\t\t\t}\n\t\t\t\t}, view));\n\t\t\t}\n\t\t}\n\n\t\treturn view;\n\t};\n\n\t/**\n\t * Removes a subview.\n\t */\n\tthis.removeSubview = function(view) {\n\t\tif (this.__view.removeSubview(view)) {\n\t\t\tthis.publish('SubviewRemoved', view);\n\t\t\tif (view.__root) {\n\t\t\t\tscheduler.add(bind(this, function recurse(view) {\n\t\t\t\t\tview.__root = null;\n\t\t\t\t\tview.emit('ViewRemoved', this);\n\t\t\t\t\tvar subviews = view.getSubviews();\n\t\t\t\t\tfor (var i = 0, subview; subview = subviews[i]; ++i) {\n\t\t\t\t\t\trecurse(subview);\n\t\t\t\t\t}\n\t\t\t\t}, view));\n\t\t\t}\n\t\t}\n\n\t\treturn view;\n\t}\n\n\t/**\n\t * Removes this view from its parent.\n\t */\n\tthis.removeFromSuperview = function() {\n\t\tvar superview = this.__view.getSuperview();\n\t\tif (superview) {\n\t\t\tsuperview.removeSubview(this);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all subviews from this view.\n\t */\n\tthis.removeAllSubviews = function() {\n\t\tvar subviews = this.getSubviews();\n\t\tvar i = subviews.length;\n\t\twhile (i--) {\n\t\t\tthis.removeSubview(subviews[i]);\n\t\t}\n\t};\n\n\t// legacy implementation shim\n\tutil.setProperty(this, '_superview', {get: this.getSuperview, set: function() {}});\n\tutil.setProperty(this, '_subviews', {get: this.getSubviews, set: function() {}});\n\n\t// --- onResize callbacks ---\n\n\tthis.reflow = function () {\n\t};\n\n\t// ---\n\n\t/**\n\t * Get the root application for this view.\n\t */\n\tthis.getApp = function() {\n\t\tvar top = this;\n\t\tvar next;\n\t\tdo {\n\t\t\tnext = top.__view.getSuperview();\n\t\t} while (next && (top = next));\n\t\treturn top.__root;\n\t};\n\n\t/**\n\t * Returns an array of all ancestors of the current view.\n\t */\n\tthis.getParents = function() {\n\t\tvar list = [this];\n\t\tvar next;\n\t\tdo {\n\t\t\tnext = list[0].__view.getSuperview();\n\t\t} while (next && list.unshift(next));\n\n\t\tlist.pop();\n\t\treturn list;\n\t};\n\n\t/**\n\t * @interface\n\t */\n\tthis.buildView = function() {};\n\n\t/**\n\t * Determine if this view contains a point.\n\t */\n\tthis.containsLocalPoint = function(pt) {\n\t\tif (this._infinite) { return true; }  // infinite plane\n\n\t\tif (this._circle) { // bounding circle\n\t\t\tvar radius = this.style.radius;\n\t\t\treturn pt.x * pt.x + pt.y * pt.y < radius * radius;\n\t\t} else { // bounding box\n\t\t\tvar s = this.style,\n\t\t\t\tw = s.width,\n\t\t\t\th = s.height;\n\n\t\t\tif (w > 0 && h > 0) {\n\t\t\t\treturn pt.x <= w && pt.y <= h && pt.x >= 0 && pt.y >= 0;\n\t\t\t} else if (w > 0) {\n\t\t\t\treturn pt.x <= w && pt.y >= h && pt.x >= 0 && pt.y <= 0;\n\t\t\t} else if (h > 0) {\n\t\t\t\treturn pt.x >= w && pt.y <= h && pt.x <= 0 && pt.y >= 0;\n\t\t\t} else {\n\t\t\t\treturn pt.x >= w && pt.y >= h && pt.x <= 0 && pt.y <= 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Return the bounding shape for this view. The shape is defined in the\n\t * options object when this view was constructed.\n\t */\n\tthis.getBoundingShape = function() {\n\t\tvar s = this.style;\n\t\tif (this._infinite) {\n\t\t\treturn true;\n\t\t} else if (this._circle) {\n\t\t\treturn new Circle(s.x, s.y, s.radius * s.scale);\n\t\t} else {\n\t\t\treturn new Rect(s.x, s.y, s.width * s.scale, s.height * s.scale);\n\t\t}\n\t};\n\n\t/**\n\t * Given a rectangle and a parent view, compute the location of\n\t * the rectangle in this view's coordinate space.\n\t * WARNING: only works with non-rotated rectangles.\n\t * TODO Make it work with rotated rectangles!\n\t */\n\tthis.getRelativeRegion = function(region, parent) {\n\t\tvar offset = this.getPosition(parent || region.src);\n\t\treturn new Rect((region.x - offset.x) / offset.scale,\n\t\t\t\t\t\t(region.y - offset.y)  / offset.scale,\n\t\t\t\t\t\tregion.width / offset.scale,\n\t\t\t\t\t\tregion.height / offset.scale);\n\t};\n\n\t/**\n\t * Return a fully defined position, rotation, size, and scale for this view.\n\t */\n\tthis.getPosition = function(/* optional */ relativeTo) {\n\t\tvar abs = new Point(),\n\t\t\tview = this,\n\t\t\tr = 0,\n\t\t\ts = this.style,\n\t\t\tw = s.width,\n\t\t\th = s.height,\n\t\t\tc = 1;\n\n\t\twhile (view && view != relativeTo) {\n\t\t\tvar scale = view.style.scale;\n\n\t\t\t//translate to anchor point\n\t\t\tabs.add(\n\t\t\t\t-(view.style.anchorX),\n\t\t\t\t-(view.style.anchorY)\n\t\t\t);\n\n\t\t\t//scale and rotate\n\t\t\tabs.rotate(view.style.r);\n\t\t\tabs.scale(scale);\n\n\t\t\t//translate back\n\t\t\tabs.add(\n\t\t\t\tview.style.anchorX + view.style.x + view.style.offsetX,\n\t\t\t\tview.style.anchorY + view.style.y + view.style.offsetY\n\t\t\t);\n\n\t\t\tr += view.style.r;\n\t\t\tw *= scale;\n\t\t\th *= scale;\n\t\t\tc *= scale;\n\t\t\tview = view.__view.getSuperview();\n\t\t}\n\n\t\treturn {\n\t\t\tx: abs.x,\n\t\t\ty: abs.y,\n\t\t\tr: r % (2 * Math.PI),\n\t\t\twidth: w,\n\t\t\theight: h,\n\t\t\tscale: c,\n\t\t\tanchorX: this.style.anchorX,\n\t\t\tanchorY: this.style.anchorY\n\t\t};\n\t};\n\n\t/**\n\t * Exposes the internal implementation of the view hierarchy\n\t */\n\tthis.getBacking = function () {\n\t\treturn this.__view;\n\t};\n\n\t/**\n\t * Sets the visibility to true. Triggers repaint.\n\t */\n\tthis.show = function () {\n\t\tthis.style.visible = true;\n\t\tthis.needsRepaint();\n\t};\n\n\t/**\n\t * Sets the visibility to false. Triggers repaint.\n\t */\n\tthis.hide = function () {\n\t\tthis.style.visible = false;\n\t\tthis.needsRepaint();\n\t};\n\n\t/**\n\t * Return a human-readable tag for this view.\n\t */\n\tthis.toString = this.getTag = function () {\n\t\tvar cls = \"View\";\n\n\t\tif (DEBUG) {\n\t\t\t// check the cached name\n\t\t\tif (this.__tagClassName) {\n\t\t\t\tcls = this.__tagClassName;\n\t\t\t} else {\n\t\t\t\t// generate the classname\n\t\t\t\tcls = this.constructor.name;\n\n\t\t\t\tif (!cls) {\n\t\t\t\t\tcls = this.constructor.toString().match(/^function ([^(]+)/)[1];\n\t\t\t\t}\n\n\t\t\t\tif (cls) {\n\t\t\t\t\tcls = cls.substr(cls.lastIndexOf(\"_\") + 1);\n\t\t\t\t}\n\n\t\t\t\tthis.__tagClassName = cls || 'unknown';\n\t\t\t}\n\t\t}\n\n\t\treturn cls + this.uid + (this.tag ? ':' + this.tag : '');\n\t};\n});\n\nvar _extensions = [];\nView.addExtension = function (ext) {\n\text.extend(View.BackingCtor);\n\t_extensions.push(ext);\n}\n\nView.setDefaultViewBacking = function (ViewBackingCtor) {\n\t_BackingCtor = View.BackingCtor = ViewBackingCtor;\n\t_extensions.forEach(function (ext) { ext.extend(_BackingCtor); });\n}\n\n// default view backing is canvas\nView.setDefaultViewBacking(backend.canvas.ViewBacking);\n","pre":true},"sdk/jsio/math/geom/Circle.js":{"path":"sdk/jsio/math/geom/Circle.js","friendlyPath":"math.geom.Circle","directory":"sdk/jsio/math/geom/","filename":"Circle.js","src":"jsio(\"import .Point\");\n\n/**\n * @extends math.geom.Point\n * Models a circle given a radius.\n *   Circle(x, y, radius)\n *   Circle({x: default 0, y: default 0, radius: default 0})\n */\nvar sdk_jsio_math_geom_Circle=__class__;exports=sdk_jsio_math_geom_Circle(function sdk_jsio_math_geom_Circle(){return this.init&&this.init.apply(this,arguments)},Point, function(supr) {\n\tthis.init = function(a, b, c) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.radius = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tthis.radius = a.radius || 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.radius = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Scale the position and radius of this circle by a percentage.\n\t */\n\t\n\tthis.scale = function(s) {\n\t\tsupr(this, 'scale', arguments);\n\t\tthis.radius *= s;\n\t\treturn this;\n\t}\n});","pre":true},"sdk/timestep/ui/backend/canvas/ViewBacking.js":{"path":"sdk/timestep/ui/backend/canvas/ViewBacking.js","friendlyPath":".backend.canvas.ViewBacking","directory":"sdk/timestep/ui/backend/canvas/","filename":"ViewBacking.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.backend.canvas.ViewStyle;\n *\n * Models the style object of the canvas View.\n */\n\njsio(\"import ..strPad\");\njsio(\"import ..BaseBacking\");\njsio(\"import util.setProperty as setProperty\");\n\nvar _styleKeys = {};\n\nvar sdk_timestep_ui_backend_canvas_ViewBacking=__class__;var ViewBacking = exports=sdk_timestep_ui_backend_canvas_ViewBacking(function sdk_timestep_ui_backend_canvas_ViewBacking(){return this.init&&this.init.apply(this,arguments)},BaseBacking, function () {\n\t\n\tthis.init = function (view) {\n\t\tthis._view = view;\n\t\tthis._subviews = [];\n\t}\n\n\tthis.getSuperview = function () { return this._superview; }\n\tthis.getSubviews = function () {\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\tvar subviews = [];\n\t\tvar backings = this._subviews;\n\t\tvar n = backings.length;\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tsubviews[i] = backings[i]._view;\n\t\t}\n\n\t\treturn subviews;\n\t}\n\n\tvar ADD_COUNTER = 900000;\n\tthis.addSubview = function (view) {\n\t\tvar backing = view.__view;\n\t\tvar superview = backing._superview;\n\t\tif (superview == this._view) { return false; }\n\t\tif (superview) { superview.__view.removeSubview(view); }\n\n\t\tvar n = this._subviews.length;\n\t\tthis._subviews[n] = backing;\n\n\t\tbacking._superview = this._view;\n\t\tbacking._setAddedAt(++ADD_COUNTER);\n\n\t\tif (n && backing.__sortKey < this._subviews[n - 1].__sortKey) {\n\t\t\tthis._needsSort = true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tthis.removeSubview = function (targetView) {\n\t\tvar index = this._subviews.indexOf(targetView.__view);\n\t\tif (index != -1) {\n\t\t\tthis._subviews.splice(index, 1);\n\t\t\t// this._view.needsRepaint();\n\n\t\t\ttargetView.__view._superview = null;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tthis.wrapTick = function(dt, app) {\n\t\tthis._view.tick && this._view.tick(dt, app);\n\n\t\tfor (var i = 0, view; view = this._subviews[i]; ++i) {\n\t\t\tview.wrapTick(dt, app);\n\t\t}\n\n\t\t// TODO: support partial repaints?\n\t\t// if (this._view._needsRepaint) {\n\t\t// \tthis._view._needsRepaint = false;\n\t\t// \tapp.needsRepaint();\n\t\t// }\n\t}\n\n\tthis.wrapRender = function(ctx, opts) {\n\t\tif (!this.visible) { return; }\n\t\t\n\t\tif (!this.__firstRender) { this._view.needsReflow(true); }\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\t\n\t\tvar width = this._width;\n\t\tvar height = this._height;\n\t\tif (!width || !height || width < 0 || height < 0) { return; }\n\n\t\tctx.save();\n\t\t\n\t\tctx.translate(this.x + this.anchorX + this.offsetX, this.y + this.anchorY + this.offsetY);\n\t\t\n\t\tif (this.r) { ctx.rotate(this.r); }\n\t\t\n\t\t// clip this render to be within its view;\n\t\tif (this.scale != 1) { ctx.scale(this.scale, this.scale); }\n\t\t\n\t\tif (this.opacity != 1) { ctx.globalAlpha *= this.opacity; }\n\n\t\tctx.translate(-this.anchorX, -this.anchorY);\n\n\t\tif (this.circle) { ctx.translate(-width / 2, -height / 2); }\n\n\t\tif (this.clip) { ctx.clipRect(0, 0, width, height); }\n\t\t\n\t\tvar filters = this._view.getFilters();\n\t\tctx.setFilters(filters);\n\n\t\tif (this.flipX || this.flipY) {\n\t\t\tctx.translate(\n\t\t\t\tthis.flipX ? width / 2 : 0,\n\t\t\t\tthis.flipY ? height / 2 : 0\n\t\t\t);\n\n\t\t\tctx.scale(\n\t\t\t\tthis.flipX ? -1 : 1,\n\t\t\t\tthis.flipY ? -1 : 1\n\t\t\t);\n\n\t\t\tctx.translate(\n\t\t\t\tthis.flipX ? -width / 2 : 0,\n\t\t\t\tthis.flipY ? -height / 2 : 0\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\tif (this.backgroundColor) {\n\t\t\t\tctx.fillStyle = this.backgroundColor;\n\t\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\t}\n\n\t\t\tvar viewport = opts.viewport;\n\t\t\tthis._view.render && this._view.render(ctx, opts);\n\t\t\tthis._renderSubviews(ctx, opts);\n\t\t\topts.viewport = viewport;\n\n\t\t} finally {\n\t\t\tctx.clearFilters();\n\t\t\tctx.restore();\n\t\t}\n\t}\n\n\tthis._renderSubviews = function(ctx, opts) {\n\t\tvar i = 0;\n\t\tvar view;\n\t\tvar subviews = this._subviews;\n\t\twhile (view = subviews[i++]) {\n\t\t\tview.wrapRender(ctx, opts);\n\t\t}\n\t}\n\n\t// this._clearCache = function() { this._cache = null; }\n\t\n\t// this.updateRadius = function() {\n\t// \tvar w = this.width * 0.5,\n\t// \t\th = this.height * 0.5;\n\t\t\n\t// \tif (!this._cache) { this._cache = {}; }\n\t// \treturn (this._cache.radius = Math.sqrt(w * w + h * h));\n\t// }\n\t\n\tthis._onResize = function(prop, value, prevValue) {\n\t\t// local properties are invalidated\n\t\t// this._cache = null;\n\t\t\n\t\t// child view properties might be invalidated\n\t\tthis._view.needsReflow();\n\t}\n\t\n\tthis._sortIndex = strPad.initialValue;\n\tthis._onZIndex = function(_, zIndex) {\n\t\tthis._sortIndex = strPad.pad(zIndex);\n\n\t\tthis._setSortKey();\n\t\tthis._view.needsRepaint();\n\n\t\tvar superview = this._view.getSuperview();\n\t\tif (superview) { superview.__view._needsSort = true; }\n\t}\n\n\tthis._setAddedAt = function(addedAt) {\n\t\tthis._addedAt = addedAt;\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setSortKey = function() {\n\t\tthis.__sortKey = this._sortIndex + this._addedAt;\n\t}\n\n\t//not implemented\n\tthis._onOffsetX = function (n) {\n\t\tthis.offsetX = n * this.width / 100;\n\t};\n\n\t//not implemented\n\tthis._onOffsetY = function (n) {\n\t\tthis.offsetY = n * this.height / 100;\n\t};\n\t\n\tthis.toString = function() { return this.__sortKey; }\n});\n","pre":true},"sdk/timestep/ui/backend/strPad.js":{"path":"sdk/timestep/ui/backend/strPad.js","friendlyPath":"..strPad","directory":"sdk/timestep/ui/backend/","filename":"strPad.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar LEN = 8;\nvar MAX = 99999999;\nvar MIN = -99999999;\nvar PAD = \"00000000\";\n\nexports.initialValue = PAD;\n\nexports.pad = function (val) {\n\tval = ~~val;\n\n\tif (val < MIN) { val = MIN; }\n\tif (val > MAX) { val = MAX; }\n\tif (val < 0) {\n\t\tval *= -1;\n\t\treturn '-' + PAD.substring(0, LEN - ('' + val).length) + val;\n\t} else {\n\t\treturn PAD.substring(0, LEN - ('' + val).length) + val;\n\t}\n};\n","pre":true},"sdk/timestep/ui/backend/BaseBacking.js":{"path":"sdk/timestep/ui/backend/BaseBacking.js","friendlyPath":"..BaseBacking","directory":"sdk/timestep/ui/backend/","filename":"BaseBacking.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\njsio(\"import util.setProperty as setProperty\");\n\nvar sdk_timestep_ui_backend_BaseBacking=__class__;var BaseBacking = exports=sdk_timestep_ui_backend_BaseBacking(function sdk_timestep_ui_backend_BaseBacking(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\n\t// required methods:\n\t//\n\t// this._onResize = function () {};\n\t// this._onZIndex = function () {};\n\n\tvar styleKeys = this.constructor.styleKeys = {};\n\n\t// keys map to properties\n\tvar BASE_STYLE_PROPS = {\n\t\t'x': {value: 0},\n\t\t'y': {value: 0},\n\t\t'offsetX': {value: 0}, //translate\n\t\t'offsetY': {value: 0},\n\t\t'offsetXPercent': {value: undefined, cb: '_onOffsetX'}, //not implemented\n\t\t'offsetYPercent': {value: undefined, cb: '_onOffsetY'},\n\t\t'anchorX': {value: 0}, //rotation and scale\n\t\t'anchorY': {value: 0},\n\t\t'centerAnchor': {value: false},\n\t\t'width': {cb: '_onResize'},\n\t\t'height': {cb: '_onResize'},\n\t\t'r': {value: 0},\n\t\t'opacity': {value: 1},\n\t\t'zIndex': {value: 0, cb: '_onZIndex'},\n\t\t// 'radius': {\n\t\t// \tget: function() {\n\t\t// \t\treturn this._cache && 'radius' in this._cache ? this._cache.radius : this.updateRadius();\n\t\t// \t}\n\t\t// },\n\t\t'scale': {value: 1},\n\t\t'flipX': {value: false},\n\t\t'flipY': {value: false},\n\t\t'visible': {value: true},\n\t\t'shadowColor': {value: 'black'}, //only has an effect in TextView??\n\t\t'clip': {value: false},\n\t\t'backgroundColor': {value: undefined}\n\t};\n\t\n\tthis.constructor.addProperty = function (key, def) {\n\t\tstyleKeys[key] = true;\n\t\tsetProperty(this.prototype, key, def);\n\t}\n\n\tfor (var key in BASE_STYLE_PROPS) {\n\t\tthis.constructor.addProperty(key, BASE_STYLE_PROPS[key]);\n\t}\n\n\tthis.localizePoint = function (pt) {\n\t\tpt.x -= this.x + this.anchorX + this.offsetX;\n\t\tpt.y -= this.y + this.anchorY + this.offsetY;\n\t\tif (this.r) { pt.rotate(-this.r); }\n\t\tpt.scale(1 / this.scale);\n\t\tpt.x += this.anchorX;\n\t\tpt.y += this.anchorY;\n\t\treturn pt;\n\t}\n\n\tthis.copy = function () {\n\t\tvar copy = {};\n\t\tfor (var key in styleKeys) {\n\t\t\tcopy[key] = this[key];\n\t\t}\n\n\t\treturn copy;\n\t}\n\t\n\tthis.update = function (style) {\n\t\tfor (var i in style) {\n\t\t\tif (style.hasOwnProperty(i) && styleKeys.hasOwnProperty(i)) {\n\t\t\t\tthis[i] = style[i];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n});\n","pre":true},"sdk/jsio/util/setProperty.js":{"path":"sdk/jsio/util/setProperty.js","friendlyPath":"util.setProperty","directory":"sdk/jsio/util/","filename":"setProperty.js","src":"function createGetter(ctx, name) {\n\treturn function() {\n\t\treturn this[name];\n\t}\n}\n\nfunction createSetter(ctx, name, callback, initialValue) {\n\tif (initialValue !== undefined) {\n\t\tctx[name] = initialValue;\n\t}\n\t\n\tif (typeof callback == 'function') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tcallback.call(this, name, value, old);\n\t\t\t}\n\t\t}\n\t} else if (typeof callback == 'string') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tthis[callback](name, value, old);\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn function(value) {\n\t\t\tthis[name] = value;\n\t\t}\n\t}\n}\n\nexports = function(ctx, name, def) {\n\tif (!def.get && !def.set && !def.cb && ('value' in def)) {\n\t\tctx[name] = def.value;\n\t} else {\n\t\tif (!def.get) { def.get = createGetter(ctx, '_' + name); }\n\t\tif (!def.set) { def.set = createSetter(ctx, '_' + name, def.cb, def.value); }\n\t\tif ('value' in def) { ctx['_' + name] = def.value; }\n\n\t\tdelete def.value;\n\t\tif (Object.defineProperty) {\n\t\t\tObject.defineProperty(ctx, name, def);\n\t\t\t// merge(def, {\n\t\t\t// \t\t\t\tconfigurable: false,\n\t\t\t// \t\t\t\tenumerable: true\n\t\t\t// \t\t\t});\n\t\t} else if (ctx.__defineSetter__) {\n\t\t\tctx.__defineSetter__(name, def.set);\n\t\t\tctx.__defineGetter__(name, def.get);\n\t\t} else {\n\t\t\tctx[name] = def.value;\n\t\t}\n\t}\n}\n","pre":true},"sdk/timestep/event/input/InputHandler.js":{"path":"sdk/timestep/event/input/InputHandler.js","friendlyPath":"event.input.InputHandler","directory":"sdk/timestep/event/input/","filename":"InputHandler.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class event.input.InputHandler;\n * An event handler proxy for an individual view. This handles dispatching\n * of events onto the actual view itself, as well as determining if the view\n * is the actual target of a propagated event. \n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import event.input.dispatch as dispatch\");\n\nvar sdk_timestep_event_input_InputHandler=__class__;var InputHandler = exports=sdk_timestep_event_input_InputHandler(function sdk_timestep_event_input_InputHandler(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\t// ---- start mouseover\n\t\n\tthis.dragCount = 0;\n\tthis.overCount = 0;\n\tthis.canHandleEvents = true;\n\tthis.blockEvents = false;\n\n\tthis.init = function(view, opts) {\n\t\tthis.view = view;\n\n\t\tif ('canHandleEvents' in opts) {\n\t\t\tthis.canHandleEvents = opts.canHandleEvents;\n\t\t}\n\n\t\tif ('blockEvents' in opts) {\n\t\t\tthis.blockEvents = opts.blockEvents;\n\t\t}\n\t}\n\t\n\tthis.containsEvent = function(evt, localPt) {\n\t\t// block events must be false\n\t\treturn !this.blockEvents && (!this.view._superview   // top-view captures all events\n\t\t\t\t|| this.view.containsLocalPoint(localPt));\n\t}\n\n\tthis.onEnter = function(id, atTarget) {\n\t\tvar view = this.view;\n\t\tvar over = this._over || (this._over = {});\n\t\tif (id in over) { return; }\n\t\t\n\t\tover[id] = true;\n\t\tthis.overCount++;\n\t\t\n\t\tif (view.onInputOver) { view.onInputOver(over, this.overCount, atTarget); }\n\t\tview.publish('InputOver', over, this.overCount, atTarget);\n\t}\n\t\n\tthis.onLeave = function(id, atTarget) {\n\t\tvar view = this.view;\n\t\tvar over = this._over || (this._over = {});\n\t\tif (!(id in over)) { return; }\n\t\t\n\t\tdelete over[id];\n\t\t--this.overCount;\n\t\t\n\t\tif (view.onInputOut) { view.onInputOut(over, this.overCount, atTarget); }\n\t\tview.publish('InputOut', over, this.overCount, atTarget);\n\t}\n\t\n\tthis.resetOver = function() {\n\t\tdelete this._over;\n\t\tthis.overCount = 0;\n\t}\n\t\n\t// ---- end mouseover\n\t\n\t\n\t// ---- start drag\n\t\n\tthis.startDrag = function(opts) {\n\t\topts = opts || {};\n\t\tvar view = this.view;\n\t\tvar inputStartEvt = opts.inputStartEvt || opts.inputStartEvent || dispatch._evtHistory[dispatch.eventTypes.START];\n\t\tvar id = inputStartEvt.id;\n\t\t\n\t\t// dedup drags from same input ID\n\t\tvar dragging = this._isDragging || (this._isDragging = {});\n\t\tif (dragging[id]) { return; }\n\t\tdragging[id] = true;\n\t\t\n\t\t++this.dragCount;\n\n\t\tvar root = inputStartEvt.root;\n\t\tvar dragEvt = new dispatch.InputEvent(inputStartEvt.id, 'input:drag', inputStartEvt.srcPt.x, inputStartEvt.srcPt.y, root, view);\n\t\t\n\t\tdragEvt.didDrag = false;\n\t\tdragEvt.radius = opts.radius * opts.radius || 0;\n\t\t\n\t\troot.subscribe('InputMoveCapture', this, 'onDragStart', dragEvt);\n\t\troot.subscribe('InputSelectCapture', this, 'onDragStop', dragEvt);\n\t}\n\t\n\tthis.isDragging = function() { return this.dragCount && dispatch._isDragging; }\n\t\n\tthis.onDragStart = function(dragEvt, moveEvt) {\n\t\t// have we exceeded the move radius?\n\t\tvar dx = moveEvt.srcPt.x - dragEvt.srcPt.x;\n\t\tvar dy = moveEvt.srcPt.y - dragEvt.srcPt.y;\n\t\tif (dx * dx + dy * dy <= dragEvt.radius) { return; }\n\n\t\tvar view = this.view;\n\t\t\n\t\t// no longer need to listen for move events for onDragStart\n\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDragStart');\n\t\t\n\t\t// want to fire onDragStart with the current point equal to the initial point \n\t\t// even though the user has moved away by now\n\t\tdragEvt.currPt = dragEvt.srcPt;\n\t\tdragEvt.localPt = view.localizePoint(new Point(dragEvt.currPt));\n\n\t\tif (view.onDragStart) { view.onDragStart(dragEvt); }\n\t\tview.publish('DragStart', dragEvt);\n\t\t\n\t\t// future move events should be captured by _onDrag\n\t\t// we should also call _onDrag now to handle the current move event delta\n\t\tdragEvt.root.subscribe('InputMoveCapture', this, 'onDrag', dragEvt);\n\t\tthis.onDrag(dragEvt, moveEvt);\n\t}\n\t\n\tthis.onDrag = function(dragEvt, moveEvt) {\n\t\tif (dragEvt.id != moveEvt.id\n\t\t\t\t|| moveEvt.srcPt.x == dragEvt.currPt.x && moveEvt.srcPt.y == dragEvt.currPt.y) { return; }\n\n\t\tvar view = this.view;\n\t\t\n\t\tdragEvt.prevPt = dragEvt.currPt;\n\t\tdragEvt.currPt = moveEvt.srcPt;\n\n\t\tdragEvt.prevLocalPt = dragEvt.localPt;\n\t\tdragEvt.localPt = view.localizePoint(new Point(dragEvt.currPt));\n\n\t\tdragEvt.didDrag = true;\n\t\t\n\t\tvar delta = Point.subtract(dragEvt.localPt, dragEvt.prevLocalPt);\n\n\t\tdispatch._isDragging = true;\n\n\t\tif (view.onDrag) { view.onDrag(dragEvt, moveEvt, delta); }\n\t\tview.publish('Drag', dragEvt, moveEvt, delta);\n\t\t\n\t\t//moveEvt.cancel();\n\t}\n\t\n\tthis.onDragStop = function(dragEvt, selectEvt) {\n\t\tvar id = dragEvt.id;\n\t\tvar dragging = this._isDragging || (this._isDragging = {});\n\t\tif (!dragging[id] || dragEvt.id != selectEvt.id) { return; }\n\t\t\n\t\tdelete dragging[id];\n\t\t--this.dragCount;\n\n\t\tif (!this.dragCount) {\n\t\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDragStart');\n\t\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDrag');\n\t\t\tdragEvt.root.unsubscribe('InputSelectCapture', this, 'onDragStop');\n\t\t\tdispatch._isDragging = false;\n\t\t}\n\t\t\n\t\tif (dragEvt.didDrag) {\n\t\t\tvar view = this.view;\n\t\t\t\n\t\t\t// a subscription can later 'uncancel' the selectEvt by setting 'selectEvt.cancelled = false;'\n\t\t\tselectEvt.cancel();\n\t\t\t\n\t\t\tif (view.onDragStop) { view.onDragStop(dragEvt, selectEvt); }\n\t\t\tview.publish('DragStop', dragEvt, selectEvt);\n\t\t}\n\t}\n\t\n\t// ---- end drag\n});\n","pre":true},"sdk/timestep/animate.js":{"path":"sdk/timestep/animate.js","friendlyPath":"animate","directory":"sdk/timestep/","filename":"animate.js","baseMod":"animate","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module animate\n * Import the DOM/Canvas implementation of animate. Also define the transition function aliases.\n *\n * @doc http://doc.gameclosure.com/api/animate.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/animate.md\n */\n\njsio(\"import ui.backend.canvas.animate as exports\");\n","pre":true},"sdk/timestep/ui/backend/canvas/animate.js":{"path":"sdk/timestep/ui/backend/canvas/animate.js","friendlyPath":"ui.backend.canvas.animate","directory":"sdk/timestep/ui/backend/canvas/","filename":"animate.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package ui.backend.canvas.animate;\n *\n * Canvas animate namespace and functions.\n */\n\njsio(\"import event.Emitter as Emitter\");\njsio(\"import animate.transitions as transitions\");\njsio(\"import timer\");\n\nvar anim_uid = 0;\n\nexports = function(subject, groupId) {\n\n\t// TODO: we have a circular import, so do the Engine import on first use\n\tif (typeof Engine == 'undefined') {\n\t\tjsio(\"import ui.Engine as Engine\");\n\t\tjsio(\"import ui.View as View\");\n\t}\n\n\tvar groupId = groupId || 0,\n\t\tgroup = groups[groupId] || (groups[groupId] = new Group()),\n\t\tanimID = subject.__anim_id || (subject.__anim_id = '__anim_' + (++anim_uid)),\n\t\tanim = group.get(animID);\n\n\tif (!anim) {\n\t\tanim = subject instanceof View\n\t\t\t\t? new ViewAnimator(subject, group)\n\t\t\t\t: new Animator(subject, group);\n\n\t\tgroup.add(animID, anim);\n\t}\n\n\treturn anim;\n}\n\nexports.getViewAnimator = function() {\n\treturn ViewAnimator;\n};\n\nexports.setViewAnimator = function(ctor) {\n\tViewAnimator = ctor;\n};\n\nGroup=__class__;var Group=Group(function Group(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function() {\n\t\tthis._anims = {};\n\t\tthis._pending = [];\n\t};\n\n\tthis.get = function(id) { return this._anims[id]; };\n\n\tthis.add = function(id, q) {\n\t\tthis._anims[id] = q;\n\t\tq.id = id;\n\t\treturn q;\n\t};\n\n\tthis.isActive = function() {\n\t\tfor (var id in this._anims) {\n\t\t\tif (this._anims[id].hasFrames()) { return true; }\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.onAnimationFinish = function(anim) {\n\t\tdelete this._anims[anim.id];\n\n\t\tif (!this.isActive()) {\n\t\t\t// if called from a Finish event, republish it\n\t\t\tthis.publish('Finish');\n\t\t}\n\t};\n});\n\nvar groups = {\n\t0: new Group()\n};\n\nexports.getGroup = function(i) {\n\treturn groups[i || 0];\n};\n\nvar TRANSITIONS = [\n\ttransitions.easeInOut, // 0: default\n\ttransitions.linear,    // 1\n\ttransitions.easeIn,    // 2\n\ttransitions.easeOut,   // 3\n\ttransitions.easeInOut, // 4\n\ttransitions.bounce     // 5\n];\n\nexports.linear = 1;\nexports.easeIn = 2;\nexports.easeOut = 3;\nexports.easeInOut = 4;\nexports.bounce = 5;\n\nfunction getTransition(n) {\n\treturn (typeof n == 'function' ? n : TRANSITIONS[n | 0]);\n}\n\nFrame=__class__;var Frame=Frame(function Frame(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tthis.subject = opts.subject;\n\t\tthis.target = opts.target;\n\t\tthis.duration = opts.duration || 0;\n\t\tthis.transition = getTransition(opts.transition);\n\t\tthis.onTick = opts.onTick;\n\t};\n\n\tthis.exec = function() {};\n\tthis.onInterrupt = function() {};\n});\n\nCallbackFrame=__class__;var CallbackFrame=CallbackFrame(function CallbackFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\tthis.exec = function(tt, t) {\n\t\tthis.target.apply(this.subject, arguments);\n\t};\n});\n\n// a wait frame is just a frame that does nothing... so we\n// don't need to do anything!\nvar WaitFrame = Frame;\n\nObjectFrame=__class__;var ObjectFrame=ObjectFrame(function ObjectFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\tthis.exec = function(tt, t, debug) {\n\t\tif (!this.base) {\n\t\t\tthis.base = {};\n\t\t\tfor (var key in this.target) {\n\t\t\t\tthis.base[key] = this.subject[key];\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in this.target) {\n\t\t\tthis.subject[key] = (this.target[key] - this.base[key]) * tt + this.base[key];\n\t\t}\n\n\t\tif (debug) {\n\t\t\tvar changed = {};\n\t\t\tfor (var key in this.target) {\n\t\t\t\tchanged[key] = this.subject[key] + ' -> ' + this.target[key];\n\t\t\t}\n\t\t\tlogger.log(this.duration, tt, JSON.stringify(changed));\n\t\t}\n\t};\n});\n\n// a ViewStyleFrame updates a view's style in exec\nViewStyleFrame=__class__;var ViewStyleFrame=ViewStyleFrame(function ViewStyleFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\n\tthis._resolvedDeltas = false;\n\n\tthis.init = function(opts) {\n\t\tthis.subject = opts.subject;\n\t\tthis.target = merge({}, opts.target);\n\t\tthis.duration = opts.duration === 0 ? 0 : (opts.duration || 500);\n\t\tthis.transition = getTransition(opts && opts.transition);\n\t\tthis.onTick = opts.onTick;\n\t};\n\n\tthis.resolveDeltas = function(againstStyle) {\n\t\tvar style = this.target;\n\t\tthis._resolvedDeltas = true;\n\t\tfor (var key in style) {\n\t\t\tvar baseKey = key.substring(1);\n\t\t\tif (key.charAt(0) == 'd' && !(key in againstStyle) && (baseKey in againstStyle)) {\n\t\t\t\tstyle[baseKey] = style[key] + againstStyle[baseKey];\n\t\t\t\tdelete style[key];\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.exec = function(tt, t, debug) {\n\t\tvar oldStyle = this._baseStyle || (this._baseStyle = this.subject.style.copy()),\n\t\t\tnewStyle = this.target;\n\n\t\tif (!this._resolvedDeltas) { this.resolveDeltas(this._baseStyle); }\n\n\t\tvar oldStyle = this._baseStyle;\n\t\tfor (var key in newStyle) {\n\t\t\tif (key in oldStyle) {\n\t\t\t\tthis.subject.style[key] = (newStyle[key] - oldStyle[key]) * tt + oldStyle[key];\n\t\t\t}\n\t\t}\n\n\t\tthis.subject.needsRepaint();\n\n\t\tif (debug) {\n\t\t\tvar changed = {};\n\t\t\tfor (var key in newStyle) {\n\t\t\t\tchanged[key] = this.subject.style[key] + ' -> ' + newStyle[key];\n\t\t\t}\n\t\t\tlogger.log(timer.now, this.duration, tt, JSON.stringify(changed));\n\t\t}\n\t};\n\n\tthis.onInterrupt = function(newFrame) {\n\t\t// var preStyle = this.subject.style.copy();\n\n\t\t// You might want to resolve any deltas against the post-committed style.\n\t\t// But I think this should be off by default.  You can commit the style,\n\t\t// resolve your deltas, then restore the old style yourself if you want.\n\t\t// I don't think you _always_ want this to be the behavior?\n\t\t//\n\t\t// this.commit(true);\n\t\t// newFrame.resolveDeltas(this.subject.style);\n\n\t\t// If you're animating multiple properties, and you've only\n\t\t// interrupted some of them, you may want the rest to continue.\n\t\t// This only looks good if the timing is the same too -- to do\n\t\t// this properly, you'd have to branch animations based on the\n\t\t// style property being animated...\n\t\t//\n\t\t// for (var i in ViewStyle.keys) {\n\t\t// \tif (postCommitStyle[i] != preStyle[i] && !(i in newStyle)) {\n\t\t// \t\tnewStyle[i] = postCommitStyle[i];\n\t\t// \t}\n\t\t// }\n\n\t\t// this.subject.style.update(preStyle);\n\t};\n});\n\nexports.Animator=__class__;var Animator = exports.Animator=exports.Animator(function exports_Animator(){return this.init&&this.init.apply(this,arguments)},Emitter, function() {\n\tthis.init = function(subject, group) {\n\t\tthis.subject = subject;\n\t\tthis._group = group;\n\t\tthis.clear();\n\t\tthis._isPaused = false;\n\t};\n\n\tthis.clear = function() {\n\t\tthis._elapsed = 0;\n\t\tthis._queue = [];\n\t\tthis._unschedule();\n\t\treturn this;\n\t};\n\n\t// this.getQueue = function() { return this._queue; }\n\n\t// Careful: pause will *not* fire the finish event, so anything pending the end of the\n\t// animation will have to wait until the animation is resumed.\n\tthis.pause = function() {\n\t\tif (!this._isPaused) {\n\t\t\tthis._isPaused = true;\n\t\t\tthis._unschedule();\n\t\t}\n\t};\n\n\tthis.resume = function() {\n\t\tif (this._isPaused) {\n\t\t\tthis._isPaused = false;\n\t\t\tthis._schedule();\n\t\t}\n\t};\n\n\tthis._schedule = function() {\n\t\tif (!this._isScheduled) {\n\t\t\tthis._isScheduled = true;\n\t\t\tEngine.get().subscribe('Tick', this, 'onTick');\n\t\t}\n\t};\n\n\tthis._unschedule = function() {\n\t\tif (this._isScheduled) {\n\t\t\tthis._isScheduled = false;\n\t\t\tEngine.get().unsubscribe('Tick', this, 'onTick');\n\t\t}\n\t};\n\n\tthis.isPaused = function() { return this._isPaused; };\n\tthis.hasFrames = function() { return !!this._queue[0]; };\n\n\tthis.wait = function(duration) {\n\t\treturn this.then(new WaitFrame({duration: duration}));\n\t};\n\n\tthis.buildFrame = function(opts) {\n\t\tif (typeof opts.target == 'function') {\n\t\t\treturn new CallbackFrame(opts);\n\t\t}\n\n\t\tif (typeof opts.target == 'object') {\n\t\t\treturn new ObjectFrame(opts);\n\t\t}\n\n\t\treturn new WaitFrame(opts);\n\t};\n\n\tthis.now = function(target, duration, transition, onTick) {\n\t\ttransition = transition || (this._queue[0] ? exports.easeOut : exports.easeInOut);\n\n\t\tvar nextFrame = target instanceof Frame\n\t\t\t\t? target\n\t\t\t\t: this.buildFrame({\n\t\t\t\t\t\tsubject: this.subject,\n\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\tduration: duration,\n\t\t\t\t\t\ttransition: transition,\n\t\t\t\t\t\tonTick: onTick\n\t\t\t\t\t});\n\n\t\tvar frame = this._queue[0];\n\t\tframe && frame.onInterrupt(nextFrame);\n\n\t\tthis.clear();\n\t\treturn this.then(nextFrame);\n\t};\n\n\tthis.then = function(target, duration, transition, onTick) {\n\t\tvar nextFrame = target instanceof Frame\n\t\t\t\t? target\n\t\t\t\t: this.buildFrame({\n\t\t\t\t\t\tsubject: this.subject,\n\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\tduration: duration,\n\t\t\t\t\t\ttransition: transition,\n\t\t\t\t\t\tonTick: onTick\n\t\t\t\t\t});\n\n\t\tthis._queue.push(nextFrame);\n\t\tthis._schedule();\n\t\treturn this;\n\t};\n\n\tthis.debug = function() { this._debug = true; return this; };\n\n\tthis.commit = function() {\n\t\tthis._elapsed = 0;\n\t\tfor (var i = 0, p; p = this._queue[i]; ++i) {\n\t\t\tthis._elapsed += p.duration;\n\t\t}\n\n\t\tthis.next();\n\t\treturn this;\n\t};\n\n\tthis.onTick = function(dt) {\n\t\tthis._elapsed += dt;\n\t\tthis.next();\n\n\t\tif (!this._isScheduled) {\n\t\t\tthis._group.onAnimationFinish(this);\n\t\t}\n\t};\n\n\tthis.next = function() {\n\t\tvar p,\n\t\t\ttarget;\n\n\t\tif (!this._queue[0]) { return; }\n\n\t\twhile ((p = this._queue[0])) {\n\t\t\tvar frameFinished = this._elapsed >= p.duration,\n\t\t\t\tt = frameFinished ? 1 : this._elapsed / p.duration,\n\t\t\t\ttt = p.transition(t);\n\n\t\t\tif (frameFinished) {\n\t\t\t\tthis._elapsed -= p.duration;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tp.exec(tt, t, this._debug);\n\t\t\t\tif (p.onTick) { p.onTick.call(p.subject, tt, t); }\n\t\t\t} finally {\n\t\t\t\t// if we haven't modified the queue in a callback, remove the frame if it is finished\n\t\t\t\tif (frameFinished && p == this._queue[0]) {\n\t\t\t\t\tthis._queue.shift();\n\t\t\t\t}\n\n\t\t\t\t// if we got paused during a callback or the\n\t\t\t\t// frame is not finished yet, don't continue\n\t\t\t\tif (!frameFinished || this._isPaused) { return; }\n\t\t\t}\n\t\t}\n\n\t\t// nothing left in the queue!\n\t\tthis._unschedule();\n\t};\n});\n\nViewAnimator=__class__;var ViewAnimator=ViewAnimator(function ViewAnimator(){return this.init&&this.init.apply(this,arguments)},Animator, function(supr) {\n\tthis.buildFrame = function(opts) {\n\t\tif (typeof opts.target == 'object') {\n\t\t\treturn new ViewStyleFrame(opts);\n\t\t}\n\n\t\treturn supr(this, 'buildFrame', arguments);\n\t};\n});\n","pre":true},"sdk/timestep/animate/transitions.js":{"path":"sdk/timestep/animate/transitions.js","friendlyPath":"animate.transitions","directory":"sdk/timestep/animate/","filename":"transitions.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module animate.transitions\n *\n * Transition functions for use by the animate features. These aren't referenced\n * directly by the animate namespace, but by numerical reference.\n *\n * @doc http://doc.gameclosure.com/api/animate.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/animate.md\n */\n\nexports.linear = function (n) { return n; }\nexports.easeIn = function (n) { return n * n; }\nexports.easeInOut = function (n) { return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2); }\nexports.easeOut = function(n) { return n * (2 - n); }\n","pre":true},"sdk/timestep/ui/backend/debug/FPSView.js":{"path":"sdk/timestep/ui/backend/debug/FPSView.js","friendlyPath":"ui.backend.debug.FPSView","directory":"sdk/timestep/ui/backend/debug/","filename":"FPSView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.backend.debug.FPSView;\n *\n * The view which renders the FPS when showFPS is set to true on the\n * Application options.\n *\n * TODO Move to debug package.\n */\n\njsio(\"import device\");\njsio(\"import lib.Enum as Enum\");\n\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import math.geom.intersect as intersect\");\n\njsio(\"import event.input.dispatch as dispatch\");\n\nvar viewModes = new Enum('FPS', 'DT');\n\nfunction strokeRect(ctx, rect, color) {\n\tctx.fillStyle = color;\n\tctx.fillRect(rect.x, rect.y, 1, rect.height);\n\tctx.fillRect(rect.x, rect.y, rect.width, 1);\n\tctx.fillRect(rect.x + rect.width - 1, rect.y, 1, rect.height);\n\tctx.fillRect(rect.x, rect.y + rect.height - 1, rect.width, 1);\n};\n\nfunction fillRect(ctx, rect, color) {\n\tctx.fillStyle = color;\n\tctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nGraph=__class__;var Graph=Graph(function Graph(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tvar Canvas = device.get('Canvas');\n\n\t\tthis._width = opts.width;\n\t\tthis._height = opts.height;\n\n\t\tthis._maxValue = opts.maxValue;\n\t\tthis._backgroundColor = opts.backgroundColor;\n\t\tthis._colors = opts.colors;\n\t\tthis._axisColor = opts.axisColor;\n\n\t\tthis._canvas = new Canvas({width: opts.width, height: opts.height});\n\t\tthis._ctx = this._canvas.getContext('2d');\n\t\tthis._ctx.fillStyle = opts.backgroundColor;\n\t\tthis._ctx.fillRect(0, 0, opts.width, opts.height);\n\n\t\tthis._offset = 0;\n\t\tthis._index = 0;\n\t};\n\n\tthis.addValues = function(values, timeAxis) {\n\t\tvar ctx = this._ctx,\n\t\t\twidth = this._width,\n\t\t\theight = this._height,\n\t\t\tvalue,\n\t\t\tmaxValue = this._maxValue,\n\t\t\tx = (this._offset + this._index) % width,\n\t\t\ty = this._height,\n\t\t\tn,\n\t\t\ti, j;\n\n\t\tctx.fillStyle = this._backgroundColor;\n\t\tctx.fillRect(x, 0, 2, height);\n\n\t\ti = values.length;\n\t\twhile (i) {\n\t\t\tvalue = values[--i];\n\t\t\tif (value > maxValue) {\n\t\t\t\tvalue = maxValue;\n\t\t\t}\n\t\t\tn = ~~(value / maxValue *  height);\n\t\t\tctx.fillStyle = this._colors[i];\n\t\t\tctx.fillRect(x, height - n, 2, n);\n\t\t}\n\n\t\tctx.fillStyle = this._axisColor;\n\t\tif (timeAxis) {\n\t\t\tctx.fillRect(x, 0, 1, height);\n\t\t}\n\t\tctx.fillRect(x, 25, 2, 1);\n\t\tctx.fillRect(x, 50, 2, 1);\n\t\tctx.fillRect(x, 75, 2, 1);\n\n\t\tif (this._index < width) {\n\t\t\tthis._index += 2;\n\t\t} else {\n\t\t\tthis._offset += 2;\n\t\t\tif (this._offset >= width) {\n\t\t\t\tthis._offset = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.render = function(ctx, x, y) {\n\t\tvar offset = this._offset,\n\t\t\twidth = this._width,\n\t\t\theight = this._height;\n\n\t\tif (offset === 0) {\n\t\t\tctx.drawImage(this._canvas, 0, 0, width, height, x, y, width, height);\n\t\t} else {\n\t\t\tctx.drawImage(this._canvas, offset, 0, width - offset, height, x, y, width - offset, height);\n\t\t\tctx.drawImage(this._canvas, 0, 0, offset, height, width - offset + x, y, offset, height);\n\t\t}\n\t};\n});\n\nvar sdk_timestep_ui_backend_debug_FPSView=__class__;exports=sdk_timestep_ui_backend_debug_FPSView(function sdk_timestep_ui_backend_debug_FPSView(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tthis._application = opts.application;\n\n\t\tthis._time = +(new Date()) + 1000;\n\t\tthis._frames = 0;\n\t\tthis._fps = 20;\n\t\tthis._dt = 10;\n\n\t\tthis._minimized = true;\n\n\t\tvar width = 200,\n\t\t\theight = 100;\n\n\t\tthis._rectTop = new Rect(1, 1, width, 16);\n\t\tthis._rectMin = new Rect(0, 0, 24, 15);\n\t\tthis._rectMax = new Rect(0, 0, width + 2, height + 17);\n\t\tthis._rect = this._rectMin;\n\n\t\tthis._rectFPS = new Rect(141, 1, 30, 15);\n\t\tthis._rectDT = new Rect(171, 1, 30, 15);\n\n\t\tthis._borderColor = 'rgb(100,100,150)';\n\t\tthis._backgroundColor = '#17182E';\n\t\tthis._textColor = '#FFFFFF';\n\n\t\tthis._viewMode = viewModes.DT;\n\n\t\tthis._graphs = {}\n\t\tthis._graphs[viewModes.FPS] = new Graph({\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmaxValue: 60,\n\t\t\tbackgroundColor: this._backgroundColor,\n\t\t\tcolors: ['rgba(170,170,252,0.3)', 'rgb(170,170,252)'],\n\t\t\taxisColor: '#FFFFFF'\n\t\t});\n\t\tthis._graphs[viewModes.DT] = new Graph({\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmaxValue: 66,\n\t\t\tbackgroundColor: this._backgroundColor,\n\t\t\tcolors: ['rgba(255,0,0,0.5)', 'rgb(254,255,170)'],\n\t\t\taxisColor: '#FFFFFF'\n\t\t});\n\t};\n\n\tthis.tick = function(dt) {\n\t\tvar time = +(new Date());\n\t\tif (time > this._time) {\n\t\t\tthis._time = time + 1000;\n\t\t\tthis._fps = this._frames;\n\t\t\tthis._frames = 1;\n\t\t} else {\n\t\t\tthis._frames++;\n\t\t}\n\n\t\tvar events = this._application.getEvents();\n\t\tif (events.length) {\n\t\t\tthis._handleEvents(events);\n\t\t}\n\n\t\tthis._dt = this._dt * 0.8 + dt * 0.2;\n\n\t\tif (!this._minimized) {\n\t\t\tswitch (this._viewMode) {\n\t\t\t\tcase viewModes.DT:\n\t\t\t\t\tthis._graphs[viewModes.DT].addValues([this._dt, dt], (this._frames === 1));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase viewModes.FPS:\n\t\t\t\t\tthis._graphs[viewModes.FPS].addValues([this._fps, 1000 / dt], (this._frames === 1));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._handleEvents = function(events) {\n\t\tvar types = dispatch.eventTypes;\n\t\tvar i = events.length;\n\n\t\twhile (i) {\n\t\t\tvar event = events[--i];\n\t\t\tswitch (event.type) {\n\t\t\t\tcase types.START:\n\t\t\t\t\tif (intersect.ptAndRect(event.srcPt, this._rect)) {\n\t\t\t\t\t\tif (this._minimized) {\n\t\t\t\t\t\t\tthis._minimized = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (intersect.ptAndRect(event.srcPt, this._rectFPS)) {\n\t\t\t\t\t\t\t\tthis._viewMode = viewModes.FPS;\n\t\t\t\t\t\t\t} else if (intersect.ptAndRect(event.srcPt, this._rectDT)) {\n\t\t\t\t\t\t\t\tthis._viewMode = viewModes.DT;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._minimized = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._rect = this._minimized ? this._rectMin : this._rectMax;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.render = function(ctx) {\n\t\tctx.save();\n\n\t\tctx.textBaseline = 'top';\n\t\tctx.textAlign = 'center';\n\t\tctx.font = '12px Verdana';\n\n\t\tif (this._minimized) {\n\t\t\tfillRect(ctx, this._rect, this._backgroundColor);\n\t\t} else {\n\t\t\tfillRect(ctx, this._rectTop, this._backgroundColor);\n\t\t\tthis._graphs[this._viewMode].render(ctx, 1, 17);\n\t\t\tctx.fillStyle = this._borderColor;\n\t\t\tctx.fillRect(0, 16, this._rect.width, 1);\n\n\t\t\tvar fpsMode = (this._viewMode === viewModes.FPS),\n\t\t\t\tdtMode = (this._viewMode === viewModes.DT);\n\n\t\t\tfillRect(ctx, this._rectFPS, fpsMode ? this._borderColor : this._backgroundColor);\n\t\t\tctx.fillStyle = fpsMode ? this._textColor : this._borderColor;\n\t\t\tctx.fillText('FPS', this._rectFPS.x + this._rectFPS.width / 2, 0);\n\n\t\t\tfillRect(ctx, this._rectDT, dtMode ? this._borderColor : this._backgroundColor);\n\t\t\tctx.fillStyle = dtMode ? this._textColor : this._borderColor;\n\t\t\tctx.fillText('DT', this._rectDT.x + this._rectDT.width / 2, 0);\n\t\t}\n\n\t\tstrokeRect(ctx, this._rect, this._borderColor);\n\n\t\tctx.fillStyle = this._textColor;\n\t\tctx.fillText(this._fps, 12, 0);\n\n\t\tctx.restore();\n\t};\n\n\tthis.getFPS = function() {\n\t\treturn this._fps;\n\t};\n});\n","pre":true},"sdk/timestep/platforms/browser/FontBuffer.js":{"path":"sdk/timestep/platforms/browser/FontBuffer.js","friendlyPath":".FontBuffer","directory":"sdk/timestep/platforms/browser/","filename":"FontBuffer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package env.browser.FontBuffer;\n *\n * ??? What the hell is this\n */\n\njsio(\"import device\");\n\nvar randomColorElement = function() {\n\tvar e = Math.floor(Math.random() * 255).toString(16);\n\treturn ((e.length === 1) ? '0' : '') + e;\n};\n\nvar randomColor = function() {\n\treturn '#' + randomColorElement() + randomColorElement() + randomColorElement();\n};\n\nvar sdk_timestep_platforms_browser_FontBuffer=__class__;var FontBuffer = exports=sdk_timestep_platforms_browser_FontBuffer(function sdk_timestep_platforms_browser_FontBuffer(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\t// 8 * 24\n\t\t// 10 * 32\n\t\t// 8 * 64\n\t\tvar lineSizes = [{size: 24, count: 8}, {size: 32, count: 10}, {size: 64, count: 8}],\n\t\t\tlineSize,\n\t\t\tlines,\n\t\t\titem,\n\t\t\ty = 0,\n\t\t\ti, j;\n\n\t\tthis._canvas = document.createElement('canvas');\n\t\tthis._canvas.width = 1024;\n\t\tthis._canvas.height = 1024;\n\t\tthis._ctx = this._canvas.getContext('2d');\n\n\t\tthis._list = [];\n\t\tfor (i = 0; i < lineSizes.length; i++) {\n\t\t\tlines = [];\n\t\t\tlineSize = lineSizes[i];\n\n\t\t\tfor (j = 0; j < lineSize.count; j++) {\n\t\t\t\titem = {\n\t\t\t\t\tprevious: null,\n\t\t\t\t\tnext: null,\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: 1024,\n\t\t\t\t\theight: 0,\n\t\t\t\t\thash: null,\n\t\t\t\t\tframe: 0,\n\t\t\t\t\trefresh: true,\n\t\t\t\t\tctx: this._ctx\n\t\t\t\t};\n\t\t\t\tlines.push(item);\n\t\t\t\ty += lineSize.size;\n\t\t\t}\n\n\t\t\tthis._list.push({\n\t\t\t\tsize: lineSize.size,\n\t\t\t\tlines: lines\n\t\t\t});\n\t\t}\n\n\t\tthis._hashMap = {};\n\n\t\tthis._currentFrame = 0;\n\t\tthis._frameTimeout = 3;\n\n\t\tjsio('import ui.Engine').get().subscribe('Tick', this, this._onTick);\n\t};\n\n\tthis._onTick = function(dt) {\n\t\tthis._currentFrame++;\n\n\t\tvar remove,\n\t\t\tcurrentFrame = this._currentFrame,\n\t\t\tframeTimeout = this._frameTimeout,\n\t\t\tlist = this._list,\n\t\t\tlines,\n\t\t\titem,\n\t\t\ti, j, k, l;\n\n\t\tfor (i = 0, j = list.length; i < j; i++) {\n\t\t\tlines = list[i].lines;\n\t\t\tfor (k = 0, l = lines.length; k < l; k++) {\n\t\t\t\titem = lines[k];\n\t\t\t\twhile (item) {\n\t\t\t\t\tif (item.hash === null) {\n\t\t\t\t\t\tif (item.next && (item.next.hash === null)) {\n\t\t\t\t\t\t\titem.width += item.next.width;\n\t\t\t\t\t\t\titem.next = item.next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (currentFrame > item.frame + frameTimeout) {\n\t\t\t\t\t\tthis._ctx.fillStyle = randomColor();\n\t\t\t\t\t\tthis._ctx.fillRect(item.x, item.y, item.width, item.height);\n\t\t\t\t\t\t// Remove old item...\n\t\t\t\t\t\tdelete(this._hashMap[item.hash]);\n\t\t\t\t\t\titem.hash = null;\n\t\t\t\t\t}\n\t\t\t\t\titem = item.next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.alloc = function(opts) {\n\t\tvar requestHeight = opts.height,\n\t\t\trequestWidth = opts.width + 3, // Add some extra pixels to allow color bleeding...\n\n\t\t\tstrokeStyle = opts.strokeStyle || '',\n\t\t\tfillStyle = opts.fillStyle || '',\n\t\t\tfont = opts.font || '',\n\t\t\thash = strokeStyle + '_' + fillStyle + '_' + font + '_' + opts.text,\n\n\t\t\tlist = this._list,\n\t\t\tlines,\n\t\t\titem = this._hashMap[hash],\n\t\t\ti, j, k, l;\n\n\t\tif (item) {\n\t\t\titem.frame = this._currentFrame;\n\t\t\titem.refresh = false;\n\t\t\treturn item;\n\t\t}\n\n\t\tfor (i = 0, j = list.length; i < j; i++) {\n\t\t\tif (requestHeight <= list[i].size) {\n\t\t\t\tlines = list[i].lines;\n\t\t\t\tfor (k = 0, l = lines.length; k < l; k++) {\n\t\t\t\t\titem = lines[k];\n\t\t\t\t\twhile (item) {\n\t\t\t\t\t\tif ((requestWidth <= item.width) && (item.hash === null)) {\n\t\t\t\t\t\t\tif (requestWidth !== item.width) {\n\t\t\t\t\t\t\t\t//console.log('request:', requestWidth, 'width:', item.width, 'rest:', item.width - requestWidth);\n\t\t\t\t\t\t\t\titem.next = {\n\t\t\t\t\t\t\t\t\tprevious: item,\n\t\t\t\t\t\t\t\t\tnext: item.next,\n\t\t\t\t\t\t\t\t\tx: item.x + requestWidth,\n\t\t\t\t\t\t\t\t\ty: item.y,\n\t\t\t\t\t\t\t\t\twidth: item.width - requestWidth,\n\t\t\t\t\t\t\t\t\thash: null,\n\t\t\t\t\t\t\t\t\tframe: 0,\n\t\t\t\t\t\t\t\t\tctx: this._ctx\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\titem.frame = this._currentFrame;\n\t\t\t\t\t\t\titem.hash = hash;\n\t\t\t\t\t\t\titem.width = requestWidth;\n\t\t\t\t\t\t\titem.height = requestHeight;\n\t\t\t\t\t\t\titem.refresh = true;\n\n\t\t\t\t\t\t\tthis._ctx.clearRect(item.x, item.y, requestWidth, requestHeight);\n\n\t\t\t\t\t\t\tthis._hashMap[hash] = item;\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem = item.next;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.getCanvas = function() {\n\t\treturn this._canvas;\n\t};\n});\n","pre":true},"sdk/timestep/platforms/browser/dev_error.js":{"path":"sdk/timestep/platforms/browser/dev_error.js","friendlyPath":".dev_error","directory":"sdk/timestep/platforms/browser/","filename":"dev_error.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package timestep.env.browser.dev_error;\n *\n * Displays a developer error.\n *\n * ??? TODO move to a debug package.\n */\n\nexports.render = function(e) {\n\tlogger.error(\"unhandled tick exception\");\n\tlogger.error(e.stack);\n\t\n\tvar c = document.getElementsByTagName('canvas');\n\tfor (var i = 0, el; el = c[i]; ++i) {\n\t\trender(el.getContext('2d'), e);\n\t}\n}\n\nfunction render(ctx, e) {\n\tctx.fillStyle = \"rgb(0, 0, 255)\";\n\tctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\n\tvar x = 30, y = 40;\n\n\tctx.fillStyle = \"#FFF\";\n\tctx.font = \"bold 12px Monaco,\\\"Bitstream Vera Sans Mono\\\",\\\"Lucida Console\\\",Terminal,monospace\";\n\tfunction drawLine(msg) {\n\t\tctx.fillText(msg, x, y);\n\t\ty += 20;\n\t}\n\t\n\tdrawLine(e.message);\n\ty += 40;\n\te.stack.split('\\n').map(drawLine);\n}\n","pre":true},"sdk/timestep/platforms/browser/FlashAPI.js":{"path":"sdk/timestep/platforms/browser/FlashAPI.js","friendlyPath":".FlashAPI","directory":"sdk/timestep/platforms/browser/","filename":"FlashAPI.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use import\";\n\njsio(\"import lib.PubSub\");\njsio(\"import .SoundManager\");\njsio(\"from util.underscore import _\");\n\nvar soundManager = new SoundManager();\nsoundManager.url = 'media/swf';\nsoundManager.flashVersion = 9;\nsoundManager.useMovieStar = true;\nsoundManager.debugMode = false;\nsoundManager.consoleOnly = true;\nsoundManager.useHighPerformance = true;\nsoundManager.useFastPolling = true;\n\n/**\n * @extends lib.PubSub\n */\nvar sdk_timestep_platforms_browser_FlashAPI=__class__;var AudioAPI = exports=sdk_timestep_platforms_browser_FlashAPI(function sdk_timestep_platforms_browser_FlashAPI(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function(supr) {\n\tthis.init = function(opts) {\n\n\t\topts = merge(opts, {\n\t\t\tmap: {},\n\t\t\tbackground: []\n\t\t});\n\n\t\tsupr(this, 'init', [opts]);\n\t\tvar path = opts.path;\n\t\tthis._map = {};\n\n\t\t_.each(opts.background, function(name) {\n\t\t\topts.map[name] = {'name': name}\n\t\t}, this);\n\t\t\n\t\tsoundManager.onready(bind(this, function() {\n\t\t\tlogger.log('SoundManager onReady');\n\t\t\tfor (key in opts.map) {\n\t\t\t\tlogger.log('SoundManager key: ', key);\n\t\t\t\tvar url = 'media/audio/'  + key + '.mp3';\n\t\t\t\tvar k = this._map[key] = soundManager.createSound({\n\t\t\t\t\tid: key,\n\t\t\t\t\tbufferTime: 3,\n\t\t\t\t\turl: url\n\t\t\t\t});\n\t\t\t\tk.load();\n\t\t\t}\n\n\t\t\tthis.publish('Ready');\n\t\t}));\n\t}\n\t\n\tthis.canPlay = function(name) {\n\t\treturn (name in this._map);\n\t}\n\t\n\tthis.setVolume = function(volume) {\n\t\tthis._soundPlaying && soundManager.setVolume(this._soundPlaying, volume);\n\t\tthis._backgroundSoundPlaying && soundManager.setVolume(this._backgroundSoundPlaying, volume);\n\t}\n\n\tthis.setMuted = function(muted) {\n\t\tthis.muted = muted;\n\t\tif (muted) {\n\t\t\tthis.setVolume(0);\n\t\t}\n\t}\n\n\tthis.play = function(name, volume, channel) {\n\t\tif (!this.canPlay(name)) { return; }\n\t\tif (this.muted) { return; }\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tthis._soundPlaying = name;\n\t\tthis._map[name].setVolume(volume * 100 | 0);\n\t\tthis._map[name].play();\n\t}\n\n\tthis.pause = function() {\n\t\tthis._map[this._soundPlaying].pause();\n\t\tthis._soundPlaying = null;\n\t}\n\n\tthis.playBackgroundMusic = function(name, volume) {\n\t\tif (!this.canPlay(name)) { return; }\n\t\tif (this.muted) { return; }\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tthis._backgroundSoundPlaying = name;\n\t\tthis._map[name].setVolume(volume * 100 | 0);\n\t\tthis._map[name].play();\n\t}\n\n\tthis.pauseBackgroundMusic = function() {\n\t\tif (!this._backgroundSoundPlaying) { return; }\n\t\tthis._map[this._backgroundSoundPlaying].pause();\n\t\tthis._backgroundSoundPlaying = null;\n\t}\n});\n","pre":true},"sdk/timestep/platforms/browser/SoundManager.js":{"path":"sdk/timestep/platforms/browser/SoundManager.js","friendlyPath":".SoundManager","directory":"sdk/timestep/platforms/browser/","filename":"SoundManager.js","src":"/** @license\r\n * SoundManager 2: JavaScript Sound for the Web\r\n * ----------------------------------------------\r\n * http://schillmania.com/projects/soundmanager2/\r\n *\r\n * Copyright (c) 2007, Scott Schiller. All rights reserved.\r\n * Code provided under the BSD License:\r\n * http://schillmania.com/projects/soundmanager2/license.txt\r\n *\r\n * V2.97a.20110801\r\n*/\r\n\r\n/*global window, SM2_DEFER, sm2Debugger, console, document, navigator, setTimeout, setInterval, clearInterval, Audio */\r\n/*jslint regexp: true, sloppy: true, white: true, nomen: true, plusplus: true */\r\n\r\nvar SoundManager = exports = function SoundManager(smURL, smID) {\r\n\r\n  this.flashVersion = 8;             // version of flash to require, either 8 or 9. Some API features require Flash 9.\r\n  this.debugMode = true;             // enable debugging output (div#soundmanager-debug, OR console if available+configured)\r\n  this.debugFlash = false;           // enable debugging output inside SWF, troubleshoot Flash/browser issues\r\n  this.useConsole = true;            // use firebug/safari console.log()-type debug console if available\r\n  this.consoleOnly = false;          // if console is being used, do not create/write to #soundmanager-debug\r\n  this.waitForWindowLoad = false;    // force SM2 to wait for window.onload() before trying to call soundManager.onload()\r\n  this.nullURL = 'about:blank';      // path to \"null\" (empty) MP3 file, used to unload sounds (Flash 8 only)\r\n  this.allowPolling = true;          // allow flash to poll for status update (required for whileplaying() events, peak, sound spectrum functions to work.)\r\n  this.useFastPolling = false;       // uses lower flash timer interval for higher callback frequency, best combined with useHighPerformance\r\n  this.useMovieStar = true;          // enable support for Flash 9.0r115+ (codename \"MovieStar\") MPEG4 audio formats (AAC, M4V, FLV, MOV etc.)\r\n  this.bgColor = '#ffffff';          // movie (.swf) background color, eg. '#000000'\r\n  this.useHighPerformance = false;   // position:fixed flash movie can help increase js/flash speed, minimize lag\r\n  this.flashPollingInterval = null;  // msec for polling interval. Defaults to 50 unless useFastPolling = true.\r\n  this.flashLoadTimeout = 1000;      // msec to wait for flash movie to load before failing (0 = infinity)\r\n  this.wmode = null;                 // string: flash rendering mode - null, transparent, opaque (last two allow layering of HTML on top)\r\n  this.allowScriptAccess = 'always'; // for scripting the SWF (object/embed property), either 'always' or 'sameDomain'\r\n  this.useFlashBlock = false;        // *requires flashblock.css, see demos* - allow recovery from flash blockers. Wait indefinitely and apply timeout CSS to SWF, if applicable.\r\n  this.useHTML5Audio = true;         // Beta feature: Use HTML5 Audio() where API is supported (most Safari, Chrome versions), Firefox (no MP3/MP4.) Ideally, transparent vs. Flash API where possible.\r\n  this.html5Test = /^(probably|maybe)$/i; // HTML5 Audio() format support test. Use /^probably$/i; if you want to be more conservative.\r\n  this.preferFlash = true;           // (experimental) if true and flash support present, will try to use flash for MP3/MP4 as needed since HTML5 audio support is still quirky in browsers.\r\n\r\n  this.audioFormats = {\r\n    /*\r\n     * determines HTML5 support + flash requirements.\r\n     * if no support for a \"required\" format, SM2 will fail to start.\r\n     * flash fallback is used for MP3 or MP4 if HTML5 can't play it (or if preferFlash = true)\r\n     * multiple MIME types may be tested while trying to get a positive canPlayType() response.\r\n    */\r\n    'mp3': {\r\n      'type': ['audio/mpeg; codecs=\"mp3\"', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'],\r\n      'required': true\r\n    },\r\n    'mp4': {\r\n      'related': ['aac','m4a'], // additional formats under the MP4 container\r\n      'type': ['audio/mp4; codecs=\"mp4a.40.2\"', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'],\r\n      'required': false\r\n    },\r\n    'ogg': {\r\n      'type': ['audio/ogg; codecs=vorbis'],\r\n      'required': false\r\n    },\r\n    'wav': {\r\n      'type': ['audio/wav; codecs=\"1\"', 'audio/wav', 'audio/wave', 'audio/x-wav'],\r\n      'required': false\r\n    }\r\n  };\r\n\r\n  this.defaultOptions = {\r\n    'autoLoad': false,             // enable automatic loading (otherwise .load() will be called on demand with .play(), the latter being nicer on bandwidth - if you want to .load yourself, you also can)\r\n    'stream': true,                // allows playing before entire file has loaded (recommended)\r\n    'autoPlay': false,             // enable playing of file as soon as possible (much faster if \"stream\" is true)\r\n    'loops': 1,                    // how many times to repeat the sound (position will wrap around to 0, setPosition() will break out of loop when >0)\r\n    'onid3': null,                 // callback function for \"ID3 data is added/available\"\r\n    'onload': null,                // callback function for \"load finished\"\r\n    'whileloading': null,          // callback function for \"download progress update\" (X of Y bytes received)\r\n    'onplay': null,                // callback for \"play\" start\r\n    'onpause': null,               // callback for \"pause\"\r\n    'onresume': null,              // callback for \"resume\" (pause toggle)\r\n    'whileplaying': null,          // callback during play (position update)\r\n    'onstop': null,                // callback for \"user stop\"\r\n    'onfailure': null,             // callback function for when playing fails\r\n    'onfinish': null,              // callback function for \"sound finished playing\"\r\n    'onbeforefinish': null,        // callback for \"before sound finished playing (at [time])\"\r\n    'onbeforefinishtime': 5000,    // offset (milliseconds) before end of sound to trigger beforefinish (eg. 1000 msec = 1 second)\r\n    'onbeforefinishcomplete': null,// function to call when said sound finishes playing\r\n    'onjustbeforefinish': null,    // callback for [n] msec before end of current sound\r\n    'onjustbeforefinishtime': 200, // [n] - if not using, set to 0 (or null handler) and event will not fire.\r\n    'multiShot': true,             // let sounds \"restart\" or layer on top of each other when played multiple times, rather than one-shot/one at a time\r\n    'multiShotEvents': false,      // fire multiple sound events (currently onfinish() only) when multiShot is enabled\r\n    'position': null,              // offset (milliseconds) to seek to within loaded sound data.\r\n    'pan': 0,                      // \"pan\" settings, left-to-right, -100 to 100\r\n    'type': null,                  // MIME-like hint for file pattern / canPlay() tests, eg. audio/mp3\r\n    'usePolicyFile': false,        // enable crossdomain.xml request for audio on remote domains (for ID3/waveform access)\r\n    'volume': 100                  // self-explanatory. 0-100, the latter being the max.\r\n  };\r\n\r\n  this.flash9Options = {      // flash 9-only options, merged into defaultOptions if flash 9 is being used\r\n    'isMovieStar': null,      // \"MovieStar\" MPEG4 audio mode. Null (default) = auto detect MP4, AAC etc. based on URL. true = force on, ignore URL\r\n    'usePeakData': false,     // enable left/right channel peak (level) data\r\n    'useWaveformData': false, // enable sound spectrum (raw waveform data) - WARNING: CPU-INTENSIVE: may set CPUs on fire.\r\n    'useEQData': false,       // enable sound EQ (frequency spectrum data) - WARNING: Also CPU-intensive.\r\n    'onbufferchange': null,   // callback for \"isBuffering\" property change\r\n    'ondataerror': null       // callback for waveform/eq data access error (flash playing audio in other tabs/domains)\r\n  };\r\n\r\n  this.movieStarOptions = { // flash 9.0r115+ MPEG4 audio options, merged into defaultOptions if flash 9+movieStar mode is enabled\r\n    'bufferTime': 3,        // seconds of data to buffer before playback begins (null = flash default of 0.1 seconds - if AAC playback is gappy, try increasing.)\r\n    'serverURL': null,      // rtmp: FMS or FMIS server to connect to, required when requesting media via RTMP or one of its variants\r\n    'onconnect': null,      // rtmp: callback for connection to flash media server\r\n    'duration': null        // rtmp: song duration (msec)\r\n  };\r\n\r\n  this.version = null;\r\n  this.versionNumber = 'V2.97a.20110801';\r\n  this.movieURL = null;\r\n  this.url = (smURL || null);\r\n  this.altURL = null;\r\n  this.swfLoaded = false;\r\n  this.enabled = false;\r\n  this.o = null;\r\n  this.movieID = 'sm2-container';\r\n  this.id = (smID || 'sm2movie');\r\n  this.swfCSS = {\r\n    'swfBox': 'sm2-object-box',\r\n    'swfDefault': 'movieContainer',\r\n    'swfError': 'swf_error', // SWF loaded, but SM2 couldn't start (other error)\r\n    'swfTimedout': 'swf_timedout',\r\n    'swfLoaded': 'swf_loaded',\r\n    'swfUnblocked': 'swf_unblocked', // or loaded OK\r\n    'sm2Debug': 'sm2_debug',\r\n    'highPerf': 'high_performance',\r\n    'flashDebug': 'flash_debug'\r\n  };\r\n  this.oMC = null;\r\n  this.sounds = {};\r\n  this.soundIDs = [];\r\n  this.muted = false;\r\n  this.debugID = 'soundmanager-debug';\r\n  this.debugURLParam = /([#?&])debug=1/i;\r\n  this.specialWmodeCase = false;\r\n  this.didFlashBlock = false;\r\n\r\n  this.filePattern = null;\r\n  this.filePatterns = {\r\n    'flash8': /\\.mp3(\\?.*)?$/i,\r\n    'flash9': /\\.mp3(\\?.*)?$/i\r\n  };\r\n\r\n  this.baseMimeTypes = /^\\s*audio\\/(?:x-)?(?:mp(?:eg|3))\\s*(?:$|;)/i; // mp3\r\n  this.netStreamMimeTypes = /^\\s*audio\\/(?:x-)?(?:mp(?:eg|3))\\s*(?:$|;)/i; // mp3, mp4, aac etc.\r\n  this.netStreamTypes = ['aac', 'flv', 'mov', 'mp4', 'm4v', 'f4v', 'm4a', 'mp4v', '3gp', '3g2']; // Flash v9.0r115+ \"moviestar\" formats\r\n  this.netStreamPattern = new RegExp('\\\\.(' + this.netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\r\n  this.mimePattern = this.baseMimeTypes;\r\n\r\n  this.features = {\r\n    'buffering': false,\r\n    'peakData': false,\r\n    'waveformData': false,\r\n    'eqData': false,\r\n    'movieStar': false\r\n  };\r\n\r\n  this.sandbox = {\r\n    // <d>\r\n    'type': null,\r\n    'types': {\r\n      'remote': 'remote (domain-based) rules',\r\n      'localWithFile': 'local with file access (no internet access)',\r\n      'localWithNetwork': 'local with network (internet access only, no local access)',\r\n      'localTrusted': 'local, trusted (local+internet access)'\r\n    },\r\n    'description': null,\r\n    'noRemote': null,\r\n    'noLocal': null\r\n    // </d>\r\n  };\r\n\r\n  this.hasHTML5 = (typeof Audio !== 'undefined' && typeof new Audio().canPlayType !== 'undefined'); // switch for handling logic\r\n\r\n  // stores canPlayType() results, etc. treat as read-only.\r\n  this.html5 = {\r\n    // mp3: boolean\r\n    // mp4: boolean\r\n    'usingFlash': null // set if/when flash fallback is needed\r\n  };\r\n\r\n  // format support\r\n  this.flash = {\r\n    // mp3: boolean\r\n    // mp4: boolean\r\n  };\r\n\r\n  this.html5Only = false;   // determined at init time\r\n  this.ignoreFlash = false; // used for special cases (eg. iPad/iPhone/palm OS?)\r\n\r\n  /*\r\n   * a few private internals\r\n  */\r\n\r\n  var SMSound,\r\n  _s = this, _sm = 'soundManager', _smc = _sm+'::', _h5 = 'HTML5::', _id, _ua = navigator.userAgent, _win = window, _wl = _win.location.href.toString(), _fV = this.flashVersion, _doc = document, _doNothing, _init, _on_queue = [], _debugOpen = true, _debugTS, _didAppend = false, _appendSuccess = false, _didInit = false, _disabled = false, _windowLoaded = false, _wDS, _wdCount = 0, _initComplete, _mixin, _addOnEvent, _processOnEvents, _initUserOnload, _delayWaitForEI, _waitForEI, _setVersionInfo, _handleFocus, _strings, _initMovie, _dcLoaded, _didDCLoaded, _getDocument, _createMovie, _catchError, _setPolling, _initDebug, _debugLevels = ['log', 'info', 'warn', 'error'], _defaultFlashVersion = 8, _disableObject, _failSafely, _normalizeMovieURL, _oRemoved = null, _oRemovedHTML = null, _str, _flashBlockHandler, _getSWFCSS, _toggleDebug, _loopFix, _policyFix, _complain, _idCheck, _waitingForEI = false, _initPending = false, _smTimer, _onTimer, _startTimer, _stopTimer, _needsFlash = null, _featureCheck, _html5OK, _html5CanPlay, _html5Ext,  _dcIE, _testHTML5, _event, _slice = Array.prototype.slice, _useGlobalHTML5Audio = false, _hasFlash, _detectFlash, _badSafariFix, _html5_events, _showSupport,\r\n  _is_iDevice = _ua.match(/(ipad|iphone|ipod)/i), _likesHTML5 = (_ua.match(/(mobile|pre\\/|xoom)/i) || _is_iDevice), _isIE = _ua.match(/msie/i), _isWebkit = _ua.match(/webkit/i), _isSafari = (_ua.match(/safari/i) && !_ua.match(/chrome/i)), _isOpera = (_ua.match(/opera/i)), \r\n  _isBadSafari = (!_wl.match(/usehtml5audio/i) && !_wl.match(/sm2\\-ignorebadua/i) && _isSafari && _ua.match(/OS X 10_6_([3-7])/i)), // Safari 4 and 5 occasionally fail to load/play HTML5 audio on Snow Leopard 10.6.3 through 10.6.7 due to bug(s) in QuickTime X and/or other underlying frameworks. :/ Confirmed bug. https://bugs.webkit.org/show_bug.cgi?id=32159\r\n  _hasConsole = (typeof console !== 'undefined' && typeof console.log !== 'undefined'), _isFocused = (typeof _doc.hasFocus !== 'undefined'?_doc.hasFocus():null), _tryInitOnFocus = (_isSafari && typeof _doc.hasFocus === 'undefined'), _okToDisable = !_tryInitOnFocus, _flashMIME = /(mp3|mp4|mpa)/i,\r\n  _overHTTP = (_doc.location?_doc.location.protocol.match(/http/i):null),\r\n  _http = (!_overHTTP ? 'http:' : '');\r\n\r\n  this.useAltURL = !_overHTTP; // use altURL if not \"online\"\r\n  this._global_a = null;\r\n\r\n  if (_likesHTML5) {\r\n    // prefer HTML5 for mobile + tablet-like devices, probably more reliable vs. flash at this point.\r\n    _s.useHTML5Audio = true;\r\n    _s.preferFlash = false;\r\n    if (_is_iDevice) {\r\n      // by default, use global feature. iOS onfinish() -> next may fail otherwise.\r\n      _s.ignoreFlash = true;\r\n      _useGlobalHTML5Audio = true;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * public soundManager API\r\n  */\r\n\r\n  this.ok = function() {\r\n    return (_needsFlash?(_didInit && !_disabled):(_s.useHTML5Audio && _s.hasHTML5));\r\n  };\r\n\r\n  this.supported = this.ok; // legacy\r\n\r\n  this.getMovie = function(smID) {\r\n    return _isIE?_win[smID]:(_isSafari?_id(smID) || _doc[smID]:_id(smID));\r\n  };\r\n\r\n  this.createSound = function(oOptions) {\r\n    var _cs = _sm+'.createSound(): ',\r\n    thisOptions = null, oSound = null, _tO = null;\r\n    if (!_didInit || !_s.ok()) {\r\n      _complain(_cs + _str(!_didInit?'notReady':'notOK'));\r\n      return false;\r\n    }\r\n    if (arguments.length === 2) {\r\n      // function overloading in JS! :) ..assume simple createSound(id,url) use case\r\n      oOptions = {\r\n        'id': arguments[0],\r\n        'url': arguments[1]\r\n      };\r\n    }\r\n    thisOptions = _mixin(oOptions); // inherit from defaultOptions\r\n    _tO = thisOptions; // alias\r\n    // <d>\r\n    if (_tO.id.toString().charAt(0).match(/^[0-9]$/)) {\r\n      _s._wD(_cs + _str('badID', _tO.id), 2);\r\n    }\r\n    _s._wD(_cs + _tO.id + ' (' + _tO.url + ')', 1);\r\n    // </d>\r\n    if (_idCheck(_tO.id, true)) {\r\n      _s._wD(_cs + _tO.id + ' exists', 1);\r\n      return _s.sounds[_tO.id];\r\n    }\r\n\r\n    function make() {\r\n      thisOptions = _loopFix(thisOptions);\r\n      _s.sounds[_tO.id] = new SMSound(_tO);\r\n      _s.soundIDs.push(_tO.id);\r\n      return _s.sounds[_tO.id];\r\n    }\r\n\r\n    if (_html5OK(_tO)) {\r\n      oSound = make();\r\n      _s._wD('Loading sound '+_tO.id+' via HTML5');\r\n      oSound._setup_html5(_tO);\r\n    } else {\r\n      if (_fV > 8 && _s.useMovieStar) {\r\n        if (_tO.isMovieStar === null) {\r\n          _tO.isMovieStar = ((_tO.serverURL || (_tO.type?_tO.type.match(_s.netStreamPattern):false)||_tO.url.match(_s.netStreamPattern))?true:false);\r\n        }\r\n        if (_tO.isMovieStar) {\r\n          _s._wD(_cs + 'using MovieStar handling');\r\n        }\r\n        if (_tO.isMovieStar) {\r\n          if (_tO.usePeakData) {\r\n            _wDS('noPeak');\r\n            _tO.usePeakData = false;\r\n          }\r\n          if (_tO.loops > 1) {\r\n            _wDS('noNSLoop');\r\n          }\r\n        }\r\n      }\r\n      _tO = _policyFix(_tO, _cs);\r\n      oSound = make();\r\n      if (_fV === 8) {\r\n        _s.o._createSound(_tO.id, _tO.onjustbeforefinishtime, _tO.loops||1, _tO.usePolicyFile);\r\n      } else {\r\n        _s.o._createSound(_tO.id, _tO.url, _tO.onjustbeforefinishtime, _tO.usePeakData, _tO.useWaveformData, _tO.useEQData, _tO.isMovieStar, (_tO.isMovieStar?_tO.bufferTime:false), _tO.loops||1, _tO.serverURL, _tO.duration||null, _tO.autoPlay, true, _tO.autoLoad, _tO.usePolicyFile);\r\n        if (!_tO.serverURL) {\r\n          // We are connected immediately\r\n          oSound.connected = true;\r\n          if (_tO.onconnect) {\r\n            _tO.onconnect.apply(oSound);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!_tO.serverURL && (_tO.autoLoad || _tO.autoPlay)) {\r\n        oSound.load(_tO); // call load for non-rtmp streams\r\n      }\r\n    }\r\n    if (!_tO.serverURL && _tO.autoPlay) { // rtmp will play in onconnect\r\n      oSound.play();\r\n    }\r\n    return oSound;\r\n  };\r\n\r\n  this.destroySound = function(sID, _bFromSound) {\r\n    // explicitly destroy a sound before normal page unload, etc.\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    var oS = _s.sounds[sID], i;\r\n    oS._iO = {}; // Disable all callbacks while the sound is being destroyed\r\n    oS.stop();\r\n    oS.unload();\r\n    for (i = 0; i < _s.soundIDs.length; i++) {\r\n      if (_s.soundIDs[i] === sID) {\r\n        _s.soundIDs.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if (!_bFromSound) {\r\n      // ignore if being called from SMSound instance\r\n      oS.destruct(true);\r\n    }\r\n    oS = null;\r\n    delete _s.sounds[sID];\r\n    return true;\r\n  };\r\n\r\n  this.load = function(sID, oOptions) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].load(oOptions);\r\n  };\r\n\r\n  this.unload = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].unload();\r\n  };\r\n\r\n  this.play = function(sID, oOptions) {\r\n    var fN = _sm+'.play(): ';\r\n    if (!_didInit || !_s.ok()) {\r\n      _complain(fN + _str(!_didInit?'notReady':'notOK'));\r\n      return false;\r\n    }\r\n    if (!_idCheck(sID)) {\r\n      if (!(oOptions instanceof Object)) {\r\n        oOptions = {\r\n          url: oOptions\r\n        }; // overloading use case: play('mySound','/path/to/some.mp3');\r\n      }\r\n      if (oOptions && oOptions.url) {\r\n        // overloading use case, create+play: .play('someID',{url:'/path/to.mp3'});\r\n        _s._wD(fN + 'attempting to create \"' + sID + '\"', 1);\r\n        oOptions.id = sID;\r\n        return _s.createSound(oOptions).play();\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    return _s.sounds[sID].play(oOptions);\r\n  };\r\n\r\n  this.start = this.play; // just for convenience\r\n\r\n  this.setPosition = function(sID, nMsecOffset) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setPosition(nMsecOffset);\r\n  };\r\n\r\n  this.stop = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    _s._wD(_sm+'.stop(' + sID + ')', 1);\r\n    return _s.sounds[sID].stop();\r\n  };\r\n\r\n  this.stopAll = function() {\r\n    var oSound;\r\n    _s._wD(_sm+'.stopAll()', 1);\r\n    for (oSound in _s.sounds) {\r\n      if (_s.sounds.hasOwnProperty(oSound)) {\r\n        _s.sounds[oSound].stop(); // apply only to sound objects\r\n      }\r\n    }\r\n  };\r\n\r\n  this.pause = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].pause();\r\n  };\r\n\r\n  this.pauseAll = function() {\r\n    var i;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].pause();\r\n    }\r\n  };\r\n\r\n  this.resume = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].resume();\r\n  };\r\n\r\n  this.resumeAll = function() {\r\n    var i;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].resume();\r\n    }\r\n  };\r\n\r\n  this.togglePause = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].togglePause();\r\n  };\r\n\r\n  this.setPan = function(sID, nPan) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setPan(nPan);\r\n  };\r\n\r\n  this.setVolume = function(sID, nVol) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setVolume(nVol);\r\n  };\r\n\r\n  this.mute = function(sID) {\r\n    var fN = _sm+'.mute(): ',\r\n    i = 0;\r\n    if (typeof sID !== 'string') {\r\n      sID = null;\r\n    }\r\n    if (!sID) {\r\n      _s._wD(fN + 'Muting all sounds');\r\n      for (i = _s.soundIDs.length; i--;) {\r\n        _s.sounds[_s.soundIDs[i]].mute();\r\n      }\r\n      _s.muted = true;\r\n    } else {\r\n      if (!_idCheck(sID)) {\r\n        return false;\r\n      }\r\n      _s._wD(fN + 'Muting \"' + sID + '\"');\r\n      return _s.sounds[sID].mute();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  this.muteAll = function() {\r\n    _s.mute();\r\n  };\r\n\r\n  this.unmute = function(sID) {\r\n    var fN = _sm+'.unmute(): ', i;\r\n    if (typeof sID !== 'string') {\r\n      sID = null;\r\n    }\r\n    if (!sID) {\r\n      _s._wD(fN + 'Unmuting all sounds');\r\n      for (i = _s.soundIDs.length; i--;) {\r\n        _s.sounds[_s.soundIDs[i]].unmute();\r\n      }\r\n      _s.muted = false;\r\n    } else {\r\n      if (!_idCheck(sID)) {\r\n        return false;\r\n      }\r\n      _s._wD(fN + 'Unmuting \"' + sID + '\"');\r\n      return _s.sounds[sID].unmute();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  this.unmuteAll = function() {\r\n    _s.unmute();\r\n  };\r\n\r\n  this.toggleMute = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].toggleMute();\r\n  };\r\n\r\n  this.getMemoryUse = function() {\r\n    // flash-only\r\n    var ram = 0;\r\n    if (_s.o && _fV !== 8) {\r\n      ram = parseInt(_s.o._getMemoryUse(), 10);\r\n    }\r\n    return ram;\r\n  };\r\n\r\n  this.disable = function(bNoDisable) {\r\n    // destroy all functions\r\n    var i;\r\n    if (typeof bNoDisable === 'undefined') {\r\n      bNoDisable = false;\r\n    }\r\n    if (_disabled) {\r\n      return false;\r\n    }\r\n    _disabled = true;\r\n    _wDS('shutdown', 1);\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _disableObject(_s.sounds[_s.soundIDs[i]]);\r\n    }\r\n    _initComplete(bNoDisable); // fire \"complete\", despite fail\r\n    _event.remove(_win, 'load', _initUserOnload);\r\n    return true;\r\n  };\r\n\r\n  this.canPlayMIME = function(sMIME) {\r\n    var result;\r\n    if (_s.hasHTML5) {\r\n      result = _html5CanPlay({type:sMIME});\r\n    }\r\n    if (!_needsFlash || result) {\r\n      // no flash, or OK\r\n      return result;\r\n    } else {\r\n      return (sMIME?(sMIME.match(_s.mimePattern)?true:false):null);\r\n    }\r\n  };\r\n\r\n  this.canPlayURL = function(sURL) {\r\n    var result;\r\n    if (_s.hasHTML5) {\r\n      result = _html5CanPlay({url: sURL});\r\n    }\r\n    if (!_needsFlash || result) {\r\n      // no flash, or OK\r\n      return result;\r\n    } else {\r\n      return (sURL?(sURL.match(_s.filePattern)?true:false):null);\r\n    }\r\n  };\r\n\r\n  this.canPlayLink = function(oLink) {\r\n    if (typeof oLink.type !== 'undefined' && oLink.type) {\r\n      if (_s.canPlayMIME(oLink.type)) {\r\n        return true;\r\n      }\r\n    }\r\n    return _s.canPlayURL(oLink.href);\r\n  };\r\n\r\n  this.getSoundById = function(sID, suppressDebug) {\r\n    if (!sID) {\r\n      throw new Error(_sm+'.getSoundById(): sID is null/undefined');\r\n    }\r\n    var result = _s.sounds[sID];\r\n    if (!result && !suppressDebug) {\r\n      _s._wD('\"' + sID + '\" is an invalid sound ID.', 2);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  this.onready = function(oMethod, oScope) {\r\n    var sType = 'onready';\r\n    if (oMethod && oMethod instanceof Function) {\r\n      if (_didInit) {\r\n        _s._wD(_str('queue', sType));\r\n      }\r\n      if (!oScope) {\r\n        oScope = _win;\r\n      }\r\n      _addOnEvent(sType, oMethod, oScope);\r\n      _processOnEvents();\r\n      return true;\r\n    } else {\r\n      throw _str('needFunction', sType);\r\n    }\r\n  };\r\n\r\n  this.ontimeout = function(oMethod, oScope) {\r\n    var sType = 'ontimeout';\r\n    if (oMethod && oMethod instanceof Function) {\r\n      if (_didInit) {\r\n        _s._wD(_str('queue', sType));\r\n      }\r\n      if (!oScope) {\r\n        oScope = _win;\r\n      }\r\n      _addOnEvent(sType, oMethod, oScope);\r\n      _processOnEvents({type:sType});\r\n      return true;\r\n    } else {\r\n      throw _str('needFunction', sType);\r\n    }\r\n  };\r\n\r\n  this._writeDebug = function(sText, sType, bTimestamp) {\r\n    // pseudo-private console.log()-style output\r\n    // <d>\r\n    var sDID = 'soundmanager-debug', o, oItem, sMethod;\r\n    if (!_s.debugMode) {\r\n      return false;\r\n    }\r\n    if (typeof bTimestamp !== 'undefined' && bTimestamp) {\r\n      sText = sText + ' | ' + new Date().getTime();\r\n    }\r\n    if (_hasConsole && _s.useConsole) {\r\n      sMethod = _debugLevels[sType];\r\n      if (typeof console[sMethod] !== 'undefined') {\r\n        console[sMethod](sText);\r\n      } else {\r\n        console.log(sText);\r\n      }\r\n      if (_s.useConsoleOnly) {\r\n        return true;\r\n      }\r\n    }\r\n    try {\r\n      o = _id(sDID);\r\n      if (!o) {\r\n        return false;\r\n      }\r\n      oItem = _doc.createElement('div');\r\n      if (++_wdCount % 2 === 0) {\r\n        oItem.className = 'sm2-alt';\r\n      }\r\n      if (typeof sType === 'undefined') {\r\n        sType = 0;\r\n      } else {\r\n        sType = parseInt(sType, 10);\r\n      }\r\n      oItem.appendChild(_doc.createTextNode(sText));\r\n      if (sType) {\r\n        if (sType >= 2) {\r\n          oItem.style.fontWeight = 'bold';\r\n        }\r\n        if (sType === 3) {\r\n          oItem.style.color = '#ff3333';\r\n        }\r\n      }\r\n      // o.appendChild(oItem); // top-to-bottom\r\n      o.insertBefore(oItem, o.firstChild); // bottom-to-top\r\n    } catch(e) {\r\n      // oh well\r\n    }\r\n    o = null;\r\n    // </d>\r\n    return true;\r\n  };\r\n  this._wD = this._writeDebug; // alias\r\n\r\n  this._debug = function() {\r\n    // <d>\r\n    var i, j;\r\n    _wDS('currentObj', 1);\r\n    for (i = 0, j = _s.soundIDs.length; i < j; i++) {\r\n      _s.sounds[_s.soundIDs[i]]._debug();\r\n    }\r\n    // </d>\r\n  };\r\n\r\n  this.reboot = function() {\r\n    // attempt to reset and init SM2\r\n    _s._wD(_sm+'.reboot()');\r\n    if (_s.soundIDs.length) {\r\n      _s._wD('Destroying ' + _s.soundIDs.length + ' SMSound objects...');\r\n    }\r\n    var i, j;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].destruct();\r\n    }\r\n    // trash ze flash\r\n    try {\r\n      if (_isIE) {\r\n        _oRemovedHTML = _s.o.innerHTML;\r\n      }\r\n      _oRemoved = _s.o.parentNode.removeChild(_s.o);\r\n      _s._wD('Flash movie removed.');\r\n    } catch(e) {\r\n      // uh-oh.\r\n      _wDS('badRemove', 2);\r\n    }\r\n    // actually, force recreate of movie.\r\n    _oRemovedHTML = _oRemoved = _needsFlash = null;\r\n    _s.enabled = _didDCLoaded = _didInit = _waitingForEI = _initPending = _didAppend = _appendSuccess = _disabled = _s.swfLoaded = false;\r\n    _s.soundIDs = _s.sounds = [];\r\n    _s.o = null;\r\n    for (i in _on_queue) {\r\n      if (_on_queue.hasOwnProperty(i)) {\r\n        for (j = _on_queue[i].length; j--;) {\r\n          _on_queue[i][j].fired = false;\r\n        }\r\n      }\r\n    }\r\n    _s._wD(_sm + ': Rebooting...');\r\n    _win.setTimeout(_s.beginDelayedInit, 20);\r\n  };\r\n\r\n  this.getMoviePercent = function() {\r\n    return (_s.o && typeof _s.o.PercentLoaded !== 'undefined' ? _s.o.PercentLoaded() : null);\r\n  };\r\n\r\n  this.beginDelayedInit = function() {\r\n    _windowLoaded = true;\r\n    _dcLoaded();\r\n    setTimeout(function() {\r\n      if (_initPending) {\r\n        return false;\r\n      }\r\n      _createMovie();\r\n      _initMovie();\r\n      _initPending = true;\r\n      return true;\r\n    }, 20);\r\n    _delayWaitForEI();\r\n  };\r\n\r\n  this.destruct = function() {\r\n    _s._wD(_sm+'.destruct()');\r\n    _s.disable(true);\r\n  };\r\n\r\n  /*\r\n   * internal HTML5 event handling\r\n  */\r\n\r\n  function _html5_event(oFn) {\r\n    // wrap html5 event handlers so we don't call them on destroyed sounds\r\n    return function(e) {\r\n      if (!this._t || !this._t._a) {\r\n        if (this._t && this._t.sID) {\r\n          _s._wD(_h5+'ignoring '+e.type+': '+this._t.sID);\r\n        } else {\r\n          _s._wD(_h5+'ignoring '+e.type);\r\n        }\r\n        return null;\r\n      } else {\r\n        return oFn.call(this, e);\r\n      }\r\n    };\r\n  }\r\n\r\n  _html5_events = {\r\n\r\n    // HTML5 event-name-to-handler map\r\n    abort: _html5_event(function(e) {\r\n      _s._wD(_h5+'abort: '+this._t.sID);\r\n    }),\r\n\r\n    // enough has loaded to play\r\n    canplay: _html5_event(function(e) {\r\n      if (this._t._html5_canplay) {\r\n        // this event has already fired. ignore.\r\n        return true;\r\n      }\r\n      this._t._html5_canplay = true;\r\n      _s._wD(_h5+'canplay: '+this._t.sID+', '+this._t.url);\r\n      this._t._onbufferchange(0);\r\n      var position1K = (!isNaN(this._t.position)?this._t.position/1000:null);\r\n      // set the position if position was set before the sound loaded\r\n      if (this._t.position && this.currentTime !== position1K) {\r\n        _s._wD(_h5+'canplay: setting position to '+position1K);\r\n        try {\r\n          this.currentTime = position1K;\r\n        } catch(ee) {\r\n          _s._wD(_h5+'setting position failed: '+ee.message, 2);\r\n        }\r\n      }\r\n    }),\r\n\r\n    load: _html5_event(function(e) {\r\n      if (!this._t.loaded) {\r\n        this._t._onbufferchange(0);\r\n        // should be 1, and the same\r\n        this._t._whileloading(this._t.bytesTotal, this._t.bytesTotal, this._t._get_html5_duration());\r\n        this._t._onload(true);\r\n      }\r\n    }),\r\n\r\n    emptied: _html5_event(function(e) {\r\n      _s._wD(_h5+'emptied: '+this._t.sID);\r\n    }),\r\n\r\n    ended: _html5_event(function(e) {\r\n      _s._wD(_h5+'ended: '+this._t.sID);\r\n      this._t._onfinish();\r\n    }),\r\n\r\n    error: _html5_event(function(e) {\r\n      _s._wD(_h5+'error: '+this.error.code);\r\n      // call load with error state?\r\n      this._t._onload(false);\r\n    }),\r\n\r\n    loadeddata: _html5_event(function(e) {\r\n      var t = this._t,\r\n          bytesTotal = t.bytesTotal || 1; // at least 1 byte, so math works\r\n      _s._wD(_h5+'loadeddata: '+this._t.sID);\r\n      if (!t._loaded && !_isSafari) { // safari seems to nicely report progress events, eventually totalling 100%\r\n        t.duration = t._get_html5_duration();\r\n        // fire whileloading() with 100% values\r\n        t._whileloading(bytesTotal, bytesTotal, t._get_html5_duration());\r\n        t._onload(true);\r\n      }\r\n    }),\r\n\r\n    loadedmetadata: _html5_event(function(e) {\r\n      _s._wD(_h5+'loadedmetadata: '+this._t.sID);\r\n    }),\r\n\r\n    loadstart: _html5_event(function(e) {\r\n      _s._wD(_h5+'loadstart: '+this._t.sID);\r\n      // assume buffering at first\r\n      this._t._onbufferchange(1);\r\n    }),\r\n\r\n    play: _html5_event(function(e) {\r\n      _s._wD(_h5+'play: '+this._t.sID+', '+this._t.url);\r\n      // once play starts, no buffering\r\n      this._t._onbufferchange(0);\r\n    }),\r\n\r\n    // TODO: verify if this is actually implemented anywhere yet.\r\n    playing: _html5_event(function(e) {\r\n      _s._wD(_h5+'playing: '+this._t.sID+', '+this._t.url);\r\n      // once play starts, no buffering\r\n      this._t._onbufferchange(0);\r\n    }),\r\n\r\n    progress: _html5_event(function(e) {\r\n\r\n      if (this._t.loaded) {\r\n        return false;\r\n      }\r\n\r\n      var i, j, str, buffered = 0,\r\n          isProgress = (e.type === 'progress'),\r\n          ranges = e.target.buffered,\r\n          loaded = (e.loaded||0), // firefox 3.6 implements e.loaded/total (bytes)\r\n          total = (e.total||1);\r\n\r\n      if (ranges && ranges.length) {\r\n\r\n        // if loaded is 0, try TimeRanges implementation as % of load\r\n        // https://developer.mozilla.org/en/DOM/TimeRanges\r\n        for (i=ranges.length; i--;) {\r\n          buffered = (ranges.end(i) - ranges.start(i));\r\n        }\r\n\r\n        // linear case, buffer sum; does not account for seeking and HTTP partials / byte ranges\r\n        loaded = buffered/e.target.duration;\r\n\r\n        // <d>\r\n        if (isProgress && ranges.length > 1) {\r\n          str = [];\r\n          j = ranges.length;\r\n          for (i=0; i<j; i++) {\r\n            str.push(e.target.buffered.start(i) +'-'+ e.target.buffered.end(i));\r\n          }\r\n          _s._wD(_h5+'progress: timeRanges: '+str.join(', '));\r\n        }\r\n        // </d>\r\n\r\n        if (isProgress && !isNaN(loaded)) {\r\n          _s._wD(_h5+'progress: '+this._t.sID+': ' + Math.floor(loaded*100)+'% loaded');\r\n        }\r\n\r\n      }\r\n\r\n      if (!isNaN(loaded)) {\r\n\r\n        this._t._onbufferchange(0); // if progress, likely not buffering\r\n        this._t._whileloading(loaded, total, this._t._get_html5_duration());\r\n\r\n        if (loaded && total && loaded === total) {\r\n          // in case \"onload\" doesn't fire (eg. gecko 1.9.2)\r\n          _html5_events.load.call(this, e);\r\n        }\r\n\r\n      }\r\n\r\n    }),\r\n\r\n    ratechange: _html5_event(function(e) {\r\n      _s._wD(_h5+'ratechange: '+this._t.sID);\r\n    }),\r\n\r\n    suspend: _html5_event(function(e) {\r\n      // download paused/stopped, may have finished (eg. onload)\r\n      _s._wD(_h5+'suspend: '+this._t.sID);\r\n      _html5_events.progress.call(this, e);\r\n    }),\r\n\r\n    stalled: _html5_event(function(e) {\r\n      _s._wD(_h5+'stalled: '+this._t.sID);\r\n    }),\r\n\r\n    timeupdate: _html5_event(function(e) {\r\n      this._t._onTimer();\r\n    }),\r\n\r\n    waiting: _html5_event(function(e) { // see also: seeking\r\n      _s._wD(_h5+'waiting: '+this._t.sID);\r\n      // playback faster than download rate, etc.\r\n      this._t._onbufferchange(1);\r\n    })\r\n\r\n  };\r\n\r\n  /*\r\n   * SMSound() (sound object) instance\r\n  */\r\n\r\n  SMSound = function(oOptions) {\r\n\r\n    var _t = this, _resetProperties, _stop_html5_timer, _start_html5_timer;\r\n    this.sID = oOptions.id;\r\n    this.url = oOptions.url;\r\n    this.options = _mixin(oOptions);\r\n    this.instanceOptions = this.options; // per-play-instance-specific options\r\n    this._iO = this.instanceOptions; // short alias\r\n    // assign property defaults\r\n    this.pan = this.options.pan;\r\n    this.volume = this.options.volume;\r\n    this._lastURL = null;\r\n    this.isHTML5 = false;\r\n    this._a = null;\r\n\r\n    // --- public methods ---\r\n\r\n    this.id3 = {};\r\n\r\n    this._debug = function() {\r\n      // <d>\r\n      // pseudo-private console.log()-style output\r\n      if (_s.debugMode) {\r\n        var stuff = null, msg = [], sF, sfBracket, maxLength = 64;\r\n        for (stuff in _t.options) {\r\n          if (_t.options[stuff] !== null) {\r\n            if (_t.options[stuff] instanceof Function) {\r\n              // handle functions specially\r\n              sF = _t.options[stuff].toString();\r\n              sF = sF.replace(/\\s\\s+/g, ' '); // normalize spaces\r\n              sfBracket = sF.indexOf('{');\r\n              msg.push(' ' + stuff + ': {' + sF.substr(sfBracket + 1, (Math.min(Math.max(sF.indexOf('\\n') - 1, maxLength), maxLength))).replace(/\\n/g, '') + '... }');\r\n            } else {\r\n              msg.push(' ' + stuff + ': ' + _t.options[stuff]);\r\n            }\r\n          }\r\n        }\r\n        _s._wD('SMSound() merged options: {\\n' + msg.join(', \\n') + '\\n}');\r\n      }\r\n      // </d>\r\n    };\r\n\r\n    // <d>\r\n    this._debug();\r\n    // </d>\r\n\r\n    this.load = function(oOptions) {\r\n      var oS = null;\r\n      if (typeof oOptions !== 'undefined') {\r\n        _t._iO = _mixin(oOptions, _t.options);\r\n        _t.instanceOptions = _t._iO;\r\n      } else {\r\n        oOptions = _t.options;\r\n        _t._iO = oOptions;\r\n        _t.instanceOptions = _t._iO;\r\n        if (_t._lastURL && _t._lastURL !== _t.url) {\r\n          _wDS('manURL');\r\n          _t._iO.url = _t.url;\r\n          _t.url = null;\r\n        }\r\n      }\r\n      if (!_t._iO.url) {\r\n        _t._iO.url = _t.url;\r\n      }\r\n      _s._wD('SMSound.load(): ' + _t._iO.url, 1);\r\n      if (_t._iO.url === _t.url && _t.readyState !== 0 && _t.readyState !== 2) {\r\n        _wDS('onURL', 1);\r\n        return _t;\r\n      }\r\n      _t._lastURL = _t.url;\r\n      _t.loaded = false;\r\n      _t.readyState = 1;\r\n      _t.playState = 0;\r\n      if (_html5OK(_t._iO)) {\r\n        oS = _t._setup_html5(_t._iO);\r\n        if (!oS._called_load) {\r\n          _s._wD(_h5+'load: '+_t.sID);\r\n          _t._html5_canplay = false;\r\n          oS.load();\r\n          oS._called_load = true;\r\n          if (_t._iO.autoPlay) {\r\n            _t.play();\r\n          }\r\n        } else {\r\n          _s._wD(_h5+'ignoring request to load again: '+_t.sID);\r\n        }\r\n      } else {\r\n        try {\r\n          _t.isHTML5 = false;\r\n          _t._iO = _policyFix(_loopFix(_t._iO));\r\n          if (_fV === 8) {\r\n            _s.o._load(_t.sID, _t._iO.url, _t._iO.stream, _t._iO.autoPlay, (_t._iO.whileloading?1:0), _t._iO.loops||1, _t._iO.usePolicyFile);\r\n          } else {\r\n            _s.o._load(_t.sID, _t._iO.url, _t._iO.stream?true:false, _t._iO.autoPlay?true:false, _t._iO.loops||1, _t._iO.autoLoad?true:false, _t._iO.usePolicyFile);\r\n          }\r\n        } catch(e) {\r\n          _wDS('smError', 2);\r\n          _debugTS('onload', false);\r\n          _catchError({type:'SMSOUND_LOAD_JS_EXCEPTION', fatal:true});\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.unload = function() {\r\n      // Flash 8/AS2 can't \"close\" a stream - fake it by loading an empty MP3\r\n      // Flash 9/AS3: Close stream, preventing further load\r\n      if (_t.readyState !== 0) {\r\n        _s._wD('SMSound.unload(): \"' + _t.sID + '\"');\r\n        if (!_t.isHTML5) {\r\n          if (_fV === 8) {\r\n            _s.o._unload(_t.sID, _s.nullURL);\r\n          } else {\r\n            _s.o._unload(_t.sID);\r\n          }\r\n        } else {\r\n          _stop_html5_timer();\r\n          if (_t._a) {\r\n            // abort()-style method here, stop loading? (doesn't exist?)\r\n            _t._a.pause();\r\n            _t._a.src = ''; // https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media\r\n          }\r\n        }\r\n        // reset load/status flags\r\n        _resetProperties();\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.destruct = function(_bFromSM) {\r\n      _s._wD('SMSound.destruct(): \"' + _t.sID + '\"');\r\n      if (!_t.isHTML5) {\r\n        // kill sound within Flash\r\n        // Disable the onfailure handler\r\n        _t._iO.onfailure = null;\r\n        _s.o._destroySound(_t.sID);\r\n      } else {\r\n        _stop_html5_timer();\r\n        if (_t._a) {\r\n          // abort()-style method here, stop loading? (doesn't exist?)\r\n          _t._a.pause();\r\n          _t._a.src = ''; // https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media\r\n          if (!_useGlobalHTML5Audio) {\r\n            _t._remove_html5_events();\r\n          }\r\n          _t._a._t = null; // break potential circular reference\r\n          _t._a = null;\r\n        }\r\n      }\r\n      if (!_bFromSM) {\r\n        _s.destroySound(_t.sID, true); // ensure deletion from controller\r\n      }\r\n    };\r\n\r\n    this.play = function(oOptions, _updatePlayState) {\r\n      var fN = 'SMSound.play(): ', allowMulti, a;\r\n      _updatePlayState = _updatePlayState === undefined ? true : _updatePlayState; // default to true\r\n      if (!oOptions) {\r\n        oOptions = {};\r\n      }\r\n      _t._iO = _mixin(oOptions, _t._iO);\r\n      _t._iO = _mixin(_t._iO, _t.options);\r\n      _t.instanceOptions = _t._iO;\r\n      if (_t._iO.serverURL && !_t.connected) {\r\n        if (!_t.getAutoPlay()) {\r\n          _s._wD(fN+' Netstream not connected yet - setting autoPlay');\r\n          _t.setAutoPlay(true);\r\n        }\r\n        return _t; // play will be called in _onconnect()\r\n      }\r\n      if (_html5OK(_t._iO)) {\r\n        _t._setup_html5(_t._iO);\r\n        _start_html5_timer();\r\n      }\r\n      if (_t.playState === 1 && !_t.paused) {\r\n        allowMulti = _t._iO.multiShot;\r\n        if (!allowMulti) {\r\n          _s._wD(fN + '\"' + _t.sID + '\" already playing (one-shot)', 1);\r\n          return _t;\r\n        } else {\r\n          _s._wD(fN + '\"' + _t.sID + '\" already playing (multi-shot)', 1);\r\n        }\r\n      }\r\n      if (!_t.loaded) {\r\n        if (_t.readyState === 0) {\r\n          _s._wD(fN + 'Attempting to load \"' + _t.sID + '\"', 1);\r\n          // try to get this sound playing ASAP\r\n          if (!_t.isHTML5) {\r\n            _t._iO.autoPlay = true; // assign directly because setAutoPlay() increments the instanceCount\r\n          }\r\n          _t.load(_t._iO);\r\n        } else if (_t.readyState === 2) {\r\n          _s._wD(fN + 'Could not load \"' + _t.sID + '\" - exiting', 2);\r\n          return _t;\r\n        } else {\r\n          _s._wD(fN + '\"' + _t.sID + '\" is loading - attempting to play..', 1);\r\n        }\r\n      } else {\r\n        _s._wD(fN + '\"' + _t.sID + '\"');\r\n      }\r\n      if (!_t.isHTML5 && _fV === 9 && _t.position > 0 && _t.position === _t.duration) {\r\n        // flash 9 needs a position reset if play() is called while at the end of a sound.\r\n        _s._wD(fN + '\"' + _t.sID + '\": Sound at end, resetting to position:0');\r\n        _t._iO.position = 0;\r\n      }\r\n      /*\r\n       * Streams will pause when their buffer is full if they are being loaded.\r\n       * In this case paused is true, but the song hasn't started playing yet.\r\n       * If we just call resume() the onplay() callback will never be called.\r\n       * So only call resume() if the position is > 0.\r\n       * Another reason is because options like volume won't have been applied yet.\r\n      */\r\n      if (_t.paused && _t.position && _t.position > 0) { // https://gist.github.com/37b17df75cc4d7a90bf6\r\n        _s._wD(fN + '\"' + _t.sID + '\" is resuming from paused state',1);\r\n        _t.resume();\r\n      } else {\r\n        _s._wD(fN+'\"'+ _t.sID+'\" is starting to play');\r\n        _t.playState = 1;\r\n        _t.paused = false;\r\n        if (!_t.instanceCount || _t._iO.multiShotEvents || (!_t.isHTML5 && _fV > 8 && !_t.getAutoPlay())) {\r\n          _t.instanceCount++;\r\n        }\r\n        _t.position = (typeof _t._iO.position !== 'undefined' && !isNaN(_t._iO.position)?_t._iO.position:0);\r\n        if (!_t.isHTML5) {\r\n          _t._iO = _policyFix(_loopFix(_t._iO));\r\n        }\r\n        if (_t._iO.onplay && _updatePlayState) {\r\n          _t._iO.onplay.apply(_t);\r\n          _t._onplay_called = true;\r\n        }\r\n        _t.setVolume(_t._iO.volume, true);\r\n        _t.setPan(_t._iO.pan, true);\r\n        if (!_t.isHTML5) {\r\n          _s.o._start(_t.sID, _t._iO.loops || 1, (_fV === 9?_t._iO.position:_t._iO.position / 1000));\r\n        } else {\r\n          _start_html5_timer();\r\n          a = _t._setup_html5();\r\n          _t.setPosition(_t._iO.position);\r\n          a.play();\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.start = this.play; // just for convenience\r\n\r\n    this.stop = function(bAll) {\r\n      if (_t.playState === 1) {\r\n        _t._onbufferchange(0);\r\n        _t.resetOnPosition(0);\r\n        if (!_t.isHTML5) {\r\n          _t.playState = 0;\r\n        }\r\n        _t.paused = false;\r\n        if (_t._iO.onstop) {\r\n          _t._iO.onstop.apply(_t);\r\n        }\r\n        if (!_t.isHTML5) {\r\n          _s.o._stop(_t.sID, bAll);\r\n          // hack for netStream: just unload\r\n          if (_t._iO.serverURL) {\r\n            _t.unload();\r\n          }\r\n        } else {\r\n          if (_t._a) {\r\n            _t.setPosition(0); // act like Flash, though\r\n            _t._a.pause(); // html5 has no stop()\r\n            _t.playState = 0;\r\n            _t._onTimer(); // and update UI\r\n            _stop_html5_timer();\r\n            _t.unload();\r\n          }\r\n        }\r\n        _t.instanceCount = 0;\r\n        _t._iO = {};\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setAutoPlay = function(autoPlay) {\r\n      _s._wD('sound '+_t.sID+' turned autoplay ' + (autoPlay ? 'on' : 'off'));\r\n      _t._iO.autoPlay = autoPlay;\r\n      if (!_t.isHTML5) {\r\n        _s.o._setAutoPlay(_t.sID, autoPlay);\r\n        if (autoPlay) {\r\n          // only increment the instanceCount if the sound isn't loaded (TODO: verify RTMP)\r\n          if (!_t.instanceCount && _t.readyState === 1) {\r\n            _t.instanceCount++;\r\n            _s._wD('sound '+_t.sID+' incremented instance count to '+_t.instanceCount);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.getAutoPlay = function() {\r\n      return _t._iO.autoPlay;\r\n    };\r\n\r\n    this.setPosition = function(nMsecOffset) {\r\n      if (nMsecOffset === undefined) {\r\n        nMsecOffset = 0;\r\n      }\r\n      // Use the duration from the instance options, if we don't have a track duration yet.\r\n      var original_pos, position, position1K,\r\n          offset = (_t.isHTML5 ? Math.max(nMsecOffset,0) : Math.min(_t.duration || _t._iO.duration, Math.max(nMsecOffset, 0))); // position >= 0 and <= current available (loaded) duration\r\n      original_pos = _t.position;\r\n      _t.position = offset;\r\n      position1K = _t.position/1000;\r\n      _t.resetOnPosition(_t.position);\r\n      _t._iO.position = offset;\r\n      if (!_t.isHTML5) {\r\n        position = (_fV === 9 ? _t.position : position1K);\r\n        if (_t.readyState && _t.readyState !== 2) {\r\n          _s.o._setPosition(_t.sID, position, (_t.paused || !_t.playState)); // if paused or not playing, will not resume (by playing)\r\n        }\r\n      } else if (_t._a) {\r\n        // Set the position in the canplay handler if the sound is not ready yet\r\n        if (_t._html5_canplay) {\r\n          if (_t._a.currentTime !== position1K) {\r\n            /*\r\n             * DOM/JS errors/exceptions to watch out for:\r\n             * if seek is beyond (loaded?) position, \"DOM exception 11\"\r\n             * \"INDEX_SIZE_ERR\": DOM exception 1\r\n            */\r\n            _s._wD('setPosition('+position1K+'): setting position');\r\n            try {\r\n              _t._a.currentTime = position1K;\r\n              if (_t.playState === 0 || _t.paused) {\r\n                // allow seek without auto-play/resume\r\n                _t._a.pause();\r\n              }\r\n            } catch(e) {\r\n              _s._wD('setPosition('+position1K+'): setting position failed: '+e.message, 2);\r\n            }\r\n          }\r\n        } else {\r\n          _s._wD('setPosition('+position1K+'): delaying, sound not ready');\r\n        }\r\n      }\r\n      if (_t.isHTML5) {\r\n        if (_t.paused) { // if paused, refresh UI right away\r\n          _t._onTimer(true); // force update\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.pause = function(bCallFlash) {\r\n      if (_t.paused || (_t.playState === 0 && _t.readyState !== 1)) {\r\n        return _t;\r\n      }\r\n      _s._wD('SMSound.pause()');\r\n      _t.paused = true;\r\n      if (!_t.isHTML5) {\r\n        if (bCallFlash || bCallFlash === undefined) {\r\n          _s.o._pause(_t.sID);\r\n        }\r\n      } else {\r\n        _t._setup_html5().pause();\r\n        _stop_html5_timer();\r\n      }\r\n      if (_t._iO.onpause) {\r\n        _t._iO.onpause.apply(_t);\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    /*\r\n     * When auto-loaded streams pause on buffer full they have a playState of 0.\r\n     * We need to make sure that the playState is set to 1 when these streams \"resume\".\r\n     * When a paused stream is resumed, we need to trigger the onplay() callback if it\r\n     * hasn't been called already. In this case since the sound is being played for the\r\n     * first time, I think it's more appropriate to call onplay() rather than onresume().\r\n    */\r\n    this.resume = function() {\r\n      if (!_t.paused) {\r\n        return _t;\r\n      }\r\n      _s._wD('SMSound.resume()');\r\n      _t.paused = false;\r\n      _t.playState = 1;\r\n      if (!_t.isHTML5) {\r\n        if (_t._iO.isMovieStar) {\r\n          // Bizarre Webkit bug (Chrome reported via 8tracks.com dudes): AAC content paused for 30+ seconds(?) will not resume without a reposition.\r\n          _t.setPosition(_t.position);\r\n        }\r\n        _s.o._pause(_t.sID); // flash method is toggle-based (pause/resume)\r\n      } else {\r\n        _t._setup_html5().play();\r\n        _start_html5_timer();\r\n      }\r\n      if (!_t._onplay_called && _t._iO.onplay) {\r\n        _t._iO.onplay.apply(_t);\r\n        _t._onplay_called = true;\r\n      } else if (_t._iO.onresume) {\r\n        _t._iO.onresume.apply(_t);\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.togglePause = function() {\r\n      _s._wD('SMSound.togglePause()');\r\n      if (_t.playState === 0) {\r\n        _t.play({\r\n          position: (_fV === 9 && !_t.isHTML5 ? _t.position : _t.position / 1000)\r\n        });\r\n        return _t;\r\n      }\r\n      if (_t.paused) {\r\n        _t.resume();\r\n      } else {\r\n        _t.pause();\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setPan = function(nPan, bInstanceOnly) {\r\n      if (typeof nPan === 'undefined') {\r\n        nPan = 0;\r\n      }\r\n      if (typeof bInstanceOnly === 'undefined') {\r\n        bInstanceOnly = false;\r\n      }\r\n      if (!_t.isHTML5) {\r\n        _s.o._setPan(_t.sID, nPan);\r\n      } // else { no HTML5 pan? }\r\n      _t._iO.pan = nPan;\r\n      if (!bInstanceOnly) {\r\n        _t.pan = nPan;\r\n        _t.options.pan = nPan;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setVolume = function(nVol, bInstanceOnly) {\r\n      if (typeof nVol === 'undefined') {\r\n        nVol = 100;\r\n      }\r\n      if (typeof bInstanceOnly === 'undefined') {\r\n        bInstanceOnly = false;\r\n      }\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, (_s.muted && !_t.muted) || _t.muted?0:nVol);\r\n      } else if (_t._a) {\r\n        _t._a.volume = Math.max(0, Math.min(1, nVol/100)); // valid range: 0-1\r\n      }\r\n      _t._iO.volume = nVol;\r\n      if (!bInstanceOnly) {\r\n        _t.volume = nVol;\r\n        _t.options.volume = nVol;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.mute = function() {\r\n      _t.muted = true;\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, 0);\r\n      } else if (_t._a) {\r\n        _t._a.muted = true;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.unmute = function() {\r\n      _t.muted = false;\r\n      var hasIO = typeof _t._iO.volume !== 'undefined';\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, hasIO?_t._iO.volume:_t.options.volume);\r\n      } else if (_t._a) {\r\n        _t._a.muted = false;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.toggleMute = function() {\r\n      return (_t.muted?_t.unmute():_t.mute());\r\n    };\r\n\r\n    this.onposition = function(nPosition, oMethod, oScope) {\r\n      // TODO: allow for ranges, too? eg. (nPosition instanceof Array)\r\n      _t._onPositionItems.push({\r\n        position: nPosition,\r\n        method: oMethod,\r\n        scope: (typeof oScope !== 'undefined'?oScope:_t),\r\n        fired: false\r\n      });\r\n      return _t;\r\n    };\r\n\r\n    this.processOnPosition = function() {\r\n      var i, item, j = _t._onPositionItems.length;\r\n      if (!j || !_t.playState || _t._onPositionFired >= j) {\r\n        return false;\r\n      }\r\n      for (i=j; i--;) {\r\n        item = _t._onPositionItems[i];\r\n        if (!item.fired && _t.position >= item.position) {\r\n          item.method.apply(item.scope,[item.position]);\r\n          item.fired = true;\r\n          _s._onPositionFired++;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this.resetOnPosition = function(nPosition) {\r\n      // reset \"fired\" for items interested in this position\r\n      var i, item, j = _t._onPositionItems.length;\r\n      if (!j) {\r\n        return false;\r\n      }\r\n      for (i=j; i--;) {\r\n        item = _t._onPositionItems[i];\r\n        if (item.fired && nPosition <= item.position) {\r\n          item.fired = false;\r\n          _s._onPositionFired--;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /*\r\n     * private internals\r\n    */\r\n\r\n    _start_html5_timer = function() {\r\n      if (_t.isHTML5) {\r\n        _startTimer(_t);\r\n      }\r\n    };\r\n\r\n    _stop_html5_timer = function() {\r\n      if (_t.isHTML5) {\r\n        _stopTimer(_t);\r\n      }\r\n    };\r\n\r\n    _resetProperties = function() {\r\n      _t._onPositionItems = [];\r\n      _t._onPositionFired = 0;\r\n      _t._hasTimer = null;\r\n      _t._onplay_called = false;\r\n      _t._a = null;\r\n      _t._html5_canplay = false;\r\n      _t.bytesLoaded = null;\r\n      _t.bytesTotal = null;\r\n      _t.position = null;\r\n      _t.duration = (_t._iO && _t._iO.duration?_t._iO.duration:null);\r\n      _t.durationEstimate = null;\r\n      _t.failures = 0;\r\n      _t.loaded = false;\r\n      _t.playState = 0;\r\n      _t.paused = false;\r\n      _t.readyState = 0; // 0 = uninitialised, 1 = loading, 2 = failed/error, 3 = loaded/success\r\n      _t.muted = false;\r\n      _t.didBeforeFinish = false;\r\n      _t.didJustBeforeFinish = false;\r\n      _t.isBuffering = false;\r\n      _t.instanceOptions = {};\r\n      _t.instanceCount = 0;\r\n      _t.peakData = {\r\n        left: 0,\r\n        right: 0\r\n      };\r\n      _t.waveformData = {\r\n        left: [],\r\n        right: []\r\n      };\r\n      _t.eqData = []; // legacy: 1D array\r\n      _t.eqData.left = [];\r\n      _t.eqData.right = [];\r\n    };\r\n\r\n    _resetProperties();\r\n\r\n    /*\r\n     * pseudo-private SMSound internals\r\n    */\r\n\r\n    this._onTimer = function(bForce) {\r\n      // HTML5-only _whileplaying() etc.\r\n      var time, x = {};\r\n      if (_t._hasTimer || bForce) {\r\n        if (_t._a && (bForce || ((_t.playState > 0 || _t.readyState === 1) && !_t.paused))) { // TODO: May not need to track readyState (1 = loading)\r\n          _t.duration = _t._get_html5_duration();\r\n          _t.durationEstimate = _t.duration;\r\n          time = _t._a.currentTime?_t._a.currentTime*1000:0;\r\n          _t._whileplaying(time,x,x,x,x);\r\n          return true;\r\n        } else {\r\n         _s._wD('_onTimer: Warn for \"'+_t.sID+'\": '+(!_t._a?'Could not find element. ':'')+(_t.playState === 0?'playState bad, 0?':'playState = '+_t.playState+', OK'));\r\n          return false;\r\n        }\r\n      }\r\n    };\r\n\r\n    this._get_html5_duration = function() {\r\n      var d = (_t._a ? _t._a.duration*1000 : (_t._iO ? _t._iO.duration : undefined)),\r\n          result = (d && !isNaN(d) && d !== Infinity ? d : (_t._iO ? _t._iO.duration : null));\r\n      return result;\r\n    };\r\n\r\n    this._setup_html5 = function(oOptions) {\r\n      var _iO = _mixin(_t._iO, oOptions), d = decodeURI,\r\n          _a = _useGlobalHTML5Audio ? _s._global_a : _t._a,\r\n          _dURL = d(_iO.url),\r\n          _oldIO = (_a && _a._t ? _a._t.instanceOptions : null);\r\n      if (_a) {\r\n        if (_a._t && _oldIO.url === _iO.url && (!_t._lastURL || (_t._lastURL === _oldIO.url))) {\r\n          return _a; // same url, ignore request\r\n        }\r\n        _s._wD('setting new URL on existing object: ' + _dURL + (_t._lastURL ? ', old URL: ' + _t._lastURL : ''));\r\n        /*\r\n         * \"First things first, I, Poppa..\" (reset the previous state of the old sound, if playing)\r\n         * Fixes case with devices that can only play one sound at a time\r\n         * Otherwise, other sounds in mid-play will be terminated without warning and in a stuck state\r\n        */\r\n        if (_useGlobalHTML5Audio && _a._t && _a._t.playState && _iO.url !== _oldIO.url) {\r\n          _a._t.stop();\r\n        }\r\n        _resetProperties(); // new URL, so reset load/playstate and so on\r\n        _a.src = _iO.url;\r\n        _t.url = _iO.url;\r\n        _t._lastURL = _iO.url;\r\n        _a._called_load = false;\r\n      } else {\r\n        _s._wD('creating HTML5 Audio() element with URL: '+_dURL);\r\n        _a = new Audio(_iO.url);\r\n        _a._called_load = false;\r\n        if (_useGlobalHTML5Audio) {\r\n          _s._global_a = _a;\r\n        }\r\n      }\r\n      _t.isHTML5 = true;\r\n      _t._a = _a; // store a ref on the track\r\n      _a._t = _t; // store a ref on the audio\r\n      _t._add_html5_events();\r\n      _a.loop = (_iO.loops>1?'loop':'');\r\n      if (_iO.autoLoad || _iO.autoPlay) {\r\n        _a.autobuffer = 'auto'; // early HTML5 implementation (non-standard)\r\n        _a.preload = 'auto'; // standard\r\n        _t.load();\r\n        _a._called_load = true;\r\n      } else {\r\n        _a.autobuffer = false; // early HTML5 implementation (non-standard)\r\n        _a.preload = 'none'; // standard\r\n      }\r\n      _a.loop = (_iO.loops>1?'loop':''); // boolean instead of \"loop\", for webkit? - spec says string. http://www.w3.org/TR/html-markup/audio.html#audio.attrs.loop\r\n      return _a;\r\n    };\r\n\r\n    this._add_html5_events = function() {\r\n\r\n      if (_t._a._added_events) {\r\n        return false;\r\n      }\r\n\r\n      var f;\r\n\r\n      function add(oEvt, oFn, bCapture) {\r\n        return _t._a ? _t._a.addEventListener(oEvt, oFn, bCapture||false) : null;\r\n      }\r\n\r\n      _s._wD(_h5+'adding event listeners: '+_t.sID);\r\n      _t._a._added_events = true;\r\n\r\n      for (f in _html5_events) {\r\n        if (_html5_events.hasOwnProperty(f)) {\r\n          add(f, _html5_events[f]);\r\n        }\r\n      }\r\n\r\n      return true;\r\n\r\n    };\r\n\r\n    this._remove_html5_events = function() {\r\n\r\n      // Remove event listeners\r\n\r\n      var f;\r\n\r\n      function remove(oEvt, oFn, bCapture) {\r\n        return (_t._a ? _t._a.removeEventListener(oEvt, oFn, bCapture||false) : null);\r\n      }\r\n\r\n      _s._wD(_h5+'removing event listeners: '+_t.sID);\r\n      _t._a._added_events = false;\r\n\r\n      for (f in _html5_events) {\r\n        if (_html5_events.hasOwnProperty(f)) {\r\n          remove(f, _html5_events[f]);\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    /*\r\n     * pseudo-private event internals\r\n    */\r\n\r\n    this._onload = function(nSuccess) {\r\n      var fN = 'SMSound._onload(): ', loadOK = (nSuccess?true:false);\r\n      _s._wD(fN + '\"' + _t.sID + '\"' + (loadOK?' loaded.':' failed to load? - ' + _t.url), (loadOK?1:2));\r\n      // <d>\r\n      if (!loadOK && !_t.isHTML5) {\r\n        if (_s.sandbox.noRemote === true) {\r\n          _s._wD(fN + _str('noNet'), 1);\r\n        }\r\n        if (_s.sandbox.noLocal === true) {\r\n          _s._wD(fN + _str('noLocal'), 1);\r\n        }\r\n      }\r\n      // </d>\r\n      _t.loaded = loadOK;\r\n      _t.readyState = loadOK?3:2;\r\n      _t._onbufferchange(0);\r\n      if (_t._iO.onload) {\r\n        _t._iO.onload.apply(_t, [loadOK]);\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this._onbufferchange = function(nIsBuffering) {\r\n      var fN = 'SMSound._onbufferchange()';\r\n      if (_t.playState === 0) {\r\n        // ignore if not playing\r\n        return false;\r\n      }\r\n      if ((nIsBuffering && _t.isBuffering) || (!nIsBuffering && !_t.isBuffering)) {\r\n        return false;\r\n      }\r\n      _t.isBuffering = (nIsBuffering === 1);\r\n      if (_t._iO.onbufferchange) {\r\n        _s._wD(fN + ': ' + nIsBuffering);\r\n        _t._iO.onbufferchange.apply(_t);\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /*\r\n     * flash-only method, should fire only once at most\r\n     * at this point we just recreate failed sounds rather than trying to reconnect\r\n    */\r\n    this._onfailure = function(msg, level, code) {\r\n      _t.failures++;\r\n      _s._wD('SMSound._onfailure(): \"'+_t.sID+'\" count '+_t.failures);\r\n      if (_t._iO.onfailure && _t.failures === 1) {\r\n        _t._iO.onfailure(_t, msg, level, code);\r\n      } else {\r\n        _s._wD('SMSound._onfailure(): ignoring');\r\n      }\r\n    };\r\n\r\n    this._onbeforefinish = function() {\r\n      if (!_t.didBeforeFinish) {\r\n        _t.didBeforeFinish = true;\r\n        if (_t._iO.onbeforefinish) {\r\n          _s._wD('SMSound._onbeforefinish(): \"' + _t.sID + '\"');\r\n          _t._iO.onbeforefinish.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._onjustbeforefinish = function(msOffset) {\r\n      if (!_t.didJustBeforeFinish) {\r\n        _t.didJustBeforeFinish = true;\r\n        if (_t._iO.onjustbeforefinish) {\r\n          _s._wD('SMSound._onjustbeforefinish(): \"' + _t.sID + '\"');\r\n          _t._iO.onjustbeforefinish.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._onfinish = function() {\r\n      var _io_onfinish = _t._iO.onfinish; // store local copy before it gets trashed..\r\n      _t._onbufferchange(0);\r\n      _t.resetOnPosition(0);\r\n      if (_t._iO.onbeforefinishcomplete) {\r\n        _t._iO.onbeforefinishcomplete.apply(_t);\r\n      }\r\n      // reset some state items\r\n      _t.didBeforeFinish = false;\r\n      _t.didJustBeforeFinish = false;\r\n      if (_t.instanceCount) {\r\n        _t.instanceCount--;\r\n        if (!_t.instanceCount) {\r\n          // reset instance options\r\n          _t.playState = 0;\r\n          _t.paused = false;\r\n          _t.instanceCount = 0;\r\n          _t.instanceOptions = {};\r\n          _t._iO = {};\r\n          _stop_html5_timer();\r\n        }\r\n        if (!_t.instanceCount || _t._iO.multiShotEvents) {\r\n          // fire onfinish for last, or every instance\r\n          if (_io_onfinish) {\r\n            _s._wD('SMSound._onfinish(): \"' + _t.sID + '\"');\r\n            _io_onfinish.apply(_t);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this._whileloading = function(nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {\r\n      _t.bytesLoaded = nBytesLoaded;\r\n      _t.bytesTotal = nBytesTotal;\r\n      _t.duration = Math.floor(nDuration);\r\n      _t.bufferLength = nBufferLength;\r\n      if (!_t._iO.isMovieStar) {\r\n        if (_t._iO.duration) {\r\n          // use options, if specified and larger\r\n          _t.durationEstimate = (_t.duration > _t._iO.duration) ? _t.duration : _t._iO.duration;\r\n        } else {\r\n          _t.durationEstimate = parseInt((_t.bytesTotal / _t.bytesLoaded) * _t.duration, 10);\r\n        }\r\n        if (_t.durationEstimate === undefined) {\r\n          _t.durationEstimate = _t.duration;\r\n        }\r\n        if (_t.readyState !== 3 && _t._iO.whileloading) {\r\n          _t._iO.whileloading.apply(_t);\r\n        }\r\n      } else {\r\n        _t.durationEstimate = _t.duration;\r\n        if (_t.readyState !== 3 && _t._iO.whileloading) {\r\n          _t._iO.whileloading.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._whileplaying = function(nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {\r\n      if (isNaN(nPosition) || nPosition === null) {\r\n        return false; // flash safety net\r\n      }\r\n      _t.position = nPosition;\r\n      _t.processOnPosition();\r\n      if (!_t.isHTML5 && _fV > 8) {\r\n        if (_t._iO.usePeakData && typeof oPeakData !== 'undefined' && oPeakData) {\r\n          _t.peakData = {\r\n            left: oPeakData.leftPeak,\r\n            right: oPeakData.rightPeak\r\n          };\r\n        }\r\n        if (_t._iO.useWaveformData && typeof oWaveformDataLeft !== 'undefined' && oWaveformDataLeft) {\r\n          _t.waveformData = {\r\n            left: oWaveformDataLeft.split(','),\r\n            right: oWaveformDataRight.split(',')\r\n          };\r\n        }\r\n        if (_t._iO.useEQData) {\r\n          if (typeof oEQData !== 'undefined' && oEQData && oEQData.leftEQ) {\r\n            var eqLeft = oEQData.leftEQ.split(',');\r\n            _t.eqData = eqLeft;\r\n            _t.eqData.left = eqLeft;\r\n            if (typeof oEQData.rightEQ !== 'undefined' && oEQData.rightEQ) {\r\n              _t.eqData.right = oEQData.rightEQ.split(',');\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (_t.playState === 1) {\r\n        // special case/hack: ensure buffering is false if loading from cache (and not yet started)\r\n        if (!_t.isHTML5 && _s.flashVersion === 8 && !_t.position && _t.isBuffering) {\r\n          _t._onbufferchange(0);\r\n        }\r\n        if (_t._iO.whileplaying) {\r\n          _t._iO.whileplaying.apply(_t); // flash may call after actual finish\r\n        }\r\n        if ((_t.loaded || (!_t.loaded && _t._iO.isMovieStar)) && _t._iO.onbeforefinish && _t._iO.onbeforefinishtime && !_t.didBeforeFinish && _t.duration - _t.position <= _t._iO.onbeforefinishtime) {\r\n          _t._onbeforefinish();\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this._onid3 = function(oID3PropNames, oID3Data) {\r\n      // oID3PropNames: string array (names)\r\n      // ID3Data: string array (data)\r\n      _s._wD('SMSound._onid3(): \"' + this.sID + '\" ID3 data received.');\r\n      var oData = [], i, j;\r\n      for (i = 0, j = oID3PropNames.length; i < j; i++) {\r\n        oData[oID3PropNames[i]] = oID3Data[i];\r\n      }\r\n      _t.id3 = _mixin(_t.id3, oData);\r\n      if (_t._iO.onid3) {\r\n        _t._iO.onid3.apply(_t);\r\n      }\r\n    };\r\n\r\n    // flash + RTMP\r\n    this._onconnect = function(bSuccess) {\r\n      var fN = 'SMSound._onconnect(): ';\r\n      bSuccess = (bSuccess === 1);\r\n      _s._wD(fN+'\"'+_t.sID+'\"'+(bSuccess?' connected.':' failed to connect? - '+_t.url), (bSuccess?1:2));\r\n      _t.connected = bSuccess;\r\n      if (bSuccess) {\r\n        _t.failures = 0;\r\n        if (_idCheck(_t.sID)) {\r\n          if (_t.getAutoPlay()) {\r\n            _t.play(undefined, _t.getAutoPlay()); // only update the play state if auto playing\r\n          } else if (_t._iO.autoLoad) {\r\n            _t.load();\r\n          }\r\n        }\r\n        if (_t._iO.onconnect) {\r\n          _t._iO.onconnect.apply(_t,[bSuccess]);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._ondataerror = function(sError) {\r\n      // flash 9 wave/eq data handler\r\n      if (_t.playState > 0) { // hack: called at start, and end from flash at/after onfinish()\r\n        _s._wD('SMSound._ondataerror(): ' + sError);\r\n        if (_t._iO.ondataerror) {\r\n          _t._iO.ondataerror.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n  }; // SMSound()\r\n\r\n  /*\r\n   * private soundManager internals\r\n  */\r\n\r\n  _getDocument = function() {\r\n    return (_doc.body || _doc._docElement || _doc.getElementsByTagName('div')[0]);\r\n  };\r\n\r\n  _id = function(sID) {\r\n    return _doc.getElementById(sID);\r\n  };\r\n\r\n  _mixin = function(oMain, oAdd) {\r\n    // non-destructive merge\r\n    var o1 = {}, i, o2, o;\r\n    for (i in oMain) { // clone c1\r\n      if (oMain.hasOwnProperty(i)) {\r\n        o1[i] = oMain[i];\r\n      }\r\n    }\r\n    o2 = (typeof oAdd === 'undefined'?_s.defaultOptions:oAdd);\r\n    for (o in o2) {\r\n      if (o2.hasOwnProperty(o) && typeof o1[o] === 'undefined') {\r\n        o1[o] = o2[o];\r\n      }\r\n    }\r\n    return o1;\r\n  };\r\n\r\n  _event = (function() {\r\n\r\n    var old = (_win.attachEvent),\r\n    evt = {\r\n      add: (old?'attachEvent':'addEventListener'),\r\n      remove: (old?'detachEvent':'removeEventListener')\r\n    };\r\n\r\n    function getArgs(oArgs) {\r\n      var args = _slice.call(oArgs), len = args.length;\r\n      if (old) {\r\n        args[1] = 'on' + args[1]; // prefix\r\n        if (len > 3) {\r\n          args.pop(); // no capture\r\n        }\r\n      } else if (len === 3) {\r\n        args.push(false);\r\n      }\r\n      return args;\r\n    }\r\n\r\n    function apply(args, sType) {\r\n      var element = args.shift(),\r\n          method = [evt[sType]];\r\n      if (old) {\r\n        element[method](args[0], args[1]);\r\n      } else {\r\n        element[method].apply(element, args);\r\n      }\r\n    }\r\n\r\n    function add() {\r\n      apply(getArgs(arguments), 'add');\r\n    }\r\n\r\n    function remove() {\r\n      apply(getArgs(arguments), 'remove');\r\n    }\r\n\r\n    return {\r\n      'add': add,\r\n      'remove': remove\r\n    };\r\n\r\n  }());\r\n\r\n  _html5OK = function(iO) {\r\n    return (!iO.serverURL && (iO.type?_html5CanPlay({type:iO.type}):_html5CanPlay({url:iO.url})||_s.html5Only)); // Use type, if specified. If HTML5-only mode, no other options, so just give 'er\r\n  };\r\n\r\n  _html5CanPlay = function(o) {\r\n\r\n    /*\r\n     * try to find MIME, test and return truthiness\r\n     * o = {\r\n     *  url: '/path/to/an.mp3',\r\n     *  type: 'audio/mp3'\r\n     * }\r\n    */\r\n\r\n    if (!_s.useHTML5Audio || !_s.hasHTML5) {\r\n      return false;\r\n    }\r\n\r\n    var url = (o.url || null),\r\n        mime = (o.type || null),\r\n        aF = _s.audioFormats,\r\n        result,\r\n        offset,\r\n        fileExt,\r\n        item;\r\n\r\n    function preferFlashCheck(kind) {\r\n      // whether flash should play a given type\r\n      return (_s.preferFlash && _hasFlash && !_s.ignoreFlash && (typeof _s.flash[kind] !== 'undefined' && _s.flash[kind]));\r\n    }\r\n\r\n    // account for known cases like audio/mp3\r\n    if (mime && _s.html5[mime] !== 'undefined') {\r\n      return (_s.html5[mime] && !preferFlashCheck(mime));\r\n    }\r\n\r\n    if (!_html5Ext) {\r\n      _html5Ext = [];\r\n      for (item in aF) {\r\n        if (aF.hasOwnProperty(item)) {\r\n          _html5Ext.push(item);\r\n          if (aF[item].related) {\r\n            _html5Ext = _html5Ext.concat(aF[item].related);\r\n          }\r\n        }\r\n      }\r\n      _html5Ext = new RegExp('\\\\.('+_html5Ext.join('|')+')(\\\\?.*)?$','i');\r\n    }\r\n\r\n    fileExt = (url ? url.toLowerCase().match(_html5Ext) : null); // TODO: Strip URL queries, etc.\r\n\r\n    if (!fileExt || !fileExt.length) {\r\n      if (!mime) {\r\n        return false;\r\n      } else {\r\n        // audio/mp3 -> mp3, result should be known\r\n        offset = mime.indexOf(';');\r\n        fileExt = (offset !== -1?mime.substr(0,offset):mime).substr(6); // strip \"audio/X; codecs..\"\r\n      }\r\n    } else {\r\n      fileExt = fileExt[1]; // match the raw extension name - \"mp3\", for example\r\n    }\r\n\r\n    if (fileExt && typeof _s.html5[fileExt] !== 'undefined') {\r\n      // result known\r\n      return (_s.html5[fileExt] && !preferFlashCheck(fileExt));\r\n    } else {\r\n      mime = 'audio/'+fileExt;\r\n      result = _s.html5.canPlayType({type:mime});\r\n      _s.html5[fileExt] = result;\r\n      // _s._wD('canPlayType, found result: '+result);\r\n      return (result && _s.html5[mime] && !preferFlashCheck(mime));\r\n    }\r\n\r\n  };\r\n\r\n  _testHTML5 = function() {\r\n\r\n    if (!_s.useHTML5Audio || typeof Audio === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    // double-whammy: Opera 9.64 throws WRONG_ARGUMENTS_ERR if no parameter passed to Audio(), and Webkit + iOS happily tries to load \"null\" as a URL. :/\r\n    var a = (typeof Audio !== 'undefined' ? (_isOpera ? new Audio(null) : new Audio()) : null),\r\n        item, support = {}, aF, i;\r\n\r\n    function _cp(m) {\r\n      var canPlay, i, j, isOK = false;\r\n      if (!a || typeof a.canPlayType !== 'function') {\r\n        return false;\r\n      }\r\n      if (m instanceof Array) {\r\n        // iterate through all mime types, return any successes\r\n        for (i=0, j=m.length; i<j && !isOK; i++) {\r\n          if (_s.html5[m[i]] || a.canPlayType(m[i]).match(_s.html5Test)) {\r\n            isOK = true;\r\n            _s.html5[m[i]] = true;\r\n            // if flash can play and preferred, also mark it for use.\r\n            _s.flash[m[i]] = !!(_s.preferFlash && _hasFlash && m[i].match(_flashMIME));\r\n          }\r\n        }\r\n        return isOK;\r\n      } else {\r\n        canPlay = (a && typeof a.canPlayType === 'function' ? a.canPlayType(m) : false);\r\n        return !!(canPlay && (canPlay.match(_s.html5Test)));\r\n      }\r\n    }\r\n\r\n    // test all registered formats + codecs\r\n    aF = _s.audioFormats;\r\n    for (item in aF) {\r\n      if (aF.hasOwnProperty(item)) {\r\n        support[item] = _cp(aF[item].type);\r\n        support['audio/'+item] = support[item]; // write back generic type too, eg. audio/mp3\r\n        // assign flash\r\n        if (_s.preferFlash && !_s.ignoreFlash && item.match(_flashMIME)) {\r\n          _s.flash[item] = true;\r\n        } else {\r\n          _s.flash[item] = false;\r\n        }\r\n        // assign result to related formats, too\r\n        if (aF[item] && aF[item].related) {\r\n          for (i=aF[item].related.length; i--;) {\r\n            support['audio/'+aF[item].related[i]] = support[item]; // eg. audio/m4a\r\n            _s.html5[aF[item].related[i]] = support[item];\r\n            _s.flash[aF[item].related[i]] = support[item];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    support.canPlayType = (a?_cp:null);\r\n    _s.html5 = _mixin(_s.html5, support);\r\n    return true;\r\n\r\n  };\r\n\r\n  _strings = {\r\n    // <d>\r\n    notReady: 'Not loaded yet - wait for soundManager.onload()/onready()',\r\n    notOK: 'Audio support is not available.',\r\n    domError: _smc + 'createMovie(): appendChild/innerHTML call failed. DOM not ready or other error.',\r\n    spcWmode: _smc + 'createMovie(): Removing wmode, preventing known SWF loading issue(s)',\r\n    swf404: _sm + ': Verify that %s is a valid path.',\r\n    tryDebug: 'Try ' + _sm + '.debugFlash = true for more security details (output goes to SWF.)',\r\n    checkSWF: 'See SWF output for more debug info.',\r\n    localFail: _sm + ': Non-HTTP page (' + _doc.location.protocol + ' URL?) Review Flash player security settings for this special case:\\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/',\r\n    waitFocus: _sm + ': Special case: Waiting for focus-related event..',\r\n    waitImpatient: _sm + ': Getting impatient, still waiting for Flash%s...',\r\n    waitForever: _sm + ': Waiting indefinitely for Flash (will recover if unblocked)...',\r\n    needFunction: _sm + ': Function object expected for %s',\r\n    badID: 'Warning: Sound ID \"%s\" should be a string, starting with a non-numeric character',\r\n    noMS: 'MovieStar mode not enabled. Exiting.',\r\n    currentObj: '--- ' + _sm + '._debug(): Current sound objects ---',\r\n    waitEI: _smc + 'initMovie(): Waiting for ExternalInterface call from Flash..',\r\n    waitOnload: _sm + ': Waiting for window.onload()',\r\n    docLoaded: _sm + ': Document already loaded',\r\n    onload: _smc + 'initComplete(): calling soundManager.onload()',\r\n    onloadOK: _sm + '.onload() complete',\r\n    init: _smc + 'init()',\r\n    didInit: _smc + 'init(): Already called?',\r\n    flashJS: _sm + ': Attempting to call Flash from JS..',\r\n    noPolling: _sm + ': Polling (whileloading()/whileplaying() support) is disabled.',\r\n    secNote: 'Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html',\r\n    badRemove: 'Warning: Failed to remove flash movie.',\r\n    noPeak: 'Warning: peakData features unsupported for movieStar formats',\r\n    shutdown: _sm + '.disable(): Shutting down',\r\n    queue: _sm + ': Queueing %s handler',\r\n    smFail: _sm + ': Failed to initialise.',\r\n    smError: 'SMSound.load(): Exception: JS-Flash communication failed, or JS error.',\r\n    fbTimeout: 'No flash response, applying .'+_s.swfCSS.swfTimedout+' CSS..',\r\n    fbLoaded: 'Flash loaded',\r\n    fbHandler: _smc+'flashBlockHandler()',\r\n    manURL: 'SMSound.load(): Using manually-assigned URL',\r\n    onURL: _sm + '.load(): current URL already assigned.',\r\n    badFV: _sm + '.flashVersion must be 8 or 9. \"%s\" is invalid. Reverting to %s.',\r\n    as2loop: 'Note: Setting stream:false so looping can work (flash 8 limitation)',\r\n    noNSLoop: 'Note: Looping not implemented for MovieStar formats',\r\n    needfl9: 'Note: Switching to flash 9, required for MP4 formats.',\r\n    mfTimeout: 'Setting flashLoadTimeout = 0 (infinite) for off-screen, mobile flash case',\r\n    mfOn: 'mobileFlash::enabling on-screen flash repositioning',\r\n    policy: 'Enabling usePolicyFile for data access'\r\n    // </d>\r\n  };\r\n\r\n  _str = function() { // o [,items to replace]\r\n    // <d>\r\n    var args = _slice.call(arguments), // real array, please\r\n    o = args.shift(), // first arg\r\n    str = (_strings && _strings[o]?_strings[o]:''), i, j;\r\n    if (str && args && args.length) {\r\n      for (i = 0, j = args.length; i < j; i++) {\r\n        str = str.replace('%s', args[i]);\r\n      }\r\n    }\r\n    return str;\r\n    // </d>\r\n  };\r\n\r\n  _loopFix = function(sOpt) {\r\n    // flash 8 requires stream = false for looping to work\r\n    if (_fV === 8 && sOpt.loops > 1 && sOpt.stream) {\r\n      _wDS('as2loop');\r\n      sOpt.stream = false;\r\n    }\r\n    return sOpt;\r\n  };\r\n\r\n  _policyFix = function(sOpt, sPre) {\r\n    if (sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData)) {\r\n      _s._wD((sPre || '') + _str('policy'));\r\n      sOpt.usePolicyFile = true;\r\n    }\r\n    return sOpt;\r\n  };\r\n\r\n  _complain = function(sMsg) {\r\n    if (typeof console !== 'undefined' && typeof console.warn !== 'undefined') {\r\n      console.warn(sMsg);\r\n    } else {\r\n      _s._wD(sMsg);\r\n    }\r\n  };\r\n\r\n  _doNothing = function() {\r\n    return false;\r\n  };\r\n\r\n  _disableObject = function(o) {\r\n    var oProp;\r\n    for (oProp in o) {\r\n      if (o.hasOwnProperty(oProp) && typeof o[oProp] === 'function') {\r\n        o[oProp] = _doNothing;\r\n      }\r\n    }\r\n    oProp = null;\r\n  };\r\n\r\n  _failSafely = function(bNoDisable) {\r\n    // general failure exception handler\r\n    if (typeof bNoDisable === 'undefined') {\r\n      bNoDisable = false;\r\n    }\r\n    if (_disabled || bNoDisable) {\r\n      _wDS('smFail', 2);\r\n      _s.disable(bNoDisable);\r\n    }\r\n  };\r\n\r\n  _normalizeMovieURL = function(smURL) {\r\n    var urlParams = null;\r\n    if (smURL) {\r\n      if (smURL.match(/\\.swf(\\?.*)?$/i)) {\r\n        urlParams = smURL.substr(smURL.toLowerCase().lastIndexOf('.swf?') + 4);\r\n        if (urlParams) {\r\n          return smURL; // assume user knows what they're doing\r\n        }\r\n      } else if (smURL.lastIndexOf('/') !== smURL.length - 1) {\r\n        smURL = smURL + '/';\r\n      }\r\n    }\r\n    return (smURL && smURL.lastIndexOf('/') !== - 1?smURL.substr(0, smURL.lastIndexOf('/') + 1):'./') + _s.movieURL;\r\n  };\r\n\r\n  _setVersionInfo = function() {\r\n\r\n    if (_fV !== 8 && _fV !== 9) {\r\n      _s._wD(_str('badFV', _fV, _defaultFlashVersion));\r\n      _s.flashVersion = _defaultFlashVersion;\r\n    }\r\n    var isDebug = (_s.debugMode || _s.debugFlash?'_debug.swf':'.swf'); // debug flash movie, if applicable\r\n    if (_s.useHTML5Audio && !_s.html5Only && _s.audioFormats.mp4.required && _s.flashVersion < 9) {\r\n      _s._wD(_str('needfl9'));\r\n      _s.flashVersion = 9;\r\n    }\r\n    _fV = _s.flashVersion; // short-hand for internal use\r\n    _s.version = _s.versionNumber + (_s.html5Only?' (HTML5-only mode)':(_fV === 9?' (AS3/Flash 9)':' (AS2/Flash 8)'));\r\n    // set up default options\r\n    if (_fV > 8) {\r\n      _s.defaultOptions = _mixin(_s.defaultOptions, _s.flash9Options);\r\n      _s.features.buffering = true;\r\n    }\r\n    if (_fV > 8 && _s.useMovieStar) {\r\n      // flash 9+ support for movieStar formats as well as MP3\r\n      _s.defaultOptions = _mixin(_s.defaultOptions, _s.movieStarOptions);\r\n      _s.filePatterns.flash9 = new RegExp('\\\\.(mp3|' + _s.netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\r\n      _s.mimePattern = _s.netStreamMimeTypes;\r\n      _s.features.movieStar = true;\r\n    } else {\r\n      _s.useMovieStar = false;\r\n      _s.features.movieStar = false;\r\n    }\r\n    _s.filePattern = _s.filePatterns[(_fV !== 8?'flash9':'flash8')];\r\n    _s.movieURL = (_fV === 8?'soundmanager2.swf':'soundmanager2_flash9.swf').replace('.swf',isDebug);\r\n    _s.features.peakData = _s.features.waveformData = _s.features.eqData = (_fV > 8);\r\n  };\r\n\r\n  _setPolling = function(bPolling, bHighPerformance) {\r\n    if (!_s.o || !_s.allowPolling) {\r\n      return false;\r\n    }\r\n    _s.o._setPolling(bPolling, bHighPerformance);\r\n  };\r\n\r\n  _initDebug = function() {\r\n    if (_s.debugURLParam.test(_wl)) {\r\n      _s.debugMode = true; // allow force of debug mode via URL\r\n    }\r\n    // <d>\r\n    if (_id(_s.debugID)) {\r\n      return false;\r\n    }\r\n    var oD, oDebug, oTarget, oToggle, tmp;\r\n    if (_s.debugMode && !_id(_s.debugID) && ((!_hasConsole || !_s.useConsole) || (_s.useConsole && _hasConsole && !_s.consoleOnly))) {\r\n      oD = _doc.createElement('div');\r\n      oD.id = _s.debugID + '-toggle';\r\n      oToggle = {\r\n        'position': 'fixed',\r\n        'bottom': '0px',\r\n        'right': '0px',\r\n        'width': '1.2em',\r\n        'height': '1.2em',\r\n        'lineHeight': '1.2em',\r\n        'margin': '2px',\r\n        'textAlign': 'center',\r\n        'border': '1px solid #999',\r\n        'cursor': 'pointer',\r\n        'background': '#fff',\r\n        'color': '#333',\r\n        'zIndex': 10001\r\n      };\r\n      oD.appendChild(_doc.createTextNode('-'));\r\n      oD.onclick = _toggleDebug;\r\n      oD.title = 'Toggle SM2 debug console';\r\n      if (_ua.match(/msie 6/i)) {\r\n        oD.style.position = 'absolute';\r\n        oD.style.cursor = 'hand';\r\n      }\r\n      for (tmp in oToggle) {\r\n        if (oToggle.hasOwnProperty(tmp)) {\r\n          oD.style[tmp] = oToggle[tmp];\r\n        }\r\n      }\r\n      oDebug = _doc.createElement('div');\r\n      oDebug.id = _s.debugID;\r\n      oDebug.style.display = (_s.debugMode?'block':'none');\r\n      if (_s.debugMode && !_id(oD.id)) {\r\n        try {\r\n          oTarget = _getDocument();\r\n          oTarget.appendChild(oD);\r\n        } catch(e2) {\r\n          throw new Error(_str('domError')+' \\n'+e2.toString());\r\n        }\r\n        oTarget.appendChild(oDebug);\r\n      }\r\n    }\r\n    oTarget = null;\r\n    // </d>\r\n  };\r\n\r\n  _idCheck = this.getSoundById;\r\n\r\n  // <d>\r\n  _wDS = function(o, errorLevel) {\r\n    if (!o) {\r\n      return '';\r\n    } else {\r\n      return _s._wD(_str(o), errorLevel);\r\n    }\r\n  };\r\n\r\n  // last-resort debugging option\r\n  if (_wl.indexOf('sm2-debug=alert') + 1 && _s.debugMode) {\r\n    _s._wD = function(sText) {window.alert(sText);};\r\n  }\r\n\r\n  _toggleDebug = function() {\r\n    var o = _id(_s.debugID),\r\n    oT = _id(_s.debugID + '-toggle');\r\n    if (!o) {\r\n      return false;\r\n    }\r\n    if (_debugOpen) {\r\n      // minimize\r\n      oT.innerHTML = '+';\r\n      o.style.display = 'none';\r\n    } else {\r\n      oT.innerHTML = '-';\r\n      o.style.display = 'block';\r\n    }\r\n    _debugOpen = !_debugOpen;\r\n  };\r\n\r\n  _debugTS = function(sEventType, bSuccess, sMessage) {\r\n    // troubleshooter debug hooks\r\n    if (typeof sm2Debugger !== 'undefined') {\r\n      try {\r\n        sm2Debugger.handleEvent(sEventType, bSuccess, sMessage);\r\n      } catch(e) {\r\n        // oh well\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  // </d>\r\n\r\n  _getSWFCSS = function() {\r\n    var css = [];\r\n    if (_s.debugMode) {\r\n      css.push(_s.swfCSS.sm2Debug);\r\n    }\r\n    if (_s.debugFlash) {\r\n      css.push(_s.swfCSS.flashDebug);\r\n    }\r\n    if (_s.useHighPerformance) {\r\n      css.push(_s.swfCSS.highPerf);\r\n    }\r\n    return css.join(' ');\r\n  };\r\n\r\n  _flashBlockHandler = function() {\r\n    // *possible* flash block situation.\r\n    var name = _str('fbHandler'),\r\n        p = _s.getMoviePercent(),\r\n        css = _s.swfCSS,\r\n        error = {type:'FLASHBLOCK'};\r\n    if (_s.html5Only) {\r\n      return false;\r\n    }\r\n    if (!_s.ok()) {\r\n      if (_needsFlash) {\r\n        // make the movie more visible, so user can fix\r\n        _s.oMC.className = _getSWFCSS() + ' ' + css.swfDefault + ' ' + (p === null?css.swfTimedout:css.swfError);\r\n        _s._wD(name+': '+_str('fbTimeout')+(p?' ('+_str('fbLoaded')+')':''));\r\n      }\r\n      _s.didFlashBlock = true;\r\n      _processOnEvents({type:'ontimeout', ignoreInit:true, error:error}); // fire onready(), complain lightly\r\n      _catchError(error);\r\n    } else {\r\n      // SM2 loaded OK (or recovered)\r\n      if (_s.didFlashBlock) {\r\n        _s._wD(name+': Unblocked');\r\n      }\r\n      if (_s.oMC) {\r\n        _s.oMC.className = [_getSWFCSS(), css.swfDefault, css.swfLoaded + (_s.didFlashBlock?' '+css.swfUnblocked:'')].join(' ');\r\n      }\r\n    }\r\n  };\r\n\r\n  _addOnEvent = function(sType, oMethod, oScope) {\r\n    if (typeof _on_queue[sType] === 'undefined') {\r\n      _on_queue[sType] = [];\r\n    }\r\n    _on_queue[sType].push({\r\n      'method': oMethod,\r\n      'scope': (oScope || null),\r\n      'fired': false\r\n    });\r\n  };\r\n\r\n  _processOnEvents = function(oOptions) {\r\n    if (!oOptions) { // assume onready, if unspecified\r\n      oOptions = {\r\n        type: 'onready'\r\n      };\r\n    }\r\n    if (!_didInit && oOptions && !oOptions.ignoreInit) {\r\n      // not ready yet.\r\n      return false;\r\n    }\r\n    if (oOptions.type === 'ontimeout' && _s.ok()) {\r\n      // invalid case\r\n      return false;\r\n    }\r\n    var status = {\r\n          success: (oOptions && oOptions.ignoreInit?_s.ok():!_disabled)\r\n        },\r\n        srcQueue = (oOptions && oOptions.type?_on_queue[oOptions.type]||[]:[]), // queue specified by type, or none\r\n        queue = [], i, j,\r\n        args = [status],\r\n        canRetry = (_needsFlash && _s.useFlashBlock && !_s.ok());\r\n    if (oOptions.error) {\r\n      args[0].error = oOptions.error;\r\n    }\r\n    for (i = 0, j = srcQueue.length; i < j; i++) {\r\n      if (srcQueue[i].fired !== true) {\r\n        queue.push(srcQueue[i]);\r\n      }\r\n    }\r\n    if (queue.length) {\r\n      _s._wD(_sm + ': Firing ' + queue.length + ' '+oOptions.type+'() item' + (queue.length === 1?'':'s'));\r\n      for (i = 0, j = queue.length; i < j; i++) {\r\n        if (queue[i].scope) {\r\n          queue[i].method.apply(queue[i].scope, args);\r\n        } else {\r\n          queue[i].method.apply(this, args);\r\n        }\r\n        if (!canRetry) { // flashblock case doesn't count here\r\n          queue[i].fired = true;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  _initUserOnload = function() {\r\n    _win.setTimeout(function() {\r\n      if (_s.useFlashBlock) {\r\n        _flashBlockHandler();\r\n      }\r\n      _processOnEvents();\r\n      // call user-defined \"onload\", scoped to window\r\n      if (_s.onload instanceof Function) {\r\n        _wDS('onload', 1);\r\n        _s.onload.apply(_win);\r\n        _wDS('onloadOK', 1);\r\n      }\r\n      if (_s.waitForWindowLoad) {\r\n        _event.add(_win, 'load', _initUserOnload);\r\n      }\r\n    },1);\r\n  };\r\n\r\n  _detectFlash = function() {\r\n\r\n    // hat tip: Flash Detect library (BSD, (C) 2007) by Carl \"DocYes\" S. Yestrau - http://featureblend.com/javascript-flash-detection-library.html / http://featureblend.com/license.txt\r\n\r\n    if (_hasFlash !== undefined) {\r\n      // this work has already been done.\r\n      return _hasFlash;\r\n    }\r\n\r\n    var hasPlugin = false, n = navigator, nP = n.plugins, obj, type, types, AX = _win.ActiveXObject;\r\n\r\n    if (nP && nP.length) {\r\n\r\n      type = 'application/x-shockwave-flash';\r\n      types = n.mimeTypes;\r\n      if (types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description) {\r\n        hasPlugin = true;\r\n      }\r\n\r\n    } else if (typeof AX !== 'undefined') {\r\n\r\n      try {\r\n        obj = new AX('ShockwaveFlash.ShockwaveFlash');\r\n      } catch(e) {\r\n        // oh well\r\n      }\r\n      hasPlugin = (!!obj);\r\n\r\n    }\r\n\r\n    _hasFlash = hasPlugin;\r\n\r\n    return hasPlugin;\r\n\r\n  };\r\n\r\n  _featureCheck = function() {\r\n\r\n    var needsFlash, item,\r\n        isSpecial = (_ua.match(/iphone os (1|2|3_0|3_1)/i)?true:false); // iPhone <= 3.1 has broken HTML5 audio(), but firmware 3.2 (iPad) + iOS4 works.\r\n\r\n    if (isSpecial) {\r\n      _s.hasHTML5 = false; // has Audio(), but is broken; let it load links directly.\r\n      _s.html5Only = true; // ignore flash case, however\r\n      if (_s.oMC) {\r\n        _s.oMC.style.display = 'none';\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (_s.useHTML5Audio) {\r\n      if (!_s.html5 || !_s.html5.canPlayType) {\r\n        _s._wD('SoundManager: No HTML5 Audio() support detected.');\r\n        _s.hasHTML5 = false;\r\n        return true;\r\n      } else {\r\n        _s.hasHTML5 = true;\r\n      }\r\n      if (_isBadSafari) {\r\n        _s._wD(_smc+'Note: Buggy HTML5 Audio in Safari on this OS X release, see https://bugs.webkit.org/show_bug.cgi?id=32159 - '+(!_hasFlash?' would use flash fallback for MP3/MP4, but none detected.':'will use flash fallback for MP3/MP4, if available'),1);\r\n        if (_detectFlash()) {\r\n          return true;\r\n        }\r\n      }\r\n    } else {\r\n      // flash needed (or, HTML5 needs enabling.)\r\n      return true;\r\n    }\r\n\r\n    for (item in _s.audioFormats) {\r\n      if (_s.audioFormats.hasOwnProperty(item)) {\r\n        if ( (_s.audioFormats[item].required && !_s.html5.canPlayType(_s.audioFormats[item].type)) || _s.flash[item] || _s.flash[_s.audioFormats[item].type]) {\r\n          // flash may be required, or preferred for this format\r\n          needsFlash = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // sanity check..\r\n    if (_s.ignoreFlash) {\r\n      needsFlash = false;\r\n    }\r\n\r\n    _s.html5Only = (_s.hasHTML5 && _s.useHTML5Audio && !needsFlash);\r\n\r\n    return (!_s.html5Only);\r\n\r\n  };\r\n\r\n  _startTimer = function(oSound) {\r\n    if (!oSound._hasTimer) {\r\n      oSound._hasTimer = true;\r\n    }\r\n  };\r\n\r\n  _stopTimer = function(oSound) {\r\n    if (oSound._hasTimer) {\r\n      oSound._hasTimer = false;\r\n    }\r\n  };\r\n\r\n  _catchError = function(options) {\r\n    options = (typeof options !== 'undefined' ? options : {});\r\n    if (_s.onerror instanceof Function) {\r\n      _s.onerror.apply(_win, [{type:(typeof options.type !== 'undefined' ? options.type : null)}]);\r\n    }\r\n    if (typeof options.fatal !== 'undefined' && options.fatal) {\r\n      _s.disable();\r\n    }\r\n  };\r\n\r\n  _badSafariFix = function() {\r\n    // special case: \"bad\" Safari (OS X 10.3 - 10.7) must fall back to flash for MP3/MP4\r\n    if (!_isBadSafari || !_detectFlash()) {\r\n      return false; // doesn't apply\r\n    }\r\n    var aF = _s.audioFormats, i, item;\r\n    for (item in aF) {\r\n      if (aF.hasOwnProperty(item)) {\r\n        if (item === 'mp3' || item === 'mp4') {\r\n          _s._wD(_sm+': Using flash fallback for '+item+' format');\r\n          _s.html5[item] = false;\r\n          // assign result to related formats, too\r\n          if (aF[item] && aF[item].related) {\r\n            for (i = aF[item].related.length; i--;) {\r\n              _s.html5[aF[item].related[i]] = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\r\n   * pseudo-private flash/ExternalInterface methods\r\n  */\r\n\r\n  this._setSandboxType = function(sandboxType) {\r\n    // <d>\r\n    var sb = _s.sandbox;\r\n    sb.type = sandboxType;\r\n    sb.description = sb.types[(typeof sb.types[sandboxType] !== 'undefined'?sandboxType:'unknown')];\r\n    _s._wD('Flash security sandbox type: ' + sb.type);\r\n    if (sb.type === 'localWithFile') {\r\n      sb.noRemote = true;\r\n      sb.noLocal = false;\r\n      _wDS('secNote', 2);\r\n    } else if (sb.type === 'localWithNetwork') {\r\n      sb.noRemote = false;\r\n      sb.noLocal = true;\r\n    } else if (sb.type === 'localTrusted') {\r\n      sb.noRemote = false;\r\n      sb.noLocal = false;\r\n    }\r\n    // </d>\r\n  };\r\n\r\n  this._externalInterfaceOK = function(flashDate) {\r\n    // flash callback confirming flash loaded, EI working etc.\r\n    // flashDate = approx. timing/delay info for JS/flash bridge\r\n    if (_s.swfLoaded) {\r\n      return false;\r\n    }\r\n    var eiTime = new Date().getTime();\r\n    _s._wD(_smc+'externalInterfaceOK()' + (flashDate?' (~' + (eiTime - flashDate) + ' ms)':''));\r\n    _debugTS('swf', true);\r\n    _debugTS('flashtojs', true);\r\n    _s.swfLoaded = true;\r\n    _tryInitOnFocus = false;\r\n    if (_isBadSafari) {\r\n      _badSafariFix();\r\n    }\r\n    if (_isIE) {\r\n      // IE needs a timeout OR delay until window.onload - may need TODO: investigating\r\n      setTimeout(_init, 100);\r\n    } else {\r\n      _init();\r\n    }\r\n  };\r\n\r\n  /*\r\n   * private initialization helpers\r\n  */\r\n\r\n  _createMovie = function(smID, smURL) {\r\n\r\n    if (_didAppend && _appendSuccess) {\r\n      return false; // ignore if already succeeded\r\n    }\r\n\r\n    function _initMsg() {\r\n      _s._wD('-- SoundManager 2 ' + _s.version + (!_s.html5Only && _s.useHTML5Audio?(_s.hasHTML5?' + HTML5 audio':', no HTML5 audio support'):'') + (!_s.html5Only ? (_s.useMovieStar?', MovieStar mode':'') + (_s.useHighPerformance?', high performance mode, ':', ') + (( _s.flashPollingInterval ? 'custom (' + _s.flashPollingInterval + 'ms)' : (_s.useFastPolling?'fast':'normal')) + ' polling') + (_s.wmode?', wmode: ' + _s.wmode:'') + (_s.debugFlash?', flash debug mode':'') + (_s.useFlashBlock?', flashBlock mode':'') : '') + ' --', 1);\r\n    }\r\n\r\n    if (_s.html5Only) {\r\n      // 100% HTML5 mode\r\n      _setVersionInfo();\r\n      _initMsg();\r\n      _s.oMC = _id(_s.movieID);\r\n      _init();\r\n      // prevent multiple init attempts\r\n      _didAppend = true;\r\n      _appendSuccess = true;\r\n      return false;\r\n    }\r\n\r\n    // flash path\r\n    var remoteURL = (smURL || _s.url),\r\n    localURL = (_s.altURL || remoteURL),\r\n    swfTitle = 'JS/Flash audio component (SoundManager 2)',\r\n    oEmbed, oMovie, oTarget = _getDocument(), tmp, movieHTML, oEl, extraClass = _getSWFCSS(), s, x, sClass, side = 'auto', isRTL = null, html = _doc.getElementsByTagName('html')[0];\r\n\r\n    isRTL = (html && html.dir && html.dir.match(/rtl/i));\r\n    smID = (typeof smID === 'undefined'?_s.id:smID);\r\n\r\n    function param(name, value) {\r\n      return '<param name=\"'+name+'\" value=\"'+value+'\" />';\r\n    }\r\n\r\n    // safety check for legacy (change to Flash 9 URL)\r\n    _setVersionInfo();\r\n    _s.url = _normalizeMovieURL(_overHTTP?remoteURL:localURL);\r\n    smURL = _s.url;\r\n\r\n    _s.wmode = (!_s.wmode && _s.useHighPerformance && !_s.useMovieStar?'transparent':_s.wmode);\r\n\r\n    if (_s.wmode !== null && (_ua.match(/msie 8/i) || (!_isIE && !_s.useHighPerformance)) && navigator.platform.match(/win32|win64/i)) {\r\n      /*\r\n       * extra-special case: movie doesn't load until scrolled into view when using wmode = anything but 'window' here\r\n       * does not apply when using high performance (position:fixed means on-screen), OR infinite flash load timeout\r\n       * wmode breaks IE 8 on Vista + Win7 too in some cases, as of January 2011 (?)\r\n      */\r\n      _s.specialWmodeCase = true;\r\n      _wDS('spcWmode');\r\n      _s.wmode = null;\r\n    }\r\n\r\n    oEmbed = {\r\n      'name': smID,\r\n      'id': smID,\r\n      'src': smURL,\r\n      'width': side,\r\n      'height': side,\r\n      'quality': 'high',\r\n      'allowScriptAccess': _s.allowScriptAccess,\r\n      'bgcolor': _s.bgColor,\r\n      'pluginspage': _http+'//www.macromedia.com/go/getflashplayer',\r\n      'title': swfTitle,\r\n      'type': 'application/x-shockwave-flash',\r\n      'wmode': _s.wmode,\r\n      'hasPriority': 'true' // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\r\n    };\r\n\r\n    if (_s.debugFlash) {\r\n      oEmbed.FlashVars = 'debug=1';\r\n    }\r\n\r\n    if (!_s.wmode) {\r\n      delete oEmbed.wmode; // don't write empty attribute\r\n    }\r\n\r\n    if (_isIE) {\r\n\r\n      // IE is \"special\".\r\n      oMovie = _doc.createElement('div');\r\n      movieHTML = [\r\n        '<object id=\"' + smID + '\" data=\"' + smURL + '\" type=\"' + oEmbed.type + '\" title=\"' + oEmbed.title +'\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"' + _http+'//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\" width=\"' + oEmbed.width + '\" height=\"' + oEmbed.height + '\">',\r\n        param('movie', smURL),\r\n        param('AllowScriptAccess', _s.allowScriptAccess),\r\n        param('quality', oEmbed.quality),\r\n        (_s.wmode? param('wmode', _s.wmode): ''),\r\n        param('bgcolor', _s.bgColor),\r\n        param('hasPriority', 'true'),\r\n        (_s.debugFlash ? param('FlashVars', oEmbed.FlashVars) : ''),\r\n        '</object>'\r\n      ].join('');\r\n\r\n    } else {\r\n\r\n      oMovie = _doc.createElement('embed');\r\n      for (tmp in oEmbed) {\r\n        if (oEmbed.hasOwnProperty(tmp)) {\r\n          oMovie.setAttribute(tmp, oEmbed[tmp]);\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    _initDebug();\r\n    extraClass = _getSWFCSS();\r\n    oTarget = _getDocument();\r\n\r\n    if (oTarget) {\r\n\r\n      _s.oMC = (_id(_s.movieID) || _doc.createElement('div'));\r\n\r\n      if (!_s.oMC.id) {\r\n\r\n        _s.oMC.id = _s.movieID;\r\n        _s.oMC.className = _s.swfCSS.swfDefault + ' ' + extraClass;\r\n        s = null;\r\n        oEl = null;\r\n\r\n        if (!_s.useFlashBlock) {\r\n          if (_s.useHighPerformance) {\r\n            // on-screen at all times\r\n            s = {\r\n              'position': 'fixed',\r\n              'width': '8px',\r\n              'height': '8px',\r\n              // >= 6px for flash to run fast, >= 8px to start up under Firefox/win32 in some cases. odd? yes.\r\n              'bottom': '0px',\r\n              'left': '0px',\r\n              'overflow': 'hidden'\r\n            };\r\n          } else {\r\n            // hide off-screen, lower priority\r\n            s = {\r\n              'position': 'absolute',\r\n              'width': '6px',\r\n              'height': '6px',\r\n              'top': '-9999px',\r\n              'left': '-9999px'\r\n            };\r\n            if (isRTL) {\r\n              s.left = Math.abs(parseInt(s.left,10))+'px';\r\n            }\r\n          }\r\n        }\r\n\r\n        if (_isWebkit) {\r\n          _s.oMC.style.zIndex = 10000; // soundcloud-reported render/crash fix, safari 5\r\n        }\r\n\r\n        if (!_s.debugFlash) {\r\n          for (x in s) {\r\n            if (s.hasOwnProperty(x)) {\r\n              _s.oMC.style[x] = s[x];\r\n            }\r\n          }\r\n        }\r\n\r\n        try {\r\n          if (!_isIE) {\r\n            _s.oMC.appendChild(oMovie);\r\n          }\r\n          oTarget.appendChild(_s.oMC);\r\n          if (_isIE) {\r\n            oEl = _s.oMC.appendChild(_doc.createElement('div'));\r\n            oEl.className = _s.swfCSS.swfBox;\r\n            oEl.innerHTML = movieHTML;\r\n          }\r\n          _appendSuccess = true;\r\n        } catch(e) {\r\n          throw new Error(_str('domError')+' \\n'+e.toString());\r\n        }\r\n\r\n      } else {\r\n\r\n        // SM2 container is already in the document (eg. flashblock use case)\r\n        sClass = _s.oMC.className;\r\n        _s.oMC.className = (sClass?sClass+' ':_s.swfCSS.swfDefault) + (extraClass?' '+extraClass:'');\r\n        _s.oMC.appendChild(oMovie);\r\n        if (_isIE) {\r\n          oEl = _s.oMC.appendChild(_doc.createElement('div'));\r\n          oEl.className = _s.swfCSS.swfBox;\r\n          oEl.innerHTML = movieHTML;\r\n        }\r\n        _appendSuccess = true;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    _didAppend = true;\r\n    _initMsg();\r\n    _s._wD(_smc+'createMovie(): Trying to load ' + smURL + (!_overHTTP && _s.altURL?' (alternate URL)':''), 1);\r\n\r\n    return true;\r\n\r\n  };\r\n\r\n  _initMovie = function() {\r\n\r\n    if (_s.html5Only) {\r\n      _createMovie();\r\n      return false;\r\n    }\r\n\r\n    // attempt to get, or create, movie\r\n    if (_s.o) {\r\n      return false; // may already exist\r\n    }\r\n\r\n    _s.o = _s.getMovie(_s.id); // inline markup\r\n\r\n    if (!_s.o) {\r\n      if (!_oRemoved) {\r\n        // try to create\r\n        _createMovie(_s.id, _s.url);\r\n      } else {\r\n        // try to re-append removed movie after reboot()\r\n        if (!_isIE) {\r\n          _s.oMC.appendChild(_oRemoved);\r\n        } else {\r\n          _s.oMC.innerHTML = _oRemovedHTML;\r\n        }\r\n        _oRemoved = null;\r\n        _didAppend = true;\r\n      }\r\n      _s.o = _s.getMovie(_s.id);\r\n    }\r\n\r\n    if (_s.o) {\r\n      _wDS('waitEI');\r\n    }\r\n\r\n    if (_s.oninitmovie instanceof Function) {\r\n      setTimeout(_s.oninitmovie, 1);\r\n    }\r\n\r\n    return true;\r\n\r\n  };\r\n\r\n  _delayWaitForEI = function() {\r\n    setTimeout(_waitForEI, 1000);\r\n  };\r\n\r\n  _waitForEI = function() {\r\n\r\n    if (_waitingForEI) {\r\n      return false;\r\n    }\r\n\r\n    _waitingForEI = true;\r\n    _event.remove(_win, 'load', _delayWaitForEI);\r\n\r\n    if (_tryInitOnFocus && !_isFocused) {\r\n      // giant Safari 3.1 hack - assume mousemove = focus given lack of focus event\r\n      _wDS('waitFocus');\r\n      return false;\r\n    }\r\n\r\n    var p;\r\n    if (!_didInit) {\r\n      p = _s.getMoviePercent();\r\n      _s._wD(_str('waitImpatient', (p === 100?' (SWF loaded)':(p > 0?' (SWF ' + p + '% loaded)':''))));\r\n    }\r\n\r\n    setTimeout(function() {\r\n\r\n      p = _s.getMoviePercent();\r\n\r\n      if (!_didInit) {\r\n        _s._wD(_sm + ': No Flash response within expected time.\\nLikely causes: ' + (p === 0?'Loading ' + _s.movieURL + ' may have failed (and/or Flash ' + _fV + '+ not present?), ':'') + 'Flash blocked or JS-Flash security error.' + (_s.debugFlash?' ' + _str('checkSWF'):''), 2);\r\n        if (!_overHTTP && p) {\r\n          _wDS('localFail', 2);\r\n          if (!_s.debugFlash) {\r\n            _wDS('tryDebug', 2);\r\n          }\r\n        }\r\n        if (p === 0) {\r\n          // if 0 (not null), probably a 404.\r\n          _s._wD(_str('swf404', _s.url));\r\n        }\r\n        _debugTS('flashtojs', false, ': Timed out' + _overHTTP?' (Check flash security or flash blockers)':' (No plugin/missing SWF?)');\r\n      }\r\n\r\n      // give up / time-out, depending\r\n      if (!_didInit && _okToDisable) {\r\n        if (p === null) {\r\n          // SWF failed. Maybe blocked.\r\n          if (_s.useFlashBlock || _s.flashLoadTimeout === 0) {\r\n            if (_s.useFlashBlock) {\r\n              _flashBlockHandler();\r\n            }\r\n            _wDS('waitForever');\r\n          } else {\r\n            // old SM2 behaviour, simply fail\r\n            _failSafely(true);\r\n          }\r\n\r\n        } else {\r\n          // flash loaded? Shouldn't be a blocking issue, then.\r\n          if (_s.flashLoadTimeout === 0) {\r\n             _wDS('waitForever');\r\n          } else {\r\n            _failSafely(true);\r\n          }\r\n        }\r\n      }\r\n\r\n    }, _s.flashLoadTimeout);\r\n\r\n  };\r\n\r\n  _handleFocus = function() {\r\n    function cleanup() {\r\n      _event.remove(_win, 'focus', _handleFocus);\r\n      _event.remove(_win, 'load', _handleFocus);\r\n    }\r\n    if (_isFocused || !_tryInitOnFocus) {\r\n      cleanup();\r\n      return true;\r\n    }\r\n    _okToDisable = true;\r\n    _isFocused = true;\r\n    _s._wD(_smc+'handleFocus()');\r\n    if (_isSafari && _tryInitOnFocus) {\r\n      _event.remove(_win, 'mousemove', _handleFocus);\r\n    }\r\n    // allow init to restart\r\n    _waitingForEI = false;\r\n    cleanup();\r\n    return true;\r\n  };\r\n\r\n  _initComplete = function(bNoDisable) {\r\n    if (_didInit) {\r\n      return false;\r\n    }\r\n    if (_s.html5Only) {\r\n      // all good.\r\n      _s._wD('-- SoundManager 2: loaded --');\r\n      _didInit = true;\r\n      _initUserOnload();\r\n      _debugTS('onload', true);\r\n      return true;\r\n    }\r\n    var wasTimeout = (_s.useFlashBlock && _s.flashLoadTimeout && !_s.getMoviePercent()),\r\n        error;\r\n    if (!wasTimeout) {\r\n      _didInit = true;\r\n      if (_disabled) {\r\n        error = {type: (!_hasFlash && _needsFlash ? 'NO_FLASH' : 'INIT_TIMEOUT')};\r\n      }\r\n    }\r\n    _s._wD('-- SoundManager 2 ' + (_disabled?'failed to load':'loaded') + ' (' + (_disabled?'security/load error':'OK') + ') --', 1);\r\n    if (_disabled || bNoDisable) {\r\n      if (_s.useFlashBlock && _s.oMC) {\r\n        _s.oMC.className = _getSWFCSS() + ' ' + (_s.getMoviePercent() === null?_s.swfCSS.swfTimedout:_s.swfCSS.swfError);\r\n      }\r\n      _processOnEvents({type:'ontimeout', error:error});\r\n      _debugTS('onload', false);\r\n      _catchError(error);\r\n      return false;\r\n    } else {\r\n      _debugTS('onload', true);\r\n    }\r\n    _event.add(_win, 'unload', _doNothing); // prevent browser from showing cached state via back button, because flash will be dead\r\n    if (_s.waitForWindowLoad && !_windowLoaded) {\r\n      _wDS('waitOnload');\r\n      _event.add(_win, 'load', _initUserOnload);\r\n      return false;\r\n    } else {\r\n      if (_s.waitForWindowLoad && _windowLoaded) {\r\n        _wDS('docLoaded');\r\n      }\r\n      _initUserOnload();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  _showSupport = function() {\r\n\r\n    var item, tests = [];\r\n    if (_s.useHTML5Audio && _s.hasHTML5) {\r\n      for (item in _s.audioFormats) {\r\n        if (_s.audioFormats.hasOwnProperty(item)) {\r\n          tests.push(item + ': ' + _s.html5[item] + (!_s.html5[item] && _hasFlash && _s.flash[item] ? ' (using flash)' : (_s.preferFlash && _s.flash[item] && _hasFlash ? ' (preferring flash)': (!_s.html5[item] ? ' (' + (_s.audioFormats[item].required ? 'required, ':'') + 'and no flash support)' : ''))));\r\n        }\r\n      }\r\n      _s._wD('-- SoundManager 2: HTML5 support tests ('+_s.html5Test+'): '+tests.join(', ')+' --',1);\r\n    }\r\n\r\n  };\r\n\r\n  _init = function() {\r\n\r\n    _wDS('init');\r\n\r\n    // called after onload()\r\n    if (_didInit) {\r\n      _wDS('didInit');\r\n      return false;\r\n    }\r\n\r\n    function _cleanup() {\r\n      _event.remove(_win, 'load', _s.beginDelayedInit);\r\n    }\r\n\r\n    if (_s.html5Only) {\r\n      if (!_didInit) {\r\n        // we don't need no steenking flash!\r\n        _cleanup();\r\n        _s.enabled = true;\r\n        _initComplete();\r\n      }\r\n      return true;\r\n    }\r\n\r\n    // flash path\r\n    _initMovie();\r\n\r\n    try {\r\n      _wDS('flashJS');\r\n      _s.o._externalInterfaceTest(false); // attempt to talk to Flash\r\n      if (!_s.allowPolling) {\r\n        _wDS('noPolling', 1);\r\n      } else {\r\n        _setPolling(true, (_s.flashPollingInterval || (_s.useFastPolling ? 10 : 50)));\r\n      }\r\n      if (!_s.debugMode) {\r\n        _s.o._disableDebug();\r\n      }\r\n      _s.enabled = true;\r\n      _debugTS('jstoflash', true);\r\n    } catch(e) {\r\n      _s._wD('js/flash exception: ' + e.toString());\r\n      _debugTS('jstoflash', false);\r\n      _catchError({type:'JS_TO_FLASH_EXCEPTION', fatal:true});\r\n      _failSafely(true); // don't disable, for reboot()\r\n      _initComplete();\r\n      return false;\r\n    }\r\n\r\n    _initComplete();\r\n    // event cleanup\r\n    _cleanup();\r\n    return true;\r\n\r\n  };\r\n\r\n  _dcLoaded = function() {\r\n    if (_didDCLoaded) {\r\n      return false;\r\n    }\r\n    _didDCLoaded = true;\r\n    _initDebug();\r\n\r\n    /*\r\n     * Temporary feature: allow force of HTML5 via URL params: sm2-usehtml5audio=0 or 1\r\n     * Ditto for sm2-preferFlash, too.\r\n    */\r\n    // <d>\r\n    (function(){\r\n      var a = 'sm2-usehtml5audio=', l = _wl.toLowerCase(), b = null,\r\n      a2 = 'sm2-preferflash=', b2 = null, hasCon = (typeof console !== 'undefined' && typeof console.log !== 'undefined');\r\n      if (l.indexOf(a) !== -1) {\r\n        b = (l.charAt(l.indexOf(a)+a.length) === '1');\r\n        if (hasCon) {\r\n          console.log((b?'Enabling ':'Disabling ')+'useHTML5Audio via URL parameter');\r\n        }\r\n        _s.useHTML5Audio = b;\r\n      }\r\n      if (l.indexOf(a2) !== -1) {\r\n        b2 = (l.charAt(l.indexOf(a2)+a2.length) === '1');\r\n        if (hasCon) {\r\n          console.log((b2?'Enabling ':'Disabling ')+'preferFlash via URL parameter');\r\n        }\r\n        _s.preferFlash = b2;\r\n      }\r\n    }());\r\n    // </d>\r\n\r\n    if (!_hasFlash && _s.hasHTML5) {\r\n      _s._wD('SoundManager: No Flash detected'+(!_s.useHTML5Audio?', enabling HTML5.':'. Trying HTML5-only mode.'));\r\n      _s.useHTML5Audio = true;\r\n      // make sure we aren't preferring flash, either\r\n      // TODO: preferFlash should not matter if flash is not installed. Currently, stuff breaks without the below tweak.\r\n      _s.preferFlash = false;\r\n    }\r\n\r\n    _testHTML5();\r\n    _s.html5.usingFlash = _featureCheck();\r\n    _needsFlash = _s.html5.usingFlash;\r\n\r\n    _showSupport();\r\n\r\n    if (!_hasFlash && _needsFlash) {\r\n      _s._wD('SoundManager: Fatal error: Flash is needed to play some required formats, but is not available.');\r\n      // TODO: Fatal here vs. timeout approach, etc.\r\n      _s.flashLoadTimeout = 1; // hack: fail sooner.\r\n    }\r\n\r\n    if (_doc.removeEventListener) {\r\n      _doc.removeEventListener('DOMContentLoaded', _dcLoaded, false);\r\n    }\r\n    _initMovie();\r\n    return true;\r\n  };\r\n\r\n  _dcIE = function() {\r\n    if (_doc.readyState === 'complete') {\r\n      _dcLoaded();\r\n      _doc.detachEvent('onreadystatechange', _dcIE);\r\n    }\r\n    return true;\r\n  };\r\n\r\n  // sniff up-front\r\n  _detectFlash();\r\n\r\n  // focus and window load, init (primarily flash-driven)\r\n  _event.add(_win, 'focus', _handleFocus);\r\n  _event.add(_win, 'load', _handleFocus);\r\n  _event.add(_win, 'load', _delayWaitForEI);\r\n  if (_isSafari && _tryInitOnFocus) {\r\n    _event.add(_win, 'mousemove', _handleFocus); // massive Safari 3.1 focus hack\r\n  }\r\n\r\n  if (_doc.addEventListener) {\r\n    _doc.addEventListener('DOMContentLoaded', _dcLoaded, false);\r\n  } else if (_doc.attachEvent) {\r\n    _doc.attachEvent('onreadystatechange', _dcIE);\r\n  } else {\r\n    // no add/attachevent support - safe to assume no JS -> Flash either\r\n    _debugTS('onload', false);\r\n    _catchError({type:'NO_DOM2_EVENTS', fatal:true});\r\n  }\r\n\r\n  if (_doc.readyState === 'complete') {\r\n    setTimeout(_dcLoaded,100);\r\n  }\r\n\r\n} // SoundManager()\r\n","pre":true},"sdk/jsio/util/underscore.js":{"path":"sdk/jsio/util/underscore.js","friendlyPath":"util.underscore","directory":"sdk/jsio/util/","filename":"underscore.js","src":"//     Underscore.js 1.2.1\n//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n(function() {\n\n  // Baseline setup\n  // --------------\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice = ArrayProto.slice,\n      unshift = ArrayProto.unshift,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n  nativeForEach = ArrayProto.forEach,\n      nativeMap = ArrayProto.map,\n      nativeReduce = ArrayProto.reduce,\n      nativeReduceRight = ArrayProto.reduceRight,\n      nativeFilter = ArrayProto.filter,\n      nativeEvery = ArrayProto.every,\n      nativeSome = ArrayProto.some,\n      nativeIndexOf = ArrayProto.indexOf,\n      nativeLastIndexOf = ArrayProto.lastIndexOf,\n      nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    return new wrapper(obj);\n  };\n\n  // Export the Underscore object for **Node.js** and **\"CommonJS\"**, with\n  // backwards-compatibility for the old `require()` API. If we're not in\n  // CommonJS, add `_` to the global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else if (typeof define === 'function' && define.amd) {\n    // Register as a named module with AMD.\n    define('underscore', function() {\n      return _;\n    });\n  } else {\n    // Exported as a string, for Closure Compiler \"advanced\" mode.\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.2.1';\n\n  // Collection Functions\n  // --------------------\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = memo !== void 0;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(\"Reduce of empty array with no initial value\");\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();\n    return _.reduce(reversed, iterator, memo, context);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator = iterator || _.identity;\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result |= iterator.call(context, value, index, list)) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      if (value === target) return true;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (method.call ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value) {\n      return value[key];\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {\n      computed: -Infinity\n    };\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {\n      computed: Infinity\n    };\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [],\n        rand;\n    each(obj, function(value, index, list) {\n      if (index == 0) {\n        shuffled[0] = value;\n      } else {\n        rand = Math.floor(Math.random() * (index + 1));\n        shuffled[index] = shuffled[rand];\n        shuffled[rand] = value;\n      }\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria,\n          b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) {\n      return obj[val];\n    };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0,\n        high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable) return [];\n    if (iterable.toArray) return iterable.toArray();\n    if (_.isArray(iterable)) return slice.call(iterable);\n    if (_.isArguments(iterable)) return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, array.length - n) : array[array.length - 1];\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value) {\n      return !!value;\n    });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var result = [];\n    _.reduce(initial, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {\n        memo[memo.length] = el;\n        result[result.length] = array[i];\n      }\n      return memo;\n    }, []);\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and another.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array, other) {\n    return _.filter(array, function(value) {\n      return !_.include(other, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while (idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n  // Reusable constructor function for prototype setting.\n  var ctor = function() {};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) {\n      obj[f] = _.bind(obj[f], obj);\n    });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return hasOwnProperty.call(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function() {\n      return func.apply(func, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var timeout, context, args, throttling, finishThrottle;\n    finishThrottle = _.debounce(function() {\n      throttling = false;\n    }, wait);\n    return function() {\n      context = this;\n      args = arguments;\n      var throttler = function() {\n        timeout = null;\n        func.apply(context, args);\n        finishThrottle();\n      };\n      if (!timeout) timeout = setTimeout(throttler, wait);\n      if (!throttling) func.apply(context, args);\n      if (finishThrottle) finishThrottle();\n      throttling = true;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds.\n  _.debounce = function(func, wait) {\n    var timeout;\n    return function() {\n      var context = this,\n          args = arguments;\n      var throttler = function() {\n        timeout = null;\n        func.apply(context, args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(throttler, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false,\n        memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = slice.call(arguments);\n    return function() {\n      var args = slice.call(arguments);\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys ||\n  function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (source[prop] !== void 0) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n\n\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if ((a == null) || (b == null)) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (_.isFunction(a.isEqual)) return a.isEqual(b);\n    if (_.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare object types.\n    var typeA = typeof a;\n    if (typeA != typeof b) return false;\n    // Optimization; ensure that both values are truthy or falsy.\n    if (!a != !b) return false;\n    // `NaN` values are equal.\n    if (_.isNaN(a)) return _.isNaN(b);\n    // Compare string objects by value.\n    var isStringA = _.isString(a),\n        isStringB = _.isString(b);\n    if (isStringA || isStringB) return isStringA && isStringB && String(a) == String(b);\n    // Compare number objects by value.\n    var isNumberA = _.isNumber(a),\n        isNumberB = _.isNumber(b);\n    if (isNumberA || isNumberB) return isNumberA && isNumberB && +a == +b;\n    // Compare boolean objects by value. The value of `true` is 1; the value of `false` is 0.\n    var isBooleanA = _.isBoolean(a),\n        isBooleanB = _.isBoolean(b);\n    if (isBooleanA || isBooleanB) return isBooleanA && isBooleanB && +a == +b;\n    // Compare dates by their millisecond values.\n    var isDateA = _.isDate(a),\n        isDateB = _.isDate(b);\n    if (isDateA || isDateB) return isDateA && isDateB && a.getTime() == b.getTime();\n    // Compare RegExps by their source patterns and flags.\n    var isRegExpA = _.isRegExp(a),\n        isRegExpB = _.isRegExp(b);\n    if (isRegExpA || isRegExpB) {\n      // Ensure commutative equality for RegExps.\n      return isRegExpA && isRegExpB && a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n    }\n    // Ensure that both values are objects.\n    if (typeA != 'object') return false;\n    // Arrays or Arraylikes with different lengths are not equal.\n    if (a.length !== b.length) return false;\n    // Objects with different constructors are not equal.\n    if (a.constructor !== b.constructor) return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0,\n        result = true;\n    // Deep compare objects.\n    for (var key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        // Count the expected number of properties.\n        size++;\n        // Deep compare each member.\n        if (!(result = hasOwnProperty.call(b, key) && eq(a[key], b[key], stack))) break;\n      }\n    }\n    // Ensure that both objects contain the same number of properties.\n    if (result) {\n      for (key in b) {\n        if (hasOwnProperty.call(b, key) && !size--) break;\n      }\n      result = !size;\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray ||\n  function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  if (toString.call(arguments) == '[object Arguments]') {\n    _.isArguments = function(obj) {\n      return toString.call(obj) == '[object Arguments]';\n    };\n  } else {\n    _.isArguments = function(obj) {\n      return !!(obj && hasOwnProperty.call(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Utility Functions\n  // -----------------\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return ('' + string).replace(/&(?!\\w+;|#\\d+;|#x[\\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' + 'with(obj||{}){__p.push(\\'' + str.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(c.escape, function(match, code) {\n      return \"',_.escape(\" + code.replace(/\\\\'/g, \"'\") + \"),'\";\n    }).replace(c.interpolate, function(match, code) {\n      return \"',\" + code.replace(/\\\\'/g, \"'\") + \",'\";\n    }).replace(c.evaluate || null, function(match, code) {\n      return \"');\" + code.replace(/\\\\'/g, \"'\").replace(/[\\r\\n\\t]/g, ' ') + \"__p.push('\";\n    }).replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/\\t/g, '\\\\t') + \"');}return __p.join('');\";\n    var func = new Function('obj', tmpl);\n    return data ? func(data) : func;\n  };\n\n  // The OOP Wrapper\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) {\n    this._wrapped = obj;\n  };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      method.apply(this._wrapped, arguments);\n      return result(this._wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n})();","pre":true},"sdk/timestep/platforms/browser/initialize.js":{"path":"sdk/timestep/platforms/browser/initialize.js","friendlyPath":"platforms.browser.initialize","directory":"sdk/timestep/platforms/browser/","filename":"initialize.js","baseMod":"platforms","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import device\");\njsio(\"from util.browser import $\");\n\ndevice.registerDevice('browser', 'platforms.browser');\nexports.init = function () {\n\n\tvar onResize;\n\n\tif (device.isMobileBrowser) {\n\t\tdevice.setUseDOM(true);\n\n\t\tvar screen = device.screen;\n\t\tif (device.isIOS || device.isAndroid) {\n\t\t\t\n\t\t\tvar _isFocused = false;\n\t\t\twindow.addEventListener('focus', function(e) {\n\t\t\t\tvar tag = e.target.tagName;\n\t\t\t\tif (tag == 'TEXTAREA' || tag == 'INPUT') {\n\t\t\t\t\t_isFocused = true;\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\t\n\t\t\tdocument.addEventListener('blur', function(e) {\n\t\t\t\tif (_isFocused) {\n\t\t\t\t\t_isFocused = false;\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\t\n\t\t\tdevice.hideAddressBar = function() {\n\t\t\t\tif (_isFocused || !device.isMobileBrowser || !(device.isIOS || device.isAndroid)) { return; }\n\t\t\t\tif (device.isIOS) {\n\t\t\t\t\twindow.scrollTo(0, 1);\n\t\t\t\t\twindow.scrollTo(0, 0);\n\t\t\t\t} else {\n\t\t\t\t\twindow.scrollTo(0, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!CONFIG.unlockViewport) {\n\t\t\t\twindow.addEventListener('touchstart', bind(device, 'hideAddressBar'), true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar lastWidth, lastHeight, lastOrientation;\n\t\tonResize = function() {\n\t\t\tif (device.isIOS) {\n\t\t\t\tdevice.hideAddressBar();\n\t\t\t}\n\t\t\t\n\t\t\tvar w = window.outerWidth;\n\t\t\tvar h = window.outerHeight;\n\t\t\tvar o = window.orientation;\n\t\t\tif (lastWidth == w && lastHeight == h && lastOrientation == o) { return; }\n\t\t\t\n\t\t\tlastWidth = w;\n\t\t\tlastHeight = h;\n\t\t\tlastOrientation = o;\n\t\t\t\n\t\t\tvar isPortrait = screen.isPortrait = (h > w);\n\t\t\tvar isLandscape = screen.isLandscape = !screen.isPortrait;\n\t\t\t\n\t\t\tvar totalW = (isPortrait ? screen.width : screen.height);\n\t\t\tvar totalH = (isPortrait ? screen.height : screen.width);\n\t//\t\tdocument.body.style.height = Math.max(screen.width, screen.height) + 'px';\n\t//\t\tdevice.hideAddressBar();\n\n\t\t\tvar innerWidth = window.innerWidth;\n\t\t\tvar innerHeight = window.innerHeight;\n\t\t\tif (device.width != innerWidth || device.height != innerHeight || device.orientation != o) {\n\t\t\t\tdevice.width = innerWidth;\n\t\t\t\tdevice.height = innerHeight;\n\t\t\t\tdevice.orientation = o;\n\t\t\t\tdevice.screen.publish('Resize', device.width, device.height, device.orientation);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tonResize = function() {\n\t\t\tvar doc = window.document,\n\t\t\t\twidth = window.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\t\theight = window.innerHeight || (doc.clientHeight || doc.clientHeight);\n\t\t\t\n\t\t\tif (width != device.width || height != device.height) {\n\t\t\t\tdevice.width = width;\n\t\t\t\tdevice.height = height;\n\t\t\t\tdevice.screen.width = width;\n\t\t\t\tdevice.screen.height = height;\n\n\t\t\t\tif (width > height) {\n\t\t\t\t\tdevice.screen.isPortrait = false;\n\t\t\t\t\tdevice.screen.isLandscape = true;\n\t\t\t\t\tdevice.screen.orientation = 'landscape';\n\t\t\t\t} else {\n\t\t\t\t\tdevice.screen.isPortrait = true;\n\t\t\t\t\tdevice.screen.isLandscape = false;\n\t\t\t\t\tdevice.screen.orientation = 'portrait';\n\t\t\t\t}\n\n\t\t\t\tdevice.screen.publish('Resize', width, height);\n\t\t\t}\n\t\t}\n\t}\n\n\t$.onEvent(window, 'resize', onResize, false);\n\t$.onEvent(window, 'orientationchange', onResize, false);\n\n\tonResize();\n};\n","pre":true},"sdk/timestep/platforms/browser/Input.js":{"path":"sdk/timestep/platforms/browser/Input.js","friendlyPath":".Input","directory":"sdk/timestep/platforms/browser/","filename":"Input.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package timestep.env.browser.Input;\n *\n * This is imported as timestep.input.InputListener. This binds touch or mouse\n * events on the document (depending on what's specified in device). \n * Additionally, if a canvas option is passed in or setElement(el) is called,\n * mouse over/out and start events are attached to the element. Used on the\n * canvas as well as DOM bindings.\n */\n\njsio(\"import device\");\njsio(\"from util.browser import $\");\n\njsio(\"import event.input.dispatch as input\");\nvar eventTypes = input.eventTypes;\n\n// import ...FPSCounter;\n\nvar UID = -1;\n\nvar sdk_timestep_platforms_browser_Input=__class__;exports=sdk_timestep_platforms_browser_Input(function sdk_timestep_platforms_browser_Input(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\t\n\tthis.init = function(opts) {\n\n\t\tif (device.simulatingMobileNative || device.simulatingMobileBrowser) { this._simulateMobile = true; }\n\t\t\n\t\tthis._evtQueue = [];\n\t\t\n\t\tif (opts.el) {\n\t\t\tif (device.isMobileBrowser) {\n\t\t\t\tthis._toggleNode = $({parent:document.body});\n\t\t\t}\n\t\t\tthis.setElement(opts.el);\n\t\t}\n\n\t\t// Mouseover/out events do not fire for mobile browsers\n\t\t// that are driven solely by touch events, so in mobile\n\t\t// browsers, assume the canvas should always handle events.\n\t\t// Otherwise, only handle events if the mouse is over the\n\t\t// canvas.\n\t\tthis._isOver = false;\n\n\t\t// disable the key listener on focus of input elements\n\t\tthis._keyListener = opts.keyListener;\n\n\t\tif (device.useDOM) {\n\t\t\t$.onEvent(document, device.events.start, this, 'handleMouse', eventTypes.START);\n\t\t}\n\t\t\n\t\tthis.enable();\n\t\t\n\t\t// this._evtFps = new FPSCounter({name: \"mouse events\"});\n\t\t\n\t\tthis._hasFocus = false;\n\t\tif (document.addEventListener) {\n\t\t\tdocument.addEventListener('focus', bind(this, 'onFocusCapture'), true);\n\t\t\tdocument.addEventListener('blur', bind(this, 'onBlurCapture'), true);\n\t\t}\n\t}\n\n\tthis.enable = function() {\n\t\tthis._handleMove = $.onEvent(document, device.events.move, this, 'handleMouse', eventTypes.MOVE);\n\t\tthis._handleSelect = $.onEvent(document, device.events.end, this, 'handleMouse', eventTypes.SELECT);\n\t\tthis._handleScroll = $.onEvent(window, 'DOMMouseScroll', this, 'handleMouse', eventTypes.SCROLL); // FF\n\t\tthis._handleWheel = $.onEvent(window, 'mousewheel', this, 'handleMouse', eventTypes.SCROLL); // webkit\n\t};\n\n\tthis.disable = function() {\n\t\tif (this._handleMove) {\n\t\t\tthis._handleMove();\n\t\t\tthis._handleMove = false;\n\t\t}\n\t\tif (this._handleSelect) {\n\t\t\tthis._handleSelect();\n\t\t\tthis._handleSelect = false;\n\t\t}\n\t\tif (this._handleScroll) {\n\t\t\tthis._handleScroll();\n\t\t\tthis._handleScroll = false;\n\t\t}\n\t\tif (this._handleWheel) {\n\t\t\tthis._handleWheel();\n\t\t\tthis._handleWheel = false;\n\t\t}\n\t};\n\t\n\tthis.onFocusCapture = function(e) {\n\t\tvar tag = e.target.tagName;\n\t\tif (tag == 'TEXTAREA' || tag == 'INPUT') {\n\t\t\tthis._hasFocus = e.target;\n\t\t\tthis._keyListener && this._keyListener.setEnabled(false);\n\t\t}\n\t}\n\t\n\tthis.onBlurCapture = function(e) {\n\t\tif (this._hasFocus) {\n\t\t\tthis._hasFocus = null;\n\t\t\tthis._keyListener && this._keyListener.setEnabled(true);\n\t\t}\n\t}\n\t\n\tthis.setElement = function(el) {\n\t\tthis._el = el;\n\t\t\n\t\tif (this._elEvents) {\n\t\t\tfor(var i = 0, detach; detach = this._elEvents[i]; ++i) {\n\t\t\t\tdetach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tel.ondragstart = function() { return false; }\n\t\tel.onselectstart = function() { return false; }\n\t\t\n\t\tthis._elEvents = [];\n\t\t\n\t\tif (!device.useDOM) {\n\t\t\tthis._elEvents.push($.onEvent(el, device.events.start, this, 'handleMouse', eventTypes.START));\n\t\t}\n\t\t\n\t\tif (!device.isMobileBrowser && !device.isNative) {\n\t\t\tthis._elEvents.push($.onEvent(el, 'mouseover', this, 'onMouseOver'));\n\t\t\tthis._elEvents.push($.onEvent(el, 'mouseout', this, 'onMouseOut'));\n\t\t}\n\t}\n\t\n\tthis.onMouseOver = function() { this._isOver = true; }\n\tthis.onMouseOut = function() { this._isOver = false; }\n\tthis.onMouseDown = function() { this._isMouseDown = true; }\n\tthis.onMouseUp = function() { this._isMouseUp = true; }\n\t\n\tthis.getEvents = function() { return this._evtQueue.splice(0, this._evtQueue.length); }\n\t\n\tthis.allowScrollEvents = function(allowScrollEvents) { this._allowScrollEvents = allowScrollEvents; }\n\t\n\tvar empty = function() {};\n\n\tthis.handleMouse = function(type, evt, recursive) {\n\t\tvar target = evt.target;\n\t\tif (this._hasFocus && this._hasFocus == target || target && target.getAttribute && target.getAttribute('noCapture')) { return; }\n\t\t\n\t\t// if (!recursive) {\n\t\t// \t// remove the empty callback to log the raw mouse event fps\n\t\t// \tthis._evtFps.tick(empty);\n\t\t// }\n\t\t\n\t\tvar isMobileBrowser = device.isMobileBrowser;\n\t\t\n\t\tif (!device.useDOM && !isMobileBrowser && !this._isDown && this._el && evt.target != this._el) { return; }\n\t\t\n\t\t// Cancel all events that occur on the canvas.  Optionally, pass scroll events\n\t\t// through to the page (apps that don't care about handling scroll events may\n\t\t// want to pass them through for easier browser debugging).\n\t\tif (isMobileBrowser) {\n\t\t\t$.stopEvent(evt);\n\t\t\tevt.returnValue = false;\n\t\t} else if (this._isOver && (!this._allowScrollEvents || type != eventTypes.SCROLL)) {\n\t\t\tif (evt.stopPropagation) { evt.stopPropagation(); }\n\t\t\tif (type != eventTypes.START) {\n\t\t\t\t$.stopEvent(evt);\n\t\t\t\tevt.returnValue = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// On ios devices, this event could correspond to multiple touches.  We recall\n\t\t// ourselves with each changed touch independently.\n\t\tif (evt.touches) {\n\t\t\tfor (var i = 0, t; t = evt.changedTouches[i]; ++i) {\n\t\t\t\tthis.handleMouse(type, t, true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar x, y;\n\t\t// Figure out where in the canvas the event fired.\n\t\t// if (isMobileBrowser) {\n\t\t// \tpt = {\n\t\t// \t\tx: evt.pageX,\n\t\t// \t\ty: evt.pageY\n\t\t// \t};\n\t\t// } else \n\t\tif ('offsetX' in evt && !device.useDOM) {\n\t\t\t// Chrome makes life easy.  offsetX/offsetY is w.r.t. the target, which\n\t\t\t// for us should be the canvas.\n\t\t\tx = evt.offsetX;\n\t\t\ty = evt.offsetY;\n\t\t} else if (this._el.getBoundingClientRect) {\n\t\t\t// It's not too hard in other browsers that support getBoundingClientRect.\n\t\t\t// Get the absolute position of the canvas and do the math.\n\t\t\tvar rect = this._el.getBoundingClientRect();\n\t\t\tx = evt.pageX - rect.left;\n\t\t\ty = evt.pageY - rect.top;\n\t\t} else {\n\t\t\t// Without boundingClientRect, life is hard.  This is the general\n\t\t\t// idea, but we need to loop for offsetParent/scrollLeft/scrollTop\n\t\t\t// to be at least partially complete.  Other libraries handle this\n\t\t\t// better, but the code complexity for that is huge.\n\t\t\t// \n\t\t\t// TODO: older browsers will fail cause this code is buggy and untested?\n\t\t\tvar offsetX, offsetY, parent = this._el;\n\t\t\twhile (parent) {\n\t\t\t\toffsetX += parent.offsetTop;\n\t\t\t\toffsetY += parent.offsetLeft;\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\tx = evt.pageX - offsetX;\n\t\t\ty = evt.pageY - offsetY;\n\t\t}\n\t\t\n\t\tvar id = evt.identifier || UID;\n\t\t\n\t\tif (this._simulateMobile) {\n\t\t\tswitch (type) {\n\t\t\t\tcase eventTypes.START:\n\t\t\t\t\tthis._moveOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase eventTypes.MOVE:\n\t\t\t\t\tif (!this._moveOK) { return; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase eventTypes.SELECT:\n\t\t\t\t\tthis._moveOK = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (type == eventTypes.START) {\n\t\t\tthis._isDown = true;\n\t\t} else if (type == eventTypes.SELECT) {\n\t\t\tthis._isDown = false;\n\t\t\t\n\t\t\tif (this._toggleNode) {\n\t\t\t\tdocument.body.removeChild(this._toggleNode);\n\t\t\t\tdocument.body.appendChild(this._toggleNode);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar inputEvent = new input.InputEvent(id, type, x, y);\n\t\tif (device.useDOM) {\n\t\t\twhile (target && !target._view) {\n\t\t\t\ttarget = target.parentNode;\n\t\t\t}\n\t\t\tif (!target) { return; }\n\t\t\tinputEvent.target = target._view;\n\t\t}\n\t\t\n\t\tif (type == eventTypes.SCROLL) {\n\t\t\t// try to normalize scroll events! :-(\n\t\t\t\n\t\t\t// some browsers send both horizontal and vertical offsets in one event! nice!\n\t\t\t// other browsers don't. This is awful, since this is the least common denominator!\n\t\t\t// so we have to send two events even if the browser only sends one.\n\t\t\tif ('wheelDeltaX' in evt) {\n\t\t\t\t// default to Y\n\t\t\t\tinputEvent.scrollDelta = evt.wheelDeltaY / 120;\n\t\t\t\tinputEvent.scrollAxis = input.VERTICAL_AXIS;\n\n\t\t\t\t// if we also have X, then send it as a separate event\n\t\t\t\tif (evt.wheelDeltaX && evt.wheelDeltaY) {\n\t\t\t\t\tvar e = inputEvent.clone();\n\t\t\t\t\te.scrollDelta = evt.wheelDeltaX / 120;\n\t\t\t\t\te.scrollAxis = input.HORIZONTAL_AXIS;\n\t\t\t\t\tthis._evtQueue.push(e);\n\t\t\t\t} else if (evt.wheelDeltaX) {\n\t\t\t\t\t// we only have one of (X, Y) and it's X, so use X\n\t\t\t\t\tinputEvent.scrollDelta = evt.wheelDeltaX / 120;\n\t\t\t\t\tinputEvent.scrollAxis = input.HORIZONTAL_AXIS;\n\t\t\t\t}\n\n\t\t\t} else if (evt.detail) {\n\t\t\t\tinputEvent.scrollDelta = -evt.detail;\n\t\t\t\tinputEvent.scrollAxis = 'axis' in evt ? evt.axis == evt.VERTICAL_AXIS ? input.VERTICAL_AXIS : input.HORIZONTAL_AXIS : input.VERTICAL_AXIS;\n\t\t\t} else if (evt.wheelDelta) { // IE/Opera\n\t\t\t\tinputEvent.scrollDelta = (window.opera ? 1 : -1) * evt.wheelDelta / 120;\n\t\t\t\tinputEvent.scrollAxis = input.VERTICAL_AXIS;\n\t\t\t}\n\t\t}\n\n\t\tthis._evtQueue.push(inputEvent);\n\t}\n\t\n});\n","pre":true},"sdk/timestep/platforms/browser/InputPrompt.js":{"path":"sdk/timestep/platforms/browser/InputPrompt.js","friendlyPath":".InputPrompt","directory":"sdk/timestep/platforms/browser/","filename":"InputPrompt.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package timestep.env.browser.InputPrompt;\n *\n * Prompt the user manually for input.\n *\n * ??? TODO Move this to debug, probably. A native modal prompt has no place\n *          in game code.\n */\n\nvar sdk_timestep_platforms_browser_InputPrompt=__class__;exports=sdk_timestep_platforms_browser_InputPrompt(function sdk_timestep_platforms_browser_InputPrompt(){return this.init&&this.init.apply(this,arguments)},function() {\n\tvar defaults = {\n\t\tonChange: function() {},\n\t\ttitle: '',\n\t\tmessage: '',\n\t\tvalue: '',\n\t\tprompt: ''\n\t}\n\n\tthis.init = function (opts) {\n\t\topts = merge(opts, defaults);\n\t\tthis.onChange = opts.onChange;\n\t\tthis._value = opts.value;\n\t\tthis._message = opts.title || opts.message || opts.prompt;\n\t};\n\n\tthis.show = function () {\n\t\tvar value = window.prompt(this._message, this._value);\n\t\tif (value !== null) { // returns null if user presses cancel\n\t\t\tthis._value = value;\n\t\t\tthis.onChange(value);\n\t\t} else {\n\t\t\t// TODO: do something else on cancel?\n\t\t\tthis.onChange(value);\n\t\t}\n\t};\n\n\tthis.getValue = function () {\n\t\treturn this._value;\n\t};\n\n\tthis.setValue = function (value) {\n\t\tthis._value = value;\n\t};\n\n\tthis.setMessage = function (message) {\n\t\tthis._message = message;\n\t};\n});\n","pre":true},"sdk/timestep/platforms/browser/KeyListener.js":{"path":"sdk/timestep/platforms/browser/KeyListener.js","friendlyPath":".KeyListener","directory":"sdk/timestep/platforms/browser/","filename":"KeyListener.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package timestep.env.browser.KeyListener;\n *\n * Listen to pressed keys and expose them using a altogether too public API.\n * An independent KeyListener is exposed for the Application Engine and any\n * Views with a Focus Manager.\n */\n\njsio(\"import lib.PubSub as PubSub\");\njsio(\"import lib.Enum\");\n\njsio(\"import event.input.keys as keyConstants\");\njsio(\"import device\");\njsio(\"import timer\");\n\njsio(\"from util.browser import $\");\n\nvar gListenerSingleton = null;\nvar gCancelKeys = lib.Enum(keyConstants.SPACE, keyConstants.LEFT, keyConstants.RIGHT, keyConstants.UP, keyConstants.DOWN);\n\nvar sdk_timestep_platforms_browser_KeyListener=__class__;exports=sdk_timestep_platforms_browser_KeyListener(function sdk_timestep_platforms_browser_KeyListener(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(el, events) {\n\t\tif (gListenerSingleton) { return gListenerSingleton; }\n\t\tgListenerSingleton = this;\n\t\t\n\t\tthis._el = el = el || document;\n\t\tthis._events = [];\n\t\tthis._shortcuts = [];\n\t\tthis._isEnabled = true;\n\t\tthis._keyMap = {};\n\t\t\n\t\t$.onEvent(el, 'keydown', this, 'onKeyDown');\n\t\t$.onEvent(el, 'keypress', this, 'onKeyPress');\n\t\t$.onEvent(el, 'keyup', this, 'onKeyUp');\n\t\t$.onEvent(window, 'blur', this, 'liftAll');\n\t}\n\t\n\tthis.setEnabled = function(isEnabled) { this._isEnabled = isEnabled; }\n\n\tthis.captureShortcut = function(shortcut) {\n\t\tthis._shortcuts.push(shortcut);\n\t}\n\t\n\tthis.getPressed = function() { return this._keyMap; }\n\n\tthis.onKeyDown = function(e) {\n\t\t\n\t\tif (!this._isEnabled) { return; }\n\t\t\n\t\tvar evt = {\n\t\t\tcode: e.keyCode,\n\t\t\tctrl: e.ctrlKey,\n\t\t\tshift: e.shiftKey,\n\t\t\talt: e.altKey,\n\t\t\tmeta: e.metaKey, // for mac keyboards\n\t\t\tlifted: false,\n\t\t\tdt: timer.getTickProgress()\n\t\t};\n\t\t\n\t\tif (evt.ctrl || evt.shift || evt.alt || evt.meta) {\n\t\t\tvar captured = false;\n\t\t\tfor (var i = 0, s; s = this._shortcuts[i]; ++i) {\n\t\t\t\tif (s.compare(evt)) {\n\t\t\t\t\ts.publish('Down', evt);\n\t\t\t\t\tcaptured = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (captured) { $.stopEvent(e); }\n\t\t\treturn;\n\t\t} else {\n\t\t\t// MUST cancel event if we're enabled to prevent browser\n\t\t\t// default behaviors (e.g. scrolling)\n\t\t\t$.stopEvent(e);\n\t\t}\n\t\t\n\t\t// We already know that key is down; ignore repeat events.\n\t\tif (e.keyCode in this._keyMap) { return; }\n\t\t\n\t\tthis._events.push(evt);\n\t\tthis._keyMap[e.keyCode] = +new Date();\n\t}\n\t\n\tthis.liftAll = function() {\n\t\tvar progressDt = timer.getTickProgress();\n\t\tfor (var code in this._keyMap) {\n\t\t\tthis._events.push({\n\t\t\t\tcode: code,\n\t\t\t\tlifted: true,\n\t\t\t\tdt: progressDt\n\t\t\t});\n\t\t}\n\t\tthis._keyMap = {};\n\t}\n\t\n\tthis.onKeyUp = function(e) {\n\t\tvar progressDt = timer.getTickProgress();\n\t\tdelete this._keyMap[e.keyCode];\n\t\tthis._events.push({\n\t\t\tcode: e.keyCode,\n\t\t\tlifted: true,\n\t\t\tdt: progressDt\n\t\t});\n\t\t$.stopEvent(e);\n\t}\n\t\n\tthis.onKeyPress = function(e) {\n\t\tif (!this._isEnabled) { return; }\n\t\tif (e.keyCode in gCancelKeys) {\n\t\t\t$.stopEvent(e);\n\t\t}\n\t}\n\t\n\tthis.peekEvents = function() { return this._events; }\n\tthis.popEvents = function() { return this._events.splice(0, this._events.length); }\n});\n\n// TODO: for maximum compatibility, especially with foreign keyboards, this needs to be inferred from the browser.  I think we can rely on a single DOM key event to get the constants in most browsers.\nmerge(exports.prototype, keyConstants);\n\nexports.Shortcut=__class__;exports.Shortcut=exports.Shortcut(function exports_Shortcut(){return this.init&&this.init.apply(this,arguments)},PubSub, function() {\n\tthis.init = function(keyCode, ctrl, shift, alt, meta) {\n\t\tthis.ctrl = !!ctrl;\n\t\tthis.shift = !!shift;\n\t\tthis.alt = !!alt;\n\t\tthis.meta = !!meta;\n\t\tthis.code = !!keyCode;\n\t}\n\t\n\tthis.compare = function(shortcut) {\n\t\treturn this.ctrl == shortcut.ctrl \n\t\t\t&& this.alt == shortcut.alt\n\t\t\t&& this.meta == shortcut.meta\n\t\t\t&& this.shift == shortcut.shift\n\t\t\t&& this.code == shortcut.code;\n\t}\n});\n","pre":true},"sdk/timestep/event/input/keys.js":{"path":"sdk/timestep/event/input/keys.js","friendlyPath":"event.input.keys","directory":"sdk/timestep/event/input/","filename":"keys.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @module event.input.keys\n * Map browser keycodes to corresponding keys.\n */\n\nexports = {\n\tBACKSPACE: 8,\n\tTAB: 9,\n\tENTER: 13,\n\tSHIFT: 16,\n\tCTRL: 17,\n\tALT: 18,\n\tPAUSE: 19,\n\tBREAK: 19,\n\tCAPS: 20,\n\tCAPS_LOCK: 20,\n\tESCAPE: 27,\n\tSPACE: 32,\n\tPAGE_UP: 33,\n\tPAGE_DOWN: 34,\n\tEND: 35,\n\tHOME: 36,\n\tLEFT: 37,\n\tUP: 38,\n\tRIGHT: 39,\n\tDOWN: 40,\n\tPRINT_SCREEN: 44,\n\tINSERT: 45,\n\tDELETE: 46,\n\tMETA_LEFT: 91,\n\tWIN_LEFT: 91,\n\tMETA_RIGHT: 92,\n\tWIN_RIGHT: 92,\n\tSELECT: 93,\n\tEQUAL: 187,\n\tMINUS: 189,\n\tF1: 112,\n\tF2: 113,\n\tF3: 114,\n\tF4: 115,\n\tF5: 116,\n\tF6: 117,\n\tF7: 118,\n\tF8: 119,\n\tF9: 120,\n\tF10: 121,\n\tF11: 122,\n\tF12: 123,\n\tMUTE: 173,\n\tVOL_DOWN: 174,\n\tVOL_UP: 175,\n\tFORWARD: 176,\n\tBACK: 177,\n\tSTOP: 178,\n\tPLAY_PAUSE: 179\n};\n","pre":true},"sdk/timestep/platforms/browser/MobileBrowserAPI.js":{"path":"sdk/timestep/platforms/browser/MobileBrowserAPI.js","friendlyPath":".MobileBrowserAPI","directory":"sdk/timestep/platforms/browser/","filename":"MobileBrowserAPI.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"import device\");\njsio(\"from util.underscore import _\");\n\n/**\n * @extends lib.PubSub\n */\nvar sdk_timestep_platforms_browser_MobileBrowserAPI=__class__;var AudioAPI = exports=sdk_timestep_platforms_browser_MobileBrowserAPI(function sdk_timestep_platforms_browser_MobileBrowserAPI(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function(supr) {\n\n\tvar defaults = {\n\t\toneChannelOnly: device.isMobileBrowser,\n\t\tcompiledFilename: 'compiled'\n\t};\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, defaults);\n\t\tsupr(this, 'init', [opts]);\n\t\tthis._opts = opts;\n\t\tthis._map = opts.map;\n\t\tthis._audios = {};\n\t\tthis.oneChannelOnly = opts.oneChannelOnly;\n\n\t\tsetInterval(bind(this, '_ontimeupdate'), 200);\n\t\t\n\t\tif (!this.oneChannelOnly) {\n\t\t\t_.each(opts.background, function(name) {\n\t\t\t\topts.map[name] = {'name': name}\n\t\t\t}, this);\n\t\t}\n\n\t\t// Install the event listener right away. Set usecapture=true so that\n\t\t// nothing else will affect us from intercepting this event.\n\n\t\tthis._load();\n\t\tif (this.oneChannelOnly) {\n\t\t\tthis._boundLoadHandler = bind(this, '_playFirst');\n\t\t\tdocument.body.addEventListener(device.events.start, \n\t\t\t\t\t\t\t\t\t\t   this._boundLoadHandler, true);\n\t\t}\n\t\twindow.addEventListener('pagehide', bind(this, 'pause'), false);\n\t}\n\n\tthis._createChannel = function(name, src) {\n\t\tvar audio = new Audio(src);\n\t\tthis._audios[name] = audio;\n\n\t\taudio.addEventListener('error', bind(this, '_onerror'));\n\t\taudio.addEventListener('timeupdate', bind(this, '_ontimeupdate'));\n\n\t\taudio.load();\n\t}\n\n\tthis.setMuted = function(muted) {\n\t\tthis.muted = muted;\n\t\tif (muted) {\n\t\t\tthis.setVolume(0);\n\t\t}\n\t}\n\t\n\tthis.setVolume = function(volume) {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.volume = volume;\n\t\t});\n\t}\n\n\tthis.unload = function() {\n\t\tthis.pause();\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.src = '';\n\t\t}, this);\n\t\t// TODO remove event listeners\n\t}\n\n\tthis._load = function() {\n\t\n\t\tthis._audios = {};\n\t\tvar path = this._opts.path.replace(/\\/$/, '');\n\t\tif (this.oneChannelOnly) {\n\t\t\tthis._createChannel('AUDIO', path + '/' + this._opts.compiledFilename + '.m4a');\n\t\t} else {\n\t\t\tfor (var key in this._map) if (this._map.hasOwnProperty(key)) {\n\t\t\t\tif (key == 'SILENCE') { continue; }\n\t\t\t\tthis._createChannel(key, path + '/' + key + '.mp3');\n\t\t\t}\n\t\t}\n\n\t\tlogger.info('now loading', this._opts.src);\n\n\t\tif (!this._publishedReady) {\n\t\t\tthis.publish('Ready'); // this is as close as we'll get with multiple sounds\n\t\t\tthis._publishedReady = true;\n\t\t}\n\t}\n\n\tthis._playFirst = function() {\n\t\tdocument.body.removeEventListener(device.events.start, \n\t\t\t\t\t\t\t\t\t\t  this._boundLoadHandler, true);\n\t\t\n\t\tthis._audios['AUDIO'].play();\n\t}\n\n\tthis._ontimeupdate = function(evt) {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\tif (audio.paused && !audio._pausedOnce) {\n\t\t\t\taudio.pause();\n\t\t\t\taudio._pausedOnce = true;\n\t\t\t\taudio._ready = true;\n\t\t\t}\n\n\t\t\tif (this.oneChannelOnly) {\n\t\t\t\tif (!this._nowPlaying || audio.currentTime >= this._nowPlaying.end) {\n\t\t\t\t\tthis.play('SILENCE');\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\n\t}\n\t\n\tthis._onerror = function(event) {\n\t\tvar s = '';\n\t\tfor (var key in event) {\n\t\t\ts += event[key] + ' ';\n\t\t}\n\t\tlogger.info('ERROR', s);\n\t\t// this.unload();\n\t\t// this.publish('AudioError', event);\n\t\t// this._status = 'error';\n\t}\n\n\tthis.canPlay = function(name) {\n\t\tif (!this._map[name]) { return false; }\n\n\t\tvar requiredEnd = null;\n\t\tif (this.oneChannelOnly) {\n\t\t\trequiredEnd = this._map[name].end;\n\t\t\tname = 'AUDIO';\n\t\t}\n\t\tvar audio = this._audios[name];\n\t\tif (!audio) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if (!audio._ready) {\n\t\t// \treturn; // try downloading the whole file...\n\t\t// }\n\t\tif (audio._ready || !requiredEnd) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tvar end = audio.seekable.end()\n\t\t\t\treturn (requiredEnd <= end);\n\t\t\t} catch(e) {\n\t\t\t\tlogger.log(e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.play = function(name, volume, loop) {\t\t\n\t\tif (this.muted) { return; }\n\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tif (!this.canPlay(name)) {\n\t\t\tlogger.info('Not ready yet');\n\t\t\treturn;\n\t\t}\n\n\t\tvar audio = this._audios[this.oneChannelOnly ? 'AUDIO' : name];\n\t\ttry {\n\t\t\tif (!audio.paused) {\n\t\t\t\taudio.pause(); // it glitches if you move currentTime while playing?\n\t\t\t}\n\t\t\tvar startTime = 0;\n\t\t\tif (this.oneChannelOnly && this._map[name].start != null) {\n\t\t\t\tstartTime = this._map[name].start;\n\t\t\t}\n\t\t\tif (audio.currentTime != startTime) {\n\t\t\t\t// logger.log('SEEK to play',name, startTime, 'from',audio.currentTime); // \n\t\t\t\taudio.currentTime = startTime;\n\t\t\t}\n\t\t\taudio.volume = volume;\n\t\t\taudio.play();\n\t\t\tthis._nowPlaying = this._map[name];\n\t\t} catch(e) {\n\t\t\t\n\t\t}\n\t}\n\t\n\tthis.pause = function() {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.pause();\n\t\t}, this);\n\t}\n\n\tthis.playBackgroundMusic = function(name, volume) {\n\t\tif (this.muted) { return; }\n\n\t\tif (this.oneChannelOnly) {\n\t\t\treturn false; // cannot play bg music here.\n\t\t}\n\n\t\tthis._backgroundSoundPlaying = name;\n\t\tthis.play(name, volume);\n\t}\n\n\tthis.pauseBackgroundMusic = function() {\n\t\tif (!this._backgroundSoundPlaying) { return; }\n\t\tthis._audios[this._backgroundSoundPlaying].pause();\n\t}\n\n});\n","pre":true},"sdk/timestep/platforms/browser/TextBox.js":{"path":"sdk/timestep/platforms/browser/TextBox.js","friendlyPath":".TextBox","directory":"sdk/timestep/platforms/browser/","filename":"TextBox.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use import\";\n\n/**\n * package timestep.env.browser.TextBox;\n *\n * A textbox for inputting user data.\n */\n\njsio(\"from util.browser import $\");\n\nvar sdk_timestep_platforms_browser_TextBox=__class__;exports=sdk_timestep_platforms_browser_TextBox(function sdk_timestep_platforms_browser_TextBox(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\tvar defaultStyle = {\n\t\tpadding: 0,\n\t\tlineHeight: 1.4,\n\t\tborder: 'none',\n\t\tdisplay: 'none',\n\t\ttextAlign: 'center',\n\t\tverticalAlign: 'middle',\n\t\tfontSize: 16,\n\t\tfontFamily: null,\n\t\tfontWeight: '',\n\t\topacity: 1,\n\t\tposition: \"absolute\",\n\t\tbackgroundColor: \"transparent\",\n\t\ttop: 0,\n\t\tleft: 0\n\t};\n\t\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\tcolor: 'black',\n\t\t\theight: 20\n\t\t});\n\n\t\tvar style = merge({}, defaultStyle);\n\t\tif (opts.color) { style.color = opts.color; }\n\t\t\n\t\tthis._el = $({\n\t\t\ttag: opts.multiLine ? \"textarea\" : \"input\",\n\t\t\tattrs: {type: \"text\"}, \n\t\t\tstyle: style\n\t\t});\n\n\t\t$.onEvent(this._el, 'blur', this, 'onBlur');\n\t\t$.onEvent(this._el, 'focus', this, 'onFocus');\n\t\t$.onEvent(this._el, 'change', this, 'onChange');\n\t\t$.onEvent(this._el, 'click', this, 'onClick');\n\t}\n\t\n\tthis.onBlur = \n\tthis.onFocus =\n\tthis.onChange =\n\tthis.onClick = function() {}\n\t\n\tthis.destroy = function() {\n\t\t$.remove(this._el);\n\t\tthis._el = null;\n\t}\n\t\n\tthis.setApp = function(app) {\n\t\tif (app != this._app || !this._el.parentNode) {\n\t\t\tthis._app = app;\n\t\t\tvar canvas = app._ctx.canvas;\n\t\t\tlogger.log('setting parent', this._el);\n\t\t\tcanvas.parentNode.appendChild(this._el);\n\t\t}\n\t}\n\t\n\tthis.change = function() {\n\t\t\n\t}\n\t\n\tthis.click = function() {\n\t}\n\t\n\tthis.selectAll = function() {\n\t\tthis._el.focus();\n\t\tthis._el.select();\n\t}\n\t\n\tthis.show = function() { $.show(this._el); }\n\tthis.hide = function() { $.hide(this._el); }\n\t\n\tthis.setValue = function(value) { this._el.value = value; return this; }\n\tthis.setOpacity = function(o) { this._el.style.opacity = o; return this; }\n\tthis.setType = function(type) { this._el.type = type; return this; }\n\tthis.setVisible = function(isVisible) { return this[isVisible ? 'show': ' hide'](); }\n\tthis.getX = function() { return parseInt(this._el.style.left); }\n\tthis.getY = function() { return parseInt(this._el.style.top); }\n\tthis.getWidth = function() { return this._el.offsetWidth; }\n\tthis.getHeight = function() { return this._el.offsetHeight; }\n\tthis.getValue = function() { return this._el.value; }\n\tthis.getOpacity = function() { return this._el.style.opacity; }\n\tthis.getType = function() { return this._el.type; }\n\tthis.getVisible = function() { return this._el.parentNode && this._el.style.display == 'block'; }\n\t\n\tthis.setPosition = function(p) { this._el.style.top = p.y + 'px'; this._el.style.left = p.x + 'px'; }\n\tthis.getPosition = function() { return {x: this.getX(), y: this.getY()}; }\n\t\n\tthis.setDimensions = function(d) { this._el.style.width = d.width + 'px'; this._el.style.height = d.height + 'px'; return this; }\n\tthis.getDimensions = function() { return {width: this.getWidth(), height: this.getHeight()}; }\n});\n","pre":true},"sdk/timestep/platforms/browser/TextInput.js":{"path":"sdk/timestep/platforms/browser/TextInput.js","friendlyPath":".TextInput","directory":"sdk/timestep/platforms/browser/","filename":"TextInput.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\"use import\";\n\n/**\n * package timestep.env.browser.TextInput;\n *\n * A textbox for inputting user data.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"from util.browser import $\");\n\n/**\n * @extends lib.PubSub\n */\nvar sdk_timestep_platforms_browser_TextInput=__class__;exports=sdk_timestep_platforms_browser_TextInput(function sdk_timestep_platforms_browser_TextInput(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\tthis.init = function(opts) {\n\t\tthis._el = $({\n\t\t\ttag: 'input',\n\t\t\tparent: document.body,\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\tleft: '-100px',\n\t\t\t\ttop: '-100px'\n\t\t\t},\n\t\t\tattrs: {\n\t\t\t\ttype: 'text',\n\t\t\t\tvalue: opts && opts.value || ''\n\t\t\t}\n\t\t});\n\t\tthis._value = this._el.value;\n\t\tthis._selectionStart = 0;\n\t\tthis._selectionEnd = 0;\n\t\t\n\t\t$.onEvent(this._el, 'keydown', this, 'checkValue');\n\t\t$.onEvent(this._el, 'keyup', this, 'checkValue');\n\t\t$.onEvent(this._el, 'keypress', this, 'checkValue');\n\t\t$.onEvent(this._el, 'focus', this, 'onFocus');\n\t\t$.onEvent(this._el, 'blur', this, 'onBlur');\n\t}\n\t\n\tthis.onFocus = function() { this.publish('Focus'); }\n\tthis.onBlur = function() { this.publish('Blur'); }\n\t\n\tthis.checkValue = function(evt) {\n\t\tvar target = evt.target,\n\t\t\tstart = target.selectionStart,\n\t\t\tend = target.selectionEnd;\n\t\t\n\t\tvar value = this._el.value;\n\t\t\n\t\tif (value != this._value) {\n\t\t\tthis.publish('ChangeValue', value);\n\t\t\tthis._value = value;\n\t\t}\n\t\t\n\t\tif (start != this._selectionStart) {\n\t\t\tthis._selectionStart = start;\n\t\t\tthis.publish('ChangeSelectionStart', start);\n\t\t}\n\t\t\n\t\tif (end != this._selectionEnd) {\n\t\t\tthis._selectionEnd = end;\n\t\t\tthis.publish('ChangeSelectionEnd', end);\n\t\t}\n\t}\n\t\n\tthis.focus = function() { logger.log('focus'); this._el.focus(); }\n\tthis.blur = function() { this._el.blur(); }\n});\n\n\n// Set desired tab- defaults to four space softtab\nvar tab = '    ',\n\ttabLength = 4;\n\nArray.prototype.map.call(document.getElementsByTagName('textarea'), function(el) {\n\tel.addEventListener('keydown', checkTab, false);\n});\n\nfunction checkTab(evt) {\n\tvar t = evt.target;\n\tvar ss = t.selectionStart;\n\tvar se = t.selectionEnd;\n \n\t// Tab key - insert tab expansion\n\tif (evt.keyCode == 9) {\n\t\tevt.preventDefault();\n\t\t\n\t\tif (evt.shiftKey) {\n\t\t\t// Special case of multi line selection\n\t\t\tif (ss != se && t.value.slice(ss,se).indexOf('\\n') != -1) {\n\t\t\t\t// In case selection was not of entire lines (e.g. selection begins in the middle of a line)\n\t\t\t\t// we ought to tab at the beginning as well as at the start of every following line.\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tvar pre = t.value.slice(0, i);\n\t\t\t\tvar post = t.value.slice(se, t.value.length);\n\t\t\t\tvar sel = t.value.slice(i, se).replace(\n\t\t\t\t\tnew RegExp('(^|\\n)' + tab, 'g'),\n\t\t\t\t\tfunction(match) {\n\t\t\t\t\t\tse -= tab.length;\n\t\t\t\t\t\tif (match.charAt(0) == '\\n') {\n\t\t\t\t\t\t\treturn '\\n';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tss -= tab.length;\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tt.value = pre.concat(sel).concat(post);\n\n\t\t\t\tt.selectionStart = ss;\n\t\t\t\tt.selectionEnd = se;\n\t\t\t} else {\n\t\t\t\t// \"Normal\" case (no selection or selection on one line only)\n\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tif (t.value.substring(i, i + tab.length) == tab) {\n\t\t\t\t\tt.value = t.value.slice(0, i).concat(t.value.slice(i + tab.length, t.value.length));\n\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\tt.selectionStart = t.selectionEnd = ss - (ss == i ? 0 : tab.length);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.selectionStart = ss - (ss == i ? 0 : tab.length);\n\t\t\t\t\t\tt.selectionEnd = se - tab.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Special case of multi line selection\n\t\t\tif (ss != se && t.value.slice(ss,se).indexOf(\"\\n\") != -1) {\n\t\t\t\t// In case selection was not of entire lines (e.g. selection begins in the middle of a line)\n\t\t\t\t// we ought to tab at the beginning as well as at the start of every following line.\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tvar pre = t.value.slice(0, i);\n\t\t\t\tvar post = t.value.slice(se, t.value.length);\n\t\t\t\tvar sel = t.value.slice(i, se).replace(/\\n/g, function() {\n\t\t\t\t\tse += tab.length;\n\t\t\t\t\treturn '\\n' + tab;\n\t\t\t\t});\n\t\t\t\tt.value = pre.concat(tab).concat(sel).concat(post);\n\n\t\t\t\tt.selectionStart = ss + tab.length;\n\t\t\t\tt.selectionEnd = se + tab.length;\n\t\t\t} else {\n\t\t\t\t// \"Normal\" case (no selection or selection on one line only)\n\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\n\t\t\t\tt.value = t.value.slice(0, i).concat(tab).concat(t.value.slice(i, t.value.length));\n\n\t\t\t\tif (ss == se) {\n\t\t\t\t\tt.selectionStart = t.selectionEnd = ss + tab.length;\n\t\t\t\t} else {\n\t\t\t\t\tt.selectionStart = ss + tab.length;\n\t\t\t\t\tt.selectionEnd = se + tab.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (evt.shiftKey || evt.metaKey || evt.ctrlKey) {\n\t\treturn;\n\t} else if (evt.keyCode == 8 && t.value.slice(ss - tabLength, ss) == tab) {\n\t\t// Backspace key - delete preceding tab expansion, if exists\n\t\tevt.preventDefault();\n\t\t\n\t\tt.value = t.value.slice(0,ss - tabLength).concat(t.value.slice(ss,t.value.length));\n\t\tt.selectionStart = t.selectionEnd = ss - tab.length;\n\t} else if (evt.keyCode == 46 && t.value.slice(se, se + tabLength) == tab) {\n\t\t// Delete key - delete following tab expansion, if exists\n\t\tevt.preventDefault();\n\t\t\n\t\tt.value = t.value.slice(0,ss).concat(t.value.slice(ss + tabLength,t.value.length));\n\t\tt.selectionStart = t.selectionEnd = ss;\n\t} else if (evt.keyCode == 37 && t.value.slice(ss - tabLength, ss) == tab) {\n\t\t// Left/right arrow keys - move across the tab in one go\n\t\tevt.preventDefault();\n\t\tt.selectionStart = t.selectionEnd = ss - tabLength;\n\t} else if (evt.keyCode == 39 && t.value.slice(ss, ss + tabLength) == tab) {\n\t\tevt.preventDefault();\n\t\tt.selectionStart = t.selectionEnd = ss + tabLength;\n\t}\n}\n","pre":true},"sdk/timestep/platforms/browser/Timer.js":{"path":"sdk/timestep/platforms/browser/Timer.js","friendlyPath":".Timer","directory":"sdk/timestep/platforms/browser/","filename":"Timer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package timestep.env.browser.Timer;\n *\n * System timer exposed to the device.\n */\n\nvar _onTick = null,\n\tdisableRequestAnimFrame = false,\n\tdisablePostMessage = true,\n\tasFastAsPossible = false,\n\tMIN_DT = 16;\n\nif (window.postMessage) {\n\tfunction postMessageCb(evt) { if (evt.data == 'timestep.TICK') { onFrame(); }}\n\t\n\tif (window.addEventListener) {\n\t\twindow.addEventListener('message', postMessageCb, false);\n\t} else {\n\t\twindow.attachEvent('onmessage', postMessageCb);\n\t}\n} else {\n\tdisablePostMessage = true;\n\ttickNow = sendTimeoutNow;\n}\n\nfunction sendPostMessage() { window.postMessage('timestep.TICK', '*'); }\nfunction sendTimeout() { setTimeout(onFrame, MIN_DT); }\nfunction sendTimeoutNow() { setTimeout(onFrame, 0); }\n\nvar fastDriver = sendTimeoutNow,\n\tmainDriver = sendTimeout;\n\nif (asFastAsPossible) {\n\tif (!disablePostMessage) {\n\t\tfastDriver = mainDriver = sendPostMessage;\n\t} else {\n\t\tmainDriver = sendTimeoutNow;\n\t}\n} else {\n\tvar reqAnim = !disableRequestAnimFrame && (\n\t\t\t\t\twindow.requestAnimationFrame\n\t\t\t\t|| window.webkitRequestAnimationFrame\n\t\t\t\t|| window.mozRequestAnimationFrame\n\t\t\t\t|| window.oRequestAnimationFrame\n\t\t\t\t|| window.msRequestAnimationFrame);\n\t\n\tif (reqAnim) {\n\t\tfastDriver = mainDriver = reqAnim;\n\t} else if (!disablePostMessage) {\n\t\tfastDriver = sendPostMessage;\n\t}\n}\n\n/*\nvar frameDts = [];\nvar print = false, frames = 0, lastPrint = 0;\nsetInterval(function() { print = true; }, 1000)\n\nvar slow = 0, fast = 0;\n*/\n\nfunction onFrame() {\n\tif (_onTick) {\n\t\tvar now = +new Date(),\n\t\t\tdt = now - (exports.last || now);\n\t\t\n\t\texports.last = now;\n\t\t\n\t\t//try {\n\t\t\t_onTick(dt);\n\t\t/*} catch (e) {\n\t\t\tif (window.DEV_MODE) {\n\t\t\t\tvar err = '.dev_error';\n\t\t\t\tjsio('import ' + err).render(e);\n\t\t\t\texports.stop();\n\t\t\t}\n\t\t}*/\n\n\t\t/*\n\t\tframeDts.push(dt);\n\t\tvar delay = +new Date() - now;\n\t\t++frames;\n\t\tif (print) {\n\t\t\tlogger.log(fast, slow, JSON.stringify(frameDts), now - lastPrint, dt, frames, delay);\n\t\t\tframeDts = [];\n\t\t\tlastPrint = now;\n\t\t\tprint = false;\n\t\t\tframes = 0;\n\t\t\tslow = 0;\n\t\t\tfast = 0;\n\t\t}\n\t\t*/\n\t\t\n\t\tif (dt > MIN_DT) {\n\t\t//\t++fast;\n\t\t\tfastDriver.call(window, onFrame);\n\t\t} else {\n\t\t//\t++slow;\n\t\t\tmainDriver.call(window, onFrame);\n\t\t}\n\t}\n}\n\nexports.last = null;\n\nexports.start = function(onTick) {\n\t_onTick = onTick;\n\tmainDriver.call(window, onFrame);\n}\n\nexports.stop = function() { _onTick = null; }\n","pre":true},"sdk/timestep/ui/backend/dom/animate.js":{"path":"sdk/timestep/ui/backend/dom/animate.js","friendlyPath":".backend.dom.animate","directory":"sdk/timestep/ui/backend/dom/","filename":"animate.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.backend.dom.animate;\n *\n * For now, this package simply forwards to Canvas' implementation.\n */\n\njsio(\"import ui.backend.canvas.animate as canvasAnimate\");\n\nexports = function(view) {\n\t// For DOM nodes, return only one singleton animation class.\n\tif ('_node' in view) {\n\t\treturn view.getAnimation();\n\t} else {\n\t\treturn canvasAnimate(view);\n\t}\n}\nexports.linear = canvasAnimate.linear;\nexports.easeIn = canvasAnimate.easeIn;\nexports.easeInOut = canvasAnimate.easeInOut;\nexports.easeOut = canvasAnimate.easeOut;\n","pre":true},"sdk/timestep/ui/backend/dom/ImageView.js":{"path":"sdk/timestep/ui/backend/dom/ImageView.js","friendlyPath":".backend.dom.ImageView","directory":"sdk/timestep/ui/backend/dom/","filename":"ImageView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.backend.dom.ImageView;\n *\n * Renders an image in a View for canvas.\n */\n\njsio(\"import ui.View as View\");\njsio(\"import ui.resource.Image as Image\");\n\nfunction getImageURL(image) {\n\tif (image.getSource) {\n\t\treturn image.getSource().src;\n\t} else {\n\t\treturn image;\n\t}\n}\n\n/**\n * @extends timestep.View\n */\nvar sdk_timestep_ui_backend_dom_ImageView=__class__;exports=sdk_timestep_ui_backend_dom_ImageView(function sdk_timestep_ui_backend_dom_ImageView(){return this.init&&this.init.apply(this,arguments)},View, function (supr) {\n\n\tthis.init = function (opts) {\n\t\topts = merge(opts, {\n\t\t\timage: null,\n\t\t\tautoSize: false\n\t\t});\n\n\t\tsupr(this, \"init\", [opts]);\n\n\t\tif (opts.image) {\n\t\t\tthis.setImage(opts.image, opts); \n\t\t}\n\t};\n\n\tthis.autoSize = function() {\n\t\tif (this._img) {\n\t\t\tthis.style.width = this._img.getWidth();\n\t\t\tthis.style.height = this._img.getHeight();\n\n\t\t\tif (this.style.fixedAspectRatio) {\n\t\t\t\tthis.style.updateAspectRatio();\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.tick = function() {\n\t\tif (this._img) {\n\t\t\tvar boundsHash = JSON.stringify(this._img.getBounds());\n\t\t\tif (this._cachedBounds != boundsHash) {\n\t\t\t\tthis._cachedBounds = boundsHash;\n\t\t\t\tthis.updateImage();\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.getImage = function() { return this._img; }\n\tthis.setImage = function(img, opts) {\n\t\tif (typeof img == 'string') {\n\t\t\tthis._img = new Image({url: img});\n\t\t} else {\n\t\t\tthis._img = img;\n\t\t}\n\n\t\tif (this._img) {\n\t\t\tif (opts && opts.autoSize) {\n\t\t\t\t// sprited resources will know their dimensions immediately\n\t\t\t\tif (this._img.getWidth() > 0 && this._img.getHeight() > 0) {\n\t\t\t\t\tthis.autoSize();\n\t\t\t\t} else {\n\t\t\t\t\t// non-sprited resources need to load first\n\t\t\t\t\tthis._img.doOnLoad(this, 'autoSize');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._img.doOnLoad(this, 'updateImage');\n\t\t} else {\n\t\t\tthis.updateImage();\n\t\t}\n\t}\n\n\tthis.reflow = function () {\n\t\tthis.updateImage();\n\t}\n\n\tthis.updateImage = function() {\n\t\tvar s = this.__view._node.style;\n\t\tif (!this._img || !this._img.isReady()) {\n\t\t\ts.backgroundImage = 'none';\n\t\t\treturn;\n\t\t}\n\n\t\tvar img = this._img;\n\t\tvar bounds = img.getBounds();\n\n\t\tvar sheetWidth = img.getOrigW();\n\t\tvar sheetHeight = img.getOrigH();\n\t\tvar imgWidth = bounds.width + bounds.marginLeft + bounds.marginRight;\n\t\tvar imgHeight = bounds.height + bounds.marginTop + bounds.marginBottom;\n\n\t\ts.padding = bounds.marginTop + 'px ' + bounds.marginRight + 'px ' + bounds.marginBottom + 'px ' + bounds.marginLeft + 'px';\n\n\t\tvar scaleX = this.style.width / imgWidth;\n\t\tvar scaleY = this.style.height / imgHeight;\n\n\t\t//s.overflow = 'hidden';\n\t\ts.webkitBackgroundClip = s.backgroundClip = 'content-box';\n\t\ts.backgroundImage = 'url(\"' + getImageURL(img) + '\")';\n\t\ts.backgroundPositionX = scaleX * (-bounds.x + bounds.marginLeft) + 'px';\n\t\ts.backgroundPositionY = scaleY * (-bounds.y + bounds.marginTop) + 'px';\n\t\ts.backgroundSize = sheetWidth * scaleX + 'px ' + sheetHeight * scaleY + 'px';\n\t}\n\n\tthis.getOrigWidth = this.getOrigW = function() { return this._img.getOrigW(); }\n\tthis.getOrigHeight = this.getOrigH = function() { return this._img.getOrigH(); }\n\n\tthis.doOnLoad = function() {\n\t\tif (arguments.length == 1) {\n\t\t\tthis._img.doOnLoad(this, arguments[0]);\n\t\t} else {\n\t\t\tthis._img.doOnLoad.apply(this._img, arguments);\n\t\t}\n\t\treturn this;\n\t}\n\n});\n","pre":true},"sdk/timestep/ui/resource/Image.js":{"path":"sdk/timestep/ui/resource/Image.js","friendlyPath":"ui.resource.Image","directory":"sdk/timestep/ui/resource/","filename":"Image.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.resource.Image;\n * Model an Image for rendering. Supports taking a subset of images, to support\n * extracting from compacted sprite sheets. Also supports applying filters to\n * an image, usually by the View class.\n *\n * @doc http://doc.gameclosure.com/api/ui-imageview.html#class-ui.resource.image\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/imageview.md\n */\n\njsio(\"import event.Callback as Callback\");\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import device\");\njsio(\"import ui.resource.loader as resourceLoader\");\n\n/**\n * Callback when images are loaded. This has a failsafe that runs up to a certain\n * threshold asynchronously, attempting to read the image size, before dying.\n */\n\nvar ImageCache = {};\n\nfunction imageOnLoad(success, evt, failCount) {\n\t// Some browsers report onLoad before the image width is available.\n\tif (success && !this.width) {\n\t\tif (failCount > 3) {\n\t\t\tthis.onLoad = this.onError = null;\n\t\t\treturn this.__cb.fire(false);\n\t\t}\n\n\t\treturn setTimeout(bind(this, imageOnLoad, success, evt, (failCount || 0) + 1), 0);\n\t}\n\n\tthis.__cb.fire(success);\n\tthis.onLoad = this.onError = null;\n}\n\n/**\n * This class models the region of a larger image that this \"Image\" references.\n */\n\nvar ImageMap = !GLOBAL.CONFIG.disableNativeViews && GLOBAL.NATIVE && GLOBAL.NATIVE.timestep && GLOBAL.NATIVE.timestep.ImageMap;\n\nif (!ImageMap) {\nImageMap=__class__;\tImageMap=ImageMap(function ImageMap(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\tthis.init = function(parentImage, x, y, width, height, marginTop, marginRight, marginBottom, marginLeft, url) {\n\t\t\tthis.url = url;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.marginTop = marginTop;\n\t\t\tthis.marginRight = marginRight;\n\t\t\tthis.marginBottom = marginBottom;\n\t\t\tthis.marginLeft = marginLeft;\n\t\t}\n\t});\n}\n\nvar sdk_timestep_ui_resource_Image=__class__;exports=sdk_timestep_ui_resource_Image(function sdk_timestep_ui_resource_Image(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tif (!opts) { opts = {}; }\n\n\t\tthis._cb = new Callback();\n\t\tthis._map = new ImageMap(this, 0, 0, -1, -1, 0, 0, 0, 0, opts.url || '');\n\n\t\tthis._originalURL = opts.url;\n\n\t\tresourceLoader._updateImageMap(this._map, opts.url, opts.sourceX, opts.sourceY, opts.sourceW, opts.sourceH);\n\n\t\tthis._scale = opts.scale;\n\n\t\t// srcImage can be null, then setSrcImg will create one\n\t\t// (use the map's URL in case it was updated to a spritesheet)\n\t\tthis._setSrcImg(opts.srcImage, this._map.url);\n\t};\n\n\tthis._setSrcImg = function(img, url) {\n\t\tthis._cb.reset();\n\n\t\t// if we haven't found an image, look in the image cache\n\t\tif (!img && url && ImageCache[url]) {\n\t\t\timg = ImageCache[url];\n\t\t}\n\n\t\t// look up the base64 cache -- if it's been preloaded, we'll get back an image that's already loaded\n\t\t// if it has not been preloaded, we'll get back raw base64 in the b64 variable\n\t\tif (!img && Image.get) {\n\t\t\tvar b64 = Image.get(url);\n\t\t\tif (typeof b64 == 'object') {\n\t\t\t\timg = b64;\n\t\t\t} else if (b64) {\n\t\t\t\turl = b64;\n\t\t\t}\n\t\t}\n\n\t\t// if it's already loaded...\n\t\tif (img && img.complete) {\n\t\t\tthis._srcImg = img;\n\t\t\tthis._onLoad(true);\n\t\t} else {\n\t\t\t// add a callback and wait for it\n\n\t\t\t// create an image if we don't have one\n\t\t\tthis._srcImg = img = img || new Image();\n\n\t\t\tif (!img.__cb) {\n\t\t\t\timg.__cb = new Callback();\n\t\t\t\timg.addEventListener('load', bind(img, imageOnLoad, true), false);\n\t\t\t\timg.addEventListener('error', bind(img, imageOnLoad, false), false);\n\n\t\t\t\tif (url) { ImageCache[url] = img; }\n\t\t\t\tif (!img.src && url) {\n\t\t\t\t\tthis._srcImg.src = this._map.url = url;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timg.__cb.run(this, '_onLoad');\n\t\t}\n\t};\n\n\tthis.setSource = this.setSrcImg = function(srcImg) {\n\t\tthis._setSrcImg(srcImg);\n\t};\n\n\tthis.__reload__ = function(cb) {\n\t\tif (this._srcImg) {\n\t\t\tvar chainedCb = cb.chain();\n\n\t\t\tvar onReload = bind(this, function() {\n\t\t\t\tthis._srcImg.removeEventListener('reload', onReload, false);\n\t\t\t\tchainedCb();\n\t\t\t});\n\n\t\t\tthis._srcImg.addEventListener('reload', onReload, false);\n\t\t}\n\t};\n\n\tthis.setURL = function(url) {\n\t\tresourceLoader._updateImageMap(this._map, url);\n\t\tthis._setSrcImg(null, this._map.url);\n\t};\n\n\tthis.getURL = function() { return this._map.url; };\n\tthis.getOriginalURL = function () { return this._originalURL; }\n\n\tthis.getSourceWidth = this.getOrigWidth = this.getOrigW = function() { return this._srcImg.width; };\n\tthis.getSourceHeight = this.getOrigHeight = this.getOrigH = function() { return this._srcImg.height; };\n\n\tthis.setSourceWidth = this.setSourceW = function(w) { this._map.width = w; };\n\tthis.setSourceHeight = this.setSourceH = function(h) { this._map.height = h; };\n\tthis.setSourceY = this.setSourceY = function(y) { this._map.y = y; };\n\tthis.setSourceX = this.setSourceX = function(x) { this._map.x = x; };\n\n\tthis.setMarginTop = function (n) { this._map.marginTop = n; };\n\tthis.setMarginRight = function (n) { this._map.marginRight = n; };\n\tthis.setMarginBottom = function (n) { this._map.marginBottom = n; };\n\tthis.setMarginLeft = function (n) { this._map.marginLeft = n; };\n\n\tthis.getURL = function() { return this._map.url; }\n\n\t/* @deprecated */\n\tthis.getSourceWidth = this.getOrigWidth = this.getOrigW = function() { return this._srcImg.width; }\n\t/* @deprecated */\n\tthis.getSourceHeight = this.getOrigHeight = this.getOrigH = function() { return this._srcImg.height; }\n\t/* @deprecated */\n\tthis.setSourceWidth = this.setSourceW = function(w) { this._map.width = w; }\n\t/* @deprecated */\n\tthis.setSourceHeight = this.setSourceH = function(h) { this._map.height = h; }\n\t/* @deprecated */\n\tthis.setSourceY = this.setSourceY = function(y) { this._map.y = y; }\n\t/* @deprecated */\n\tthis.setSourceX = this.setSourceX = function(x) { this._map.x = x; }\n\t/* @deprecated */\n\tthis.setMarginTop = function (n) { this._map.marginTop = n; }\n\t/* @deprecated */\n\tthis.setMarginRight = function (n) { this._map.marginRight = n; }\n\t/* @deprecated */\n\tthis.setMarginBottom = function (n) { this._map.marginBottom = n; }\n\t/* @deprecated */\n\tthis.setMarginLeft = function (n) { this._map.marginLeft = n; }\n\t\n\tthis.getSource = function() {\n\t\treturn this._srcImg;\n\t};\n\n\tthis.getWidth = function() {\n\t\treturn (this._map.width == -1\n\t\t\t? 0\n\t\t\t: this._map.width + this._map.marginLeft + this._map.marginRight) / this._map.scale;\n\t};\n\n\tthis.getHeight = function() {\n\t\treturn (this._map.height == -1 ? 0 :\n\t\t\t\t\t\t\t   this._map.height + this._map.marginTop + this._map.marginBottom) / this._map.scale;\n\t};\n\n\tthis.getMap =\n\tthis.getBounds = function() { return this._map; };\n\tthis.setBounds = function(x, y, w, h, marginTop, marginRight, marginBottom, marginLeft) {\n\t\tvar map = this._map;\n\t\tmap.x = x;\n\t\tmap.y = y;\n\t\tmap.width = w;\n\t\tmap.height = h;\n\t\tmap.marginTop = marginTop || 0;\n\t\tmap.marginRight = marginRight || 0;\n\t\tmap.marginBottom = marginBottom || 0;\n\t\tmap.marginLeft = marginLeft || 0;\n\t};\n\n\t/* @deprecated */\n\tthis.setBounds = this.setMap;\n\t\n\t// register a callback for onload\n\tthis.doOnLoad = function() { this._cb.forward(arguments); return this; };\n\n\t// internal onload handler for actual Image object\n\tthis._onLoad = function(didLoad) {\n\t\tif (!didLoad) {\n\t\t\t// TODO: something better?\n\t\t\tlogger.error('Image failed to load:', this._map.url);\n\t\t\tthis._cb.fire({NoImage: true});\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._srcImg.width == 0) { logger.warn('Image has no width', this._url); }\n\n\t\tvar map = this._map;\n\t\tif (this._scale && (map.width != -1 || map.height != -1)) {\n\t\t\t// requested scale & provided a width or height\n\t\t\tif (map.width == -1) {\n\t\t\t\t// by the above check, this._sourceH should not be -1\n\t\t\t\tmap.width = this._srcImg.width * map.height / this._srcImg.height;\n\t\t\t}\n\n\t\t\tif (map.height == -1) {\n\t\t\t\t// this._sourceW was initialized above\n\t\t\t\tmap.height = this._srcImg.height * map.width / this._srcImg.width;\n\t\t\t}\n\n\t\t\t// TODO: sourceImage might be shared so we can't actually modify width/height.  This is a bug.\n\t\t\tthis._srcImg.width = map.width;\n\t\t\tthis._srcImg.height = map.height;\n\t\t} else {\n\t\t\tif (map.width == -1) { map.width = this._srcImg.width; }\n\t\t\tif (map.height == -1) { map.height = this._srcImg.height; }\n\t\t}\n\n\t\tthis._map.url = this._srcImg.src;\n\n\t\tthis._cb.fire(null, this);\n\t};\n\n\tthis.isLoaded =\n\tthis.isReady = function() { return this._cb.fired(); };\n\n\tvar isNative = GLOBAL.NATIVE && !device.simulatingMobileNative;\n\tvar SLICE = Array.prototype.slice;\n\tif (!isNative) {\n\t\tvar Canvas = device.get('Canvas');\n\t\tvar _filterCanvas = new Canvas();\n\t\tvar _filterCtx = _filterCanvas.getContext('2d');\n\t};\n\n\tthis.render = function(ctx, destX, destY, destW, destH) {\n\t\tif (!this._cb.fired()) { return; }\n\n\t\ttry {\n\t\t\tvar args = arguments;\n\t\t\tvar map = this._map;\n\t\t\tvar scaleX;\n\t\t\tvar scaleY;\n\n\t\t\tif (!(ctx.filters && (ctx.filters.Multiply || ctx.filters.NegativeMask || ctx.filters.PositiveMask))) {\n\t\t\t\tif (args.length == 9) {\n\t\t\t\t\tctx.drawImage(this._srcImg, args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\t\t} else if (destX instanceof Rect) {\n\t\t\t\t\tif (destY instanceof Rect) {\n\t\t\t\t\t\tvar srcRect = destX;\n\t\t\t\t\t\tvar destRect = destY;\n\t\t\t\t\t\tscaleX = destRect.width / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\t\tscaleY = destRect.height / (map.marginTop + map.height + map.marginBottom);\n\t\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\tsrcRect.x, srcRect.y, srcRect.width, srcRect.height,\n\t\t\t\t\t\t\tdestRect.x, destRect.y, destRect.width, destRect.height);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar destRect = destX;\n\t\t\t\t\t\tscaleX = destRect.width / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\t\tscaleY = destRect.height / (map.marginTop + map.height + map.marginBottom);\n\t\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\t\t\t  map.x, map.y, map.width, map.height,\n\t\t\t\t\t\t\t\t\t  destRect.x + scaleX * map.marginLeft,\n\t\t\t\t\t\t\t\t\t  destRect.y + scaleY * map.marginTop,\n\t\t\t\t\t\t\t\t\t  scaleX * map.width,\n\t\t\t\t\t\t\t\t\t  scaleY * map.height);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tscaleX = destW / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\tscaleY = destH / (map.marginTop + map.height + map.marginBottom);\n\n\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\t\t  map.x, map.y, map.width, map.height,\n\t\t\t\t\t\t\t\t  (destX || 0) + scaleX * map.marginLeft,\n\t\t\t\t\t\t\t\t  (destY || 0) + scaleY * map.marginTop,\n\t\t\t\t\t\t\t\t  scaleX * map.width,\n\t\t\t\t\t\t\t\t  scaleY * map.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar renderArgs = arguments, img = this;\n\n\t\t\tfunction applyOperation(color, op1, op2) {\n\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t_filterCtx.globalCompositeOperation = op1;\n\t\t\t\t_filterCtx.fillStyle = \"rgba(\" + color.r  + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n\t\t\t\t_filterCtx.fillRect(destX || 0, destY || 0, destW || map.width, destH || map.height);\n\n\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\tctx.globalCompositeOperation = op2;\n\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t}\n\n\t\t\t// Rendering engine flags.\n\t\t\tvar isWebkit = /WebKit/.exec(navigator.appVersion);\n\t\t\tif (!isNative && ctx.filters) {\n\n\t\t\t\tif (ctx.filters.LinearAdd) {\n\t\t\t\t\tvar f = ctx.filters.LinearAdd.get();\n\t\t\t\t\tapplyOperation(f, 'source-in', 'lighter');\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.Tint) {\n\t\t\t\t\tvar f = ctx.filters.Tint.get();\n\t\t\t\t\tvar color = {r: f.r, g: f.g, b: f.b, a: f.a};\n\t\t\t\t\tapplyOperation(color, 'source-in', 'source-over');\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.Multiply) {\n\t\t\t\t\tvar f = ctx.filters.Multiply.get();\n\t\t\t\t\tvar imgData = this.getImageData();\n\t\t\t\t\tvar data = imgData.data;\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < data.length; i+=4) {\n\t\t\t\t\t\tdata[i] *= ((f.r / 255) * f.a); \n\t\t\t\t\t\tdata[i + 1] *= ((f.g / 255) * f.a); \n\t\t\t\t\t\tdata[i + 2] *= ((f.b / 255) * f.a); \n\t\t\t\t\t}\n\n\t\t\t\t\t_filterCanvas.width = imgData.width;\n\t\t\t\t\t_filterCanvas.height = imgData.height;\n\t\t\t\t\t_filterCtx.putImageData(imgData, 0, 0);\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.NegativeMask) {\n\t\t\t\t\tvar f = ctx.filters.NegativeMask.get();\n\t\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tf.imgObject.render.apply(f.imgObject, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-in';\n\t\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\t\tctx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.PositiveMask) {\n\t\t\t\t\tvar f = ctx.filters.PositiveMask.get();\n\t\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tf.imgObject.render.apply(f.imgObject, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-out';\n\t\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\t\tctx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(e) {}\n\t};\n\n\tthis.getImageData = function() {\n\t\tif (!GLOBAL.document || !document.createElement) { throw 'Not supported'; }\n\t\tif (!this._map.width || !this._map.height) { throw 'Not loaded'; }\n\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = this._map.width;\n\t\tcanvas.height = this._map.height;\n\t\tvar ctx = canvas.getContext('2d');\n\n\t\tthis.render(ctx, 0, 0, this._map.width, this._map.height);\n\n\t\tvar imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\treturn imageData;\n\t};\n\n\tthis.setImageData = function(data) { };\n\n\tthis.destroy = function() {\n\t\tthis._srcImg.destroy();\n\t};\n});\n\nexports.__clearCache__ = function () {\n\tImageCache = {};\n};\n","pre":true},"sdk/timestep/event/Callback.js":{"path":"sdk/timestep/event/Callback.js","friendlyPath":"event.Callback","directory":"sdk/timestep/event/","filename":"Callback.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class event.Callback;\n * Namespace shim to bring in Callback from jsio.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.callback\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import lib.Callback as exports\");\n","pre":true},"sdk/jsio/lib/Callback.js":{"path":"sdk/jsio/lib/Callback.js","friendlyPath":"lib.Callback","directory":"sdk/jsio/lib/","filename":"Callback.js","src":"var sdk_jsio_lib_Callback=__class__;exports=sdk_jsio_lib_Callback(function sdk_jsio_lib_Callback(){return this.init&&this.init.apply(this,arguments)},function() {\n\n\tthis._fired = false;\n\tthis._id = 0;\n\tthis._pending = null;\n\n\tthis.init = function() { this._run = []; };\n\t\n\t/* fired is @deprecated in favor of hasFired*/\n\tthis.hasFired = this.fired = function() { return this._fired; } ;\n\n\t// preserve pending callbacks, but clear fired status\n\tthis.reset = function() { this._args = []; this._fired = false; };\n\n\t// clear fired status and remove any pending callbacks\n\tthis.clear = function() { this.reset(); this._run = []; this._pending = null; this._stat = null; };\n\n\t// a convenience function to proxy arguments to `this.run`: arguments passed as the first argument\n\tthis.forward = function(args) { this.run.apply(this, args); };\n\n\t// when the lib.Callback object fires, run a ctx, method, and\n\t// (optional) curried arguments or a single callback function\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.runOrTimeout = function(onFire, onTimeout, duration) {\n\t\tif (!onFire && !onTimeout) { return; }\n\n\t\tif (this._fired) {\n\t\t\tonFire.apply(this, this._args);\n\t\t} else {\n\t\t\tvar f = bind(this, function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tonFire.apply(this, this._args);\n\t\t\t});\n\n\t\t\tthis.run(f);\n\n\t\t\tvar timeout = setTimeout(bind(this, function() {\n\t\t\t\tfor (var i = 0, n = this._run.length; i < n; ++i) {\n\t\t\t\t\tif (this._run[i] == f) {\n\t\t\t\t\t\tthis._run.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tonTimeout();\n\t\t\t}), duration);\n\t\t}\n\t};\n\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\n\t\tvar cbs = this._run;\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t};\n\n\tthis.chain = function(id) {\n\t\tif (!this._pending) { this._pending = {}; }\n\t\tif (id === undefined) { id = this._id++; }\n\t\tthis._pending[id] = true;\n\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id);\n\t};\n\n\tthis._deferred = function(id) {\n\t\tif (!this._stat) { this._stat = {}; }\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = Array.prototype.slice.call(arguments, 1);\n\t\tvar pending = this._pending;\n\t\tdelete pending[id];\n\t\tfor (var id in pending) {\n\t\t\tif (pending.hasOwnProperty(id)) { return; }\n\t\t}\n\n\t\tthis.fire(this._stat);\n\t};\n});\n","pre":true},"sdk/timestep/ui/resource/loader.js":{"path":"sdk/timestep/ui/resource/loader.js","friendlyPath":"ui.resource.loader","directory":"sdk/timestep/ui/resource/","filename":"loader.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.Callback\");\n\nvar _cache = {};\n\nvar MIME = {\n\t'.png': 'image',\n\t'.jpg': 'image',\n\t'.bmp': 'image',\n\t'.css': 'css',\n\t'.html': 'html',\n\t'.mp3': 'audio',\n\t'.ogg': 'audio',\n\t'.mp4': 'audio',\n\t'.3gp': 'audio',\n\t'.m4a': 'audio',\n\t'.aac': 'audio',\n\t'.flac': 'audio',\n\t'.mkv': 'audio',\n\t'.wav': 'audio'\n};\n\nLoader=__class__;var Loader=Loader(function Loader(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis._map = {};\n\n\tthis.getMap = function () { return this._map; }\n\tthis.setMap = function (map) { this._map = map || {}; }\n\t\n\t// TODO: rename this function...\n\tthis.get = function (file) {\n\t\treturn 'resources/images/' + file;\n\t}\n\t\n\t/**\n\t * Preload a given resource or array of resources.\n\t * You can specify a folder name, or even a partial filename,\n\t * to preload all resources that begin with that prefix.\n\t * For instance, in a tree like so:\n\t * \n\t * resources\n\t * └── images\n     *     ├── boss\n     *     │   ├── enemy1.png\n\t *     │   └── enemy2.png\n     *     └── hero\n     *         ├── shield.png\n\t *         └── sword.png\n\t * \n\t * You could preload both enemy images in either of the following\n\t * ways:\n\t * \n\t *     ui.resource.loader.preload(\"resources/images/boss/\");\n\t *     ui.resource.loader.preload(\"resources/images/boss/enemy\");\n\t * \n\t * Pass an array of paths to preload all at once. The callback\n\t * will be called when all resources have finished loading.\n\t * \n\t * This works for both images and sounds.\n\t */\n\tthis.preload = function (pathPrefix, opts, cb) {\n\t\tif (typeof opts == 'function') {\n\t\t\tcb = opts;\n\t\t\topts = undefined;\n\t\t}\n\n\t\t// process an array of items, where cb is run at completion of the final one\n\t\tif (isArray(pathPrefix)) {\n\t\t\tvar chainCb = new lib.Callback();\n\t\t\tpathPrefix.forEach(function(prefix) {\n\t\t\t\tif (prefix) {\n\t\t\t\t\tthis.preload(prefix, opts, chainCb.chain());\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tcb && chainCb.run(cb);\n\t\t\treturn chainCb;\n\t\t} else {\n\t\t\tpathPrefix = pathPrefix.replace(/^\\//, ''); // remove leading slash\n\t\t\t// if an item is found in the map, add that item's sheet to the group.\n\t\t\t// If there is no sheet in the map (i.e. for sounds), load that file directly.\n\t\t\tvar preloadSheets = {};\n\t\t\tvar map = this._map;\n\t\t\tfor (var uri in map) {\n\t\t\t\tif (uri.indexOf(pathPrefix) == 0) {\n\t\t\t\t\t// sprites have sheet; sounds are just by the filename key itself\n\t\t\t\t\tpreloadSheets[map[uri] && map[uri].sheet || uri] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar files = Object.keys(preloadSheets);\n\n\t\t\tvar callback = this._loadGroup(merge({resources: files}, opts));\n\t\t\tcb && callback.run(cb);\n\t\t\treturn callback;\n\t\t}\n\t};\n\t\n\tvar soundLoader = null;\n\tthis.getSound = function(src) {\n\t\tif (!soundLoader) {\n\t\t\tjsio(\"import AudioManager\");\n\t\t\tsoundLoader = new AudioManager();\n\t\t}\n\n\t\tif (GLOBAL.NATIVE && GLOBAL.NATIVE.sound && GLOBAL.NATIVE.sound.preloadSound) {\n\t\t\treturn NATIVE.sound.preloadSound(src);\n\t\t} else {\n\t\t\tsoundLoader.addSound(src);\n\t\t\t//HACK to make the preloader continue in the browser\n\t\t\treturn { complete: true };\n\t\t}\n\t}\n\n\tthis.getImage = function(src, noWarn) {\n\t\t// create the image\n\t\tvar img = new Image();\n\t\t\n\t\t// find the base64 image if it exists\n\t\tif (Image.get) {\n\t\t\tvar b64 = Image.get(src);\n\t\t\tif (b64 instanceof Image) { \n\t\t\t\treturn b64;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (b64) {\n\t\t\timg.src = b64;\n\t\t\tImage.set(src, img);\n\t\t} else {\n\t\t\tif (!noWarn) { logger.warn(src, 'may not be properly cached!'); }\n\t\t\timg.src = src;\n\t\t}\n\n\t\treturn img;\n\t}\n\n\t/** \n\t * used internally by timestep.Image to seamlessly convert\n\t * non-sprited image URLs to sprited images. This is here (rather\n\t * than in timestep.Image) to keep sprite formats in one consistent place. \n\t */\n\tthis._updateImageMap = function (map, url, x, y, w, h) {\n\n\t\tx = x || 0;\n\t\ty = y || 0;\n\t\tw = w == undefined ? -1 : w;\n\t\th = h == undefined ? -1 : h;\n\n\t\tvar info = this._map[url];\n\t\tif (!info || !info.sheet) {\n\t\t\tmap.x = x;\n\t\t\tmap.y = y;\n\t\t\tmap.width = w;\n\t\t\tmap.height = h;\n\t\t\tmap.scale = 1;\n\t\t\tmap.url = url;\n\t\t\treturn;\n\t\t}\n\n\t\tvar scale = info.scale || 1;\n\n\t\t// calculate the source rectangle, with margins added to the edges\n\t\t// (disregarding the fact that they may fall off the edge of the sheet)\n\t\tmap.x = info.x - info.marginLeft;\n\t\tmap.y = info.y - info.marginTop;\n\t\tmap.width = info.w + info.marginLeft + info.marginRight;\n\t\tmap.height = info.h + info.marginTop + info.marginBottom;\n\t\t\n\t\t// Add in any source map options passed in to get the actual offsets\n\t\tmap.x += x * scale;\n\t\tmap.y += y * scale;\n\t\tif (w > 0) {\n\t\t\tmap.width = w * scale;\n\t\t}\n\t\tif (h > 0) {\n\t\t\tmap.height = h * scale;\n\t\t}\n\t\t\n\t\t// now updatea the margins to account for the new source map\n\t\tmap.marginLeft = Math.max(0, info.x - map.x);\n\t\tmap.marginTop = Math.max(0, info.y - map.y);\n\t\tmap.marginRight = Math.max(0, (map.x + map.width) - (info.x + info.w));\n\t\tmap.marginBottom = Math.max(0, (map.y + map.height) - (info.y + info.h));\n\t\t\n\t\t// and re-offset the source map to exclude margins\n\t\tmap.x += map.marginLeft;\n\t\tmap.y += map.marginTop;\n\t\tmap.width -= (map.marginLeft + map.marginRight);\n\t\tmap.height -= (map.marginTop + map.marginBottom);\n\t\t\n\t\t// the scale of the source image, if scaled in a spritesheet\n\t\tmap.scale = scale;\n\t\tmap.url = info.sheet;\n\n\t\treturn map;\n\t}\n\n\tthis._getRaw = function(type, src, copy, noWarn) {\n\t\t// always return the cached copy unless specifically requested not to\n\t\tif (!copy && _cache[src]) { return _cache[src]; }\n\t\tvar res = null;\n\t\tswitch (type) {\n\t\t\tcase 'audio':\n\t\t\t\tres = this.getSound(src);\n\t\t\t\tbreak;\n\t\t\tcase 'image':\n\t\t\t\tres = this.getImage(src, noWarn);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.error('unknown type for preloader', type);\n\t\t}\n\t\treturn (_cache[src] = res);\n\t}\n\n\t// The callback is called for each image in the group with the image\n\t// source that loaded and whether there was an error.\n\t// \n\t// function callback(lastSrc, error, isComplete, numCompleted, numTotal)\n\t//    where error is true or false and isComplete is true when numCompleted == numTotal\n\t//\n\tthis._loadGroup = function (opts, cb) {\n\t\tvar timeout = opts.timeout;\n\t\tvar callback = new lib.Callback();\n\t\t\n\t\t// compute a list of images using file extensions\n\t\tvar resources = opts.resources || [];\n\t\tvar n = resources.length || 0;\n\t\tvar loadableResources = [];\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tvar ext = resources[i].substring(resources[i].lastIndexOf('.')).split('|')[0];\n\t\t\tif (MIME[ext] == 'image') {\n\t\t\t\tloadableResources.push({type:'image', resource: resources[i]});\n\t\t\t\tGLOBAL.NATIVE && NATIVE.gl && NATIVE.gl.touchTexture(resources[i]);\n\t\t\t} else if (MIME[ext] == 'audio') {\n\t\t\t\tloadableResources.push({type:'audio', resource: resources[i]});\n\t\t\t}\n\t\t}\n\n\t\t// If no resources were loadable,\n\t\tif (!loadableResources.length) {\n\t\t\tcb && callback.run(cb);\n\t\t\tcallback.fire();\n\t\t\treturn callback;\n\t\t}\n\t\t\n\t\t// do the preload asynchronously (note that base64 is synchronous, only downloads are asynchronous)\n\t\tvar nextIndexToLoad = 0;\n\t\tvar numResources = loadableResources.length;\n\t\tvar parallel = opts.parallel || 5; // how many should we try to download at a time?\n\t\tvar numLoaded = 0;\n\n\t\tvar loadResource = bind(this, function() {\n\t\t    var currentIndex = nextIndexToLoad++;\n\t\t\tvar src = loadableResources[currentIndex];\n\t\t\tvar res;\n\t\t\tif (src) {\n\t\t\t\tres = this._getRaw(src.type, src.resource, false, true);\n\t\t\t} else {\n\t\t\t\t// End of resource list, done!\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar next = function(failed) {\n\t\t\t\t// If already complete, stub this out\n\t\t\t\tif (numLoaded >= numResources) { return; }\n\n\t\t\t\t// Set stubs for the reload and load events so that code\n\t\t\t\t// elsewhere can blindly call these without causing problems.\n\t\t\t\t// An alternative would be to set these to null but not every\n\t\t\t\t// piece of code that uses this does the right checks.\n\t\t\t\tres.onreload = res.onload = res.onerror = function(){};\n\n\t\t\t\t// The number of loads (success or failure) has increased.\n\t\t\t\t++numLoaded;\n\n\t\t\t\t// If we have loaded all of the resources,\n\t\t\t\tif (numLoaded >= numResources) {\n\t\t\t\t\t// Call the progress callback with isComplete == true\n\t\t\t\t\tcb && cb(src, failed, true, numLoaded, numResources);\n\n\t\t\t\t\t// If a timeout was set, clear it\n\t\t\t\t\tif (_timeout) {\n\t\t\t\t\t\tclearTimeout(_timeout);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fire the completion callback chain\n\t\t\t\t\tcallback.fire();\n\t\t\t\t} else {\n\t\t\t\t\t// Call the progress callback with the current progress\n\t\t\t\t\tcb && cb(src, failed, false, numLoaded, numResources);\n\n\t\t\t\t\t// Restart on next image in list\n\t\t\t\t\tsetTimeout(loadResource, 0);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// IF this is the type of resource that has a reload method,\n\t\t\tif (res.reload && res.complete) {\n\t\t\t\t// Use the magic of closures to create a chain of onreload\n\t\t\t\t// completion callbacks.  This is really important because\n\t\t\t\t// we can be be preloading the same resource twice, and we can\n\t\t\t\t// also be simultaneously preloading two groups at once.\n\t\t\t\tvar prevOnLoad = res.onreload;\n\t\t\t\tvar prevOnError = res.onerror;\n\n\t\t\t\t// When the resource completes loading, either with success\n\t\t\t\t// or failure:\n\n\t\t\t\tres.onreload = function () {\n\t\t\t\t\t// If previous callback exists, run it first in a chain\n\t\t\t\t\tprevOnLoad && prevOnLoad();\n\n\t\t\t\t\t// React to successful load of this resource\n\t\t\t\t\tnext(false);\n\t\t\t\t};\n\n\t\t\t\tres.onerror = function () {\n\t\t\t\t\t// If previous callback exists, run it first in a chain\n\t\t\t\t\tprevOnError && prevOnError();\n\n\t\t\t\t\t// React to failed load of this resource\n\t\t\t\t\tnext(true);\n\t\t\t\t}\n\n\t\t\t\t// Start it reloading\n\t\t\t\tres.reload();\n\t\t\t} else if (res.complete) {\n\t\t\t\t// Since the resource has already completed loading, go\n\t\t\t\t// ahead and invoke the next callback indicating the previous\n\t\t\t\t// success or failure.\n\t\t\t\tnext(res.failed === true);\n\t\t\t} else {\n\t\t\t\t// The comments above about onreload callback chaining equally\n\t\t\t\t// apply here.  See above.\n\t\t\t\tvar prevOnLoad = res.onload;\n\t\t\t\tvar prevOnError = res.onerror;\n\n\t\t\t\t// When the resource completes loading, either with success\n\t\t\t\t// or failure:\n\n\t\t\t\tres.onload = function() {\n\t\t\t\t\t// If previous callback exists, run it first in a chain\n\t\t\t\t\tprevOnLoad && prevOnLoad();\n\n\t\t\t\t\t// Reset fail flag\n\t\t\t\t\tres.failed = false;\n\n\t\t\t\t\t// React to successful load of this resource\n\t\t\t\t\tnext(false);\n\t\t\t\t};\n\n\t\t\t\tres.onerror = function() {\n\t\t\t\t\t// If previous callback exists, run it first in a chain\n\t\t\t\t\tprevOnError && prevOnError();\n\n\t\t\t\t\t// Set fail flag\n\t\t\t\t\tres.failed = true;\n\n\t\t\t\t\t// React to failed load of this resource\n\t\t\t\t\tnext(true);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tvar _timeout = null;\n\t\tsetTimeout(function() {\n\t\t\t// spin up n simultaneous loaders!\n\t\t\tfor (var i = 0; i < parallel; ++i) { loadResource(); }\n\t\t\t\n\t\t\t// register timeout call\n\t\t\tif (timeout) {\n\t\t\t\t_timeout = setTimeout(function() {\n\t\t\t\t\tcallback.fire();\n\t\t\t\t\tnumLoaded = numResources;\n\t\t\t\t}, timeout)\n\t\t\t}\n\t\t}, 0);\n\t\t\n\t\treturn callback;\n\t}\n});\n\nexports = new Loader();\n","pre":true},"sdk/timestep/AudioManager.js":{"path":"sdk/timestep/AudioManager.js","friendlyPath":"AudioManager","directory":"sdk/timestep/","filename":"AudioManager.js","baseMod":"AudioManager","basePath":"sdk/timestep/","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class Sound;\n * Implement the correct Audio support, depending on what platform we're running.\n *\n * @doc http://doc.gameclosure.com/api/sound.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/sound.md\n */\n\njsio(\"import device\");\njsio(\"import event.Emitter as Emitter\");\n\n// Allow accessibility controls (like muting).\n// TODO This should definitely be in another file.\nGLOBAL.ACCESSIBILITY = new (Class(Emitter, function (supr) {\n\tthis.muted = false;\n\n\tthis.mute = function (flag) {\n\t\tthis.muted = flag;\n\t\tthis.publish('MuteChange');\n\t};\n}));\nif (GLOBAL.ONACCESSIBLE) {\n\tGLOBAL.ONACCESSIBLE();\n}\n\n// Determine which API to include.\nif (device.isMobileBrowser && !device.simulatingMobileBrowser){\n\tjsio(\"import platforms.browser.MobileBrowserAPI\");\n\texports = platforms.browser.MobileBrowserAPI;\n} else {\n\texports = jsio('import ui.backend.sound.HTML5API');\n}\n","pre":true},"sdk/timestep/ui/backend/sound/HTML5API.js":{"path":"sdk/timestep/ui/backend/sound/HTML5API.js","friendlyPath":"ui.backend.sound.HTML5API","directory":"sdk/timestep/ui/backend/sound/","filename":"HTML5API.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// An API for playing named sounds. Sounds can be given a single file source\n// or multiple sources which will be chosen at random at play time. Sounds may\n// also be given a default volume and loop boolean.\n//\n// Only one background sound can be played at a time. They are streamed, not\n// preloaded, on native.\n\njsio(\"import event.Emitter as Emitter\");\njsio(\"import util.path\");\njsio(\"import device\");\n\n// \"Extend\" the local instance of Audio objects.\nRawAudio=__class__;var RawAudio=RawAudio(function RawAudio(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tvar audio = new Audio();\n\n\t\t// we can't really extend an HTML5 audio object in a browser, so\n\t\t// do our best...\n\t\tvar proto = RawAudio.prototype;\n\t\tfor (var i in proto) {\n\t\t\tif (!audio[i] && proto.hasOwnProperty(i)) {\n\t\t\t\taudio[i] = RawAudio.prototype[i];\n\t\t\t}\n\t\t}\n\n\t\t// Hook into accessibility features.\n\t\tGLOBAL.ACCESSIBILITY.subscribe('MuteChange', this, function () {\n\t\t\taudio.muted = GLOBAL.ACCESSIBILITY.muted;\n\t\t});\n\n\t\taudio.muted = GLOBAL.ACCESSIBILITY.muted;\n\n\t\treturn audio;\n\t};\n\n\t// add a stop method that resets the current time\n\tthis.stop = function () {\n\t\ttry {\n\t\t\t// html5 Audio object\n\t\t\tif (!this.paused) { this.pause(); }\n\n\t\t\t// if we have the NETWORK_LOADING flag, only restart currentTime if the sound has loaded.\n\t\t\t// http://scottdowne.wordpress.com/2010/08/17/no-more-exceptions/\n\t\t\tif ((!('NETWORK_LOADING' in this)\n\t\t\t\t\t|| this.networkState != this.NETWORK_LOADING\n\t\t\t\t\t|| this.networkState != this.NETWORK_NO_SOURCE)\n\t\t\t\t\t&& !isNaN(this.duration)) {\n\t\t\t\tthis.currentTime = 0;\n\t\t\t}\n\t\t} catch (e) {}\n\t};\n});\n\n/**\n * A sound object that can play one of a collection of audio sources.\n */\nMultiSound=__class__;var MultiSound=MultiSound(function MultiSound(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function (soundManager, name, opts) {\n\t\tthis._soundManager = soundManager;\n\t\tthis._name = name;\n\n\t\t// if a list of file names is given in sources, load them as alternative\n\t\t// clips for this sound. Else, assume the only clip for this sound\n\t\t// is the file with its same name\n\t\topts = typeof opts == 'string' ? {sources: [opts]} : (opts || {});\n\t\tvar srcList = opts.sources || [name];\n\t\tvar sources = this._sources = [];\n\n\t\tvar basePath = soundManager.getPath();\n\t\tvar ext = soundManager.getExt();\n\t\tvar extTestExp = new RegExp(ext + '$', 'i');\n\n\t\tvar loop = opts.loop || opts.background;\n\t\tvar volume = opts.volume !== undefined ? opts.volume : 1.0;\n\n\t\tfor (var i = 0, src; src = srcList[i]; ++i) {\n\n\t\t\t// file paths are relative to the base path\n\t\t\tvar fullPath = util.path.join(basePath, opts.path, src);\n\n\t\t\t// append the extension if not already provided\n\t\t\tif (!extTestExp.test(fullPath)) {\n\t\t\t\tfullPath += ext;\n\t\t\t}\n\n\t\t\tvar audio = new RawAudio();\n\t\t\tif (device.isMobileNative) {\n\t\t\t\t//if this isn't none on native, native will preload things like music, which is Not Good.\n\t\t\t\t//however this also prevents music from being played in Chrome (as of 23.0.1271.91)\n\t\t\t\t//so if we're actually on native, preload should be none, otherwise auto.\n\t\t\t\taudio.preload = 'none';\n\t\t\t}\n\t\t\taudio.loop = loop;\n\t\t\taudio.volume = volume;\n\t\t\taudio.isBackgroundMusic = opts.background;\n\t\t\taudio.src = fullPath;\n\n\t\t\t// TODO: what's this option for??\n\t\t\tif (opts.isLoaded && typeof audio.load == 'function') {\n\t\t\t\taudio.load();\n\t\t\t}\n\n\t\t\tsources.push(audio);\n\t\t}\n\n\t\tthis.isBackgroundMusic = opts.background;\n\t};\n\n\tthis.setVolume = function (volume) {\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.volume = volume;\n\t\t}\n\t};\n\n\tthis.stop = function () {\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.stop();\n\t\t}\n\t};\n\n\tthis.pause = function () {\n\t\tthis._isPaused = true;\n\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.pause();\n\t\t}\n\t};\n\n\tthis.play = function (opts) {\n\t\topts = opts || {};\n\t\tif (!this._isPaused) {\n\t\t\tthis.stop();\n\t\t} else {\n\t\t\tthis._isPaused = false;\n\t\t}\n\n\t\tvar src = this._getRandom();\n\t\tsrc.loop = opts.loop || this.isBackgroundMusic;\n\t\tsrc.play();\n\t\t\n\t\tif (src.muted) {\n\t\t\t// Chrome bug? Audio objects with muted set before they\n\t\t\t// are played won't be muted, so toggle the mute state\n\t\t\t// twice after calling play.\n\t\t\tsrc.muted = false;\n\t\t\tsrc.muted = true;\n\t\t}\n\t};\n\n\tthis._getRandom = function () {\n\t\tvar index = Math.random() * this._sources.length | 0;\n\t\treturn this._sources[index];\n\t};\n});\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_backend_sound_HTML5API=__class__;exports=sdk_timestep_ui_backend_sound_HTML5API(function sdk_timestep_ui_backend_sound_HTML5API(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function(opts) {\n\t\topts = opts || {};\n\n\t\tsupr(this, 'init', [opts]);\n\n\t\tthis.setPath(opts.path);\n\n\t\t//opts.map is deprecated in favor of opts.files\n\t\tthis._map = opts.files || opts.map;\n\t\tthis._sounds = {};\n\t\tthis._isMusicMuted = false;\n\t\tthis._areEffectsMuted = false;\n\t\tthis._currentMusic = null;\n\n\t\tif (opts.persist) {\n\t\t\tthis.persistState(opts.persist);\n\t\t}\n\n\t\t// determine whether browser supports mp3 or ogg. Default to mp3 if\n\t\t// both are supported. Native will return true for everything, but\n\t\t// on native, we store ogg files as .mp3 files, so return .mp3...\n\t\tvar sound = new Audio();\n\t\tthis._ext = sound.canPlayType(\"audio/mpeg\") ? '.mp3'\n\t\t\t: sound.canPlayType(\"audio/ogg\") ? '.ogg' : '';\n\n\t\tif (!this._ext) {\n\t\t\tthis._ext = '.mp3';\n\t\t\tlogger.log('warning: could not determine sound support type');\n\t\t}\n\n\t\t// add sounds to the audio API's list of sounds and\n\t\t// preload them if appropriate\n\t\tfor (var key in this._map) {\n\t\t\tvar item = this._map[key];\n\t\t\tthis.addSound(key, item);\n\t\t}\n\t};\n\n\tthis.getExt = function () { return this._ext; };\n\n\tthis.getPath = function (name) {\n\t\treturn (name) ? this._sounds[name].path : this._path;\n\t};\n\n\tthis.setPath = function (path) {\n\t\tif (path) {\n\t\t\tpath = path.replace(/\\/$/, '');\n\t\t}\n\n\t\tthis._path = path || '';\n\t};\n\n\tthis.addSound = function(name, opts) {\n\t\tthis._sounds[name] = new MultiSound(this, name, opts);\n\t};\n\n\t/* @internal for now\n\t */\n\tthis.persistState = function (key) {\n\t\tthis._key = key;\n\n\t\tvar value = localStorage.getItem(this._key);\n\t\tif (value) { try { value = JSON.parse(value); } catch (e) {} }\n\t\tif (value) {\n\t\t\tlogger.log('restoring audio api state');\n\t\t\tthis.setMusicMuted(value.isMusicMuted);\n\t\t\tthis.setEffectsMuted(value.areEffectsMuted);\n\t\t}\n\t};\n\n\t/* @internal for now\n\t */\n\tthis._persist = function () {\n\t\tif (this._key) {\n\t\t\tlocalStorage.setItem(this._key, JSON.stringify({\n\t\t\t\t\tisMusicMuted: this._isMusicMuted,\n\t\t\t\t\tareEffectsMuted: this._areEffectsMuted\n\t\t\t\t}));\n\t\t}\n\t};\n\n\tthis.getMuted = function () { return this._isMusicMuted && this._areEffectsMuted; };\n\tthis.getMusicMuted = function () { return this._isMusicMuted; };\n\tthis.getEffectsMuted = function () { return this._areEffectsMuted; };\n\n\t// global mute\n\tthis.setMuted = function (isMuted) {\n\t\tthis.setMusicMuted(isMuted);\n\t\tthis.setEffectsMuted(isMuted);\n\t};\n\n\tthis.setMusicMuted = function (isMusicMuted) {\n\t\tif (isMusicMuted == this._isMusicMuted) { return; }\n\t\tthis._isMusicMuted = isMusicMuted;\n\t\tthis._persist();\n\n\t\t// resume music on unmute\n\t\tif (this._currentMusic) {\n\t\t\tif (isMusicMuted) {\n\t\t\t\tthis._currentMusic.pause();\n\t\t\t} else {\n\t\t\t\tthis._currentMusic.play();\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setEffectsMuted = function (areEffectsMuted) {\n\t\tif (areEffectsMuted == this._areEffectsMuted) { return; }\n\t\tthis._areEffectsMuted = areEffectsMuted;\n\t\tthis._persist();\n\n\t\tif (areEffectsMuted) {\n\t\t\tfor (var key in this._sounds) {\n\t\t\t\tvar sound = this._sounds[key];\n\t\t\t\tif (!sound.isBackgroundMusic) {\n\t\t\t\t\tsound.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setVolume = function(name, volume) {\n\t\tvar sound = this._sounds[name];\n\t\tif (sound) {\n\t\t\tsound.setVolume(volume);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.getVolume = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (sound) {\n\t\t\tvar elem = sound._sources[0]; //first audio element\n\t\t\treturn Math.round(10 * elem.volume) / 10; //round to nearest tenth\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tthis.play = function (name, opts) {\n\t\tvar sound = this._sounds[name];\n\t\topts = opts || {};\n\t\tif (!sound) {\n\t\t\tlogger.log(\"warning: no sound of that name\");\n\t\t\treturn false;\n\t\t}\n\n\t\tvar isBackgroundMusic = sound.isBackgroundMusic;\n\t\tif (isBackgroundMusic) {\n\t\t\t// some platforms enforce only one simultaneous background music\n\t\t\t// (native) while others do not.  Enforce it always.\n\t\t\tif (this._currentMusic) {\n\t\t\t\tthis._currentMusic.stop();\n\t\t\t}\n\n\t\t\tthis._currentMusic = sound;\n\n\t\t\t// if we're muted, make sure to resume the music if we unmute\n\t\t\tif (!this._isMusicMuted) {\n\t\t\t\tsound.play(opts);\n\t\t\t}\n\t\t} else if (!this._areEffectsMuted) {\n\t\t\tsound.play(opts);\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tthis.pause = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (!sound) { return false; }\n\n\t\t// if we're muted and we pause the current music,\n\t\t// don't resume the music on unmute.\n\t\tif (this._currentMusic == sound) {\n\t\t\tthis._currentMusic = null;\n\t\t}\n\n\t\tsound.pause();\n\n\t\treturn true;\n\t};\n\n\tthis.stop = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (!sound) { return false; }\n\n\t\t// if we're muted and we pause the current music,\n\t\t// don't resume the music on unmute.\n\t\tif (this._currentMusic == sound) {\n\t\t\tthis._currentMusic = null;\n\t\t}\n\n\t\tsound.stop();\n\n\t\treturn true;\n\t};\n\n\t// @deprecated\n\tthis.playBackgroundMusic = this.play;\n\n\t// @deprecated\n\tthis.pauseBackgroundMusic = function () {\n\t\tthis._currentMusic && this._currentMusic.pause();\n\t};\n});\n","pre":true},"sdk/jsio/util/path.js":{"path":"sdk/jsio/util/path.js","friendlyPath":"util.path","directory":"sdk/jsio/util/","filename":"path.js","baseMod":"util","basePath":"sdk/jsio","pre":true,"src":"var util = jsio.__jsio.__util;\n\nexports.join = util.buildPath;\nexports.resolveRelativePath = util.resolveRelativePath;\nexports.splitPath = util.splitPath;\nexports.makeRelativePath = util.makeRelativePath;\nexports.splitExt = function(path) {\n\tvar res = exports.splitPath(path);\n\tvar i = res.filename.lastIndexOf('.');\n\tif (i == -1) {\n\t\tres.basename = res.filename;\n\t\tres.ext = '';\n\t} else {\n\t\tres.basename = res.filename.substring(0, i);\n\t\tres.ext = res.filename.substring(i);\n\t}\n\treturn res;\n}"},"sdk/timestep/ui/backend/dom/StackView.js":{"path":"sdk/timestep/ui/backend/dom/StackView.js","friendlyPath":".backend.dom.StackView","directory":"sdk/timestep/ui/backend/dom/","filename":"StackView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import ui.View\");\n\n/**\n * @extends timestep.dom.View\n */\nvar sdk_timestep_ui_backend_dom_StackView=__class__;exports=sdk_timestep_ui_backend_dom_StackView(function sdk_timestep_ui_backend_dom_StackView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis.stack = [];\n\t}\n\t\n\tthis.getCurrentView = function() {\n\t\tif (!this.stack.length) { return null; }\n\t\treturn this.stack[this.stack.length - 1];\n\t}\n\t\n\tthis.push = function(view, dontAnimate) {\n\t\t// don't animate the first (base) view of a stackview unless explicitly asked to\n\t\tif (!this.stack[0] && dontAnimate !== false) {\n\t\t\tdontAnimate = true;\n\t\t}\n\t\t\n\t\tvar current = this.getCurrentView();\n\t\tif (current) { this._hide(current, dontAnimate); }\n\t\tview.style.width = this.style.width;\n\t\tview.style.height = this.style.height;\n\t\tthis.stack.push(view);\n\t\tthis._show(view, dontAnimate);\n\t\treturn view;\n\t}\n\t\n\tthis._hide = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillDisappear');\n\t\tif (!dontAnimate) {\n\t\t\t// Prevent touches from triggering buttons/UI on the\n\t\t\t// disappearing view. Unfortunately, canHandleEvents()\n\t\t\t// doesn't affect subviews, so an overlay is added here\n\t\t\t// so that touches just don't go through while it animates out.\n\t\t\tvar overlay = new View({parent: view, zIndex: 100000});\n\t\t\tview.then({x: (backward ? 1 : -1) * view.style.width})\n\t\t\t\t.then(bind(this, 'removeSubview', view))\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidDisappear'))\n\t\t\t\t.then(bind(overlay, 'removeFromSuperview'));\n\t\t} else {\n\t\t\tthis.removeSubview(view);\n\t\t\tview.publish('ViewDidDisappear');\n\t\t}\n\t}\n\n\tthis._show = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillAppear');\n\t\tview.style.visible = true;\n\t\tif (!dontAnimate) {\n\t\t\tview.style.x = (backward ? -1 : 1) * this.style.width;\n\t\t\tthis.addSubview(view);\n\t\t\tview.then({x: 0})\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidAppear'));\n\t\t} else {\n\t\t\tthis.addSubview(view);\n\t\t\tview.style.x = 0;\n\t\t\tview.publish('ViewDidAppear');\n\t\t}\n\t}\n\t\n\tthis.pop = function(dontAnimate) {\n\t\tif (!this.stack.length) { return false; }\n\t\tvar view = this.stack.pop();\n\t\tthis._hide(view, dontAnimate, true);\n\t\t\n\t\tif (this.stack.length) {\n\t\t\tthis._show(this.stack[this.stack.length - 1], dontAnimate, true);\n\t\t}\n\t\t\n\t\treturn view;\n\t}\n\t\n\tthis.popAll = function(dontAnimate) {\n\t\twhile (this.stack[1]) {\n\t\t\tthis.pop(dontAnimate);\n\t\t}\n\t}\n});\n","pre":true},"sdk/timestep/ui/backend/dom/TextView.js":{"path":"sdk/timestep/ui/backend/dom/TextView.js","friendlyPath":".backend.dom.TextView","directory":"sdk/timestep/ui/backend/dom/","filename":"TextView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.backend.dom.TextView;\n *\n * TextView implementation for DOM.\n */\n\njsio(\"import ui.View as View\");\njsio(\"import device\");\n\n/**\n * @extends ui.View\n */\nvar sdk_timestep_ui_backend_dom_TextView=__class__;exports=sdk_timestep_ui_backend_dom_TextView(function sdk_timestep_ui_backend_dom_TextView(){return this.init&&this.init.apply(this,arguments)},View, function (supr) {\n\n\tthis._displayStyle = \"table\";\n\n\tvar defaults = {\n\t\t// layout properties...\n\t\twrap: true,\n\t\tautoSize: true,\n\t\tautoFontSize: true,\n\t\tverticalPadding: 0,\n\t\thorizontalPadding: 0,\n\t\tlineHeight: 1.2,\n\n\t\t// font properties...\n\t\tcolor: \"#000000\",\n\t\tfontFamily: device.defaultFontFamily,\n\t\tfontWeight: \"\",\n\t\tsize: 12,\n\t\tlineWidth: 2,\n\t\toutlineColor: null,\n\t\tshadowColor: null,\n\n\t\t// alignment properties...\n\t\tverticalAlign: \"middle\",\n\t\thorizontalAlign: \"center\",\n\n\t\t// misc properties...\n\t\tbackgroundColor: null\n\t};\n\n\tthis.init = function (opts) {\n\t\tsupr(this, \"init\", [merge(opts, defaults)]);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\topts = supr(this, \"updateOpts\", arguments);\n\n\t\tvar s = this.__view.getElement().style;\n\n\t\tif (opts.horizontalPadding) {\n\t\t\tif (isArray(opts.horizontalPadding)) {\n\t\t\t\ts.paddingLeft = opts.horizontalPadding[0] + \"px\";\n\t\t\t\ts.paddingRight = opts.horizontalPadding[0] + \"px\";\n\t\t\t} else {\n\t\t\t\ts.paddingLeft = opts.horizontalPadding + \"px\";\n\t\t\t\ts.paddingRight = opts.horizontalPadding + \"px\";\n\t\t\t}\n\t\t}\n\n\t\tif (opts.verticalPadding) {\n\t\t\tif (isArray(opts.verticalPadding)) {\n\t\t\t\ts.paddingTop = opts.verticalPadding[0] + \"px\";\n\t\t\t\ts.paddingBottom = opts.verticalPadding[0] + \"px\";\n\t\t\t} else {\n\t\t\t\ts.paddingTop = opts.verticalPadding + \"px\";\n\t\t\t\ts.paddingBottom = opts.verticalPadding + \"px\";\n\t\t\t}\n\t\t}\n\n\t\tif (opts.color)           { s.color = opts.color; }\n\t\tif (opts.size)            { s.fontSize = opts.size + \"px\"; }\n\t\tif (opts.fontFamily)      { s.fontFamily = opts.fontFamily; }\n\t\tif (opts.horizontalAlign) { s.textAlign = opts.horizontalAlign; }\n\t\tif (opts.fontWeight)      { s.fontWeight = opts.fontWeight; }\n\t\tif (opts.shadowColor)     { s.textShadow = opts.shadowColor + \" 2px 2px 1px\"; }\n\t\tif (opts.outlineColor)    { s.webkitTextStroke = opts.lineWidth + \"px \" + opts.outlineColor; }\n\t\tif (!opts.wrap)           { s.whiteSpace = \"nowrap\"; }\n\n\t\ts.display = \"table\";\n\n\t\tif (\"text\" in opts) this.setText(opts.text);\n\t};\n\n\tthis.getText = function() {\n\t\treturn this.__view.getElement().getElementsByTagName(\"span\")[0].innerHTML;\n\t}\n\n\tthis.reflow = function() {\n\t\tif (this._textNode && this._opts.autoSize) {\n\t\t\tvar idealHeight = this._textNode.scrollHeight;\n\t\t\tif (!this.style.height || this.style.height < idealHeight) {\n\t\t\t\tthis.style.height = idealHeight;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setText = function (text) {\n\t\tif (typeof text == \"function\") {\n\t\t\treturn text(this);\n\t\t}\n\n\t\tif (this._text != text) {\n\t\t\tthis._text = text;\n\t\t\tvar n = this._textNode || document.createElement(\"span\");\n\t\t\tif (!this._textNode) {\n\t\t\t\tthis._textNode = n;\n\t\t\t\tthis.__view.getElement().appendChild(n);\n\t\t\t\tn.className = \"text\";\n\t\t\t\tn.style.display = \"table-cell\";\n\t\t\t\tn.style.verticalAlign = this._opts.verticalAlign || \"middle\";\n\t\t\t}\n\t\t\tthis._textNode.innerText = text || \"\";\n\t\t\tthis.needsReflow();\n\t\t}\n\t};\n});\n","pre":true},"sdk/timestep/ui/backend/dom/ViewBacking.js":{"path":"sdk/timestep/ui/backend/dom/ViewBacking.js","friendlyPath":".backend.dom.ViewBacking","directory":"sdk/timestep/ui/backend/dom/","filename":"ViewBacking.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import device\");\njsio(\"import event.Callback as Callback\");\njsio(\"import animate\");\njsio(\"import animate.transitions as transitions\");\njsio(\"import event.input.InputEvent as InputEvent\");\njsio(\"import math.geom.Point as Point\");\njsio(\"from util.browser import $\");\n\njsio(\"import ..BaseBacking\");\n\nvar Canvas = device.get('Canvas');\n\nvar AVOID_CSS_ANIM = device.isAndroid;\n\n\nvar sdk_timestep_ui_backend_dom_ViewBacking=__class__;var ViewBacking = exports=sdk_timestep_ui_backend_dom_ViewBacking(function sdk_timestep_ui_backend_dom_ViewBacking(){return this.init&&this.init.apply(this,arguments)},BaseBacking, function() {\n\n\tvar arr = ['x', 'y', 'r', 'width', 'height', 'visible', 'anchorX', 'anchorY',\n\t\t\t   'opacity', 'scale', 'zIndex', 'scrollLeft', 'scrollTop', 'flipX', 'flipY'];\n\n\tvar CUSTOM_KEYS = {};\n\n\tarr.forEach(function (prop) {\n\t\tCUSTOM_KEYS[prop] = true;\n\n\t\tthis.__defineGetter__(prop, function() {\n\t\t\tif (prop in this._computed) {\n\t\t\t\treturn this._computed[prop];\n\t\t\t} else {\n\t\t\t\treturn parseInt(this._node.style[prop]);\n\t\t\t}\n\t\t});\n\t\tthis.__defineSetter__(prop, function(val) {\n\t\t\tvar props = {};\n\t\t\tprops[prop] = val;\n\t\t\tthis._setProps(props);\n\t\t\treturn val;\n\t\t});\n\t}, this);\n\n\tthis.init = function (view, opts) {\n\t\tthis._view = view;\n\t\tthis._subviews = [];\n\n\t\tvar n = this._node = document.createElement(opts.elementType || 'div');\n\n\t\t// used to identify dom nodes\n\t\tn._view = view;\n\t\tn.addEventListener(\"webkitTransitionEnd\", bind(this, \"_transitionEnd\"), false);\n\t\tn.className = \"view\" + \" \" + opts.className;\n\n\t\tvar s = n.style;\n\t\ts.fontSize = '1px';\n\t\ts.position = \"absolute\";\n\t\ts.top = \"0px\";\n\t\ts.left = \"0px\";\n\t\tif (!device.isAndroid) {\n\t\t\ts.webkitBackfaceVisibility = 'hidden';\n\t\t}\n\n\t\ts.webkitTransformOrigin = '0px 0px';\n\n\t\t// add any custom CSS style\n\t\tfor (var name in opts.styles) {\n\t\t\ts[name] = opts.styles[name];\n\t\t}\n\n\t\t// store for the computed styles\n\t\tthis._computed = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tr: 0,\n\t\t\twidth: undefined,\n\t\t\theight: undefined,\n\t\t\tanchorX: 0,\n\t\t\tanchorY: 0,\n\t\t\topacity: 1,\n\t\t\tvisible: true,\n\t\t\tzIndex: 0,\n\t\t\tscale: 1\n\t\t};\n\n\t\t// animation\n\t\tthis._animating = false;\n\t\tthis._animationQueue = [];\n\t\tthis._animationCallback = null;\n\t}\n\n\tthis.getElement = function () { return this._node; }\n\n\tvar ADD_COUNTER = 900000;\n\tthis.addSubview = function (view) {\n\t\tvar backing = view.__view;\n\t\tvar node = backing._node;\n\t\tvar superview = node.parentNode && node.parentNode._view;\n\t\tif (superview == this._view) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (superview) { superview.__view.removeSubview(view); }\n\t\t\tvar n = this._subviews.length;\n\t\t\tthis._subviews[n] = view;\n\t\t\tthis._node.appendChild(node);\n\n\t\t\tbacking._setAddedAt(++ADD_COUNTER);\n\t\t\tif (n && backing.__sortKey < this._subviews[n - 1].__view.__sortKey) {\n\t\t\t\tthis._needsSort = true;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tthis.removeSubview = function (targetView) {\n\t\tvar index = this._subviews.indexOf(targetView);\n\t\tif (index != -1) {\n\t\t\tthis._subviews.splice(index, 1);\n\t\t\tthis._node.removeChild(targetView.__view._node);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tthis.getSuperview = function() {\n\t\tvar p = this._node.parentNode;\n\t\tif (p == document.body || !p) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn p._view;\n\t}\n\n\tthis.getSubviews = function () {\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\treturn this._subviews;\n\t}\n\n\tthis.wrapTick = function(dt, app) {\n\t\tthis._view.tick && this._view.tick(dt, app);\n\n\t\tfor (var i = 0, view; view = this._subviews[i]; ++i) {\n\t\t\tview.__view.wrapTick(dt, app);\n\t\t}\n\t}\n\n\tthis.wrapRender = function(ctx, opts) {\n\t\tif (!this.visible) { return; }\n\n\t\tif (!this.__firstRender) { this._view.needsReflow(true); }\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\n\n\t\tvar width = this._computed.width;\n\t\tvar height = this._computed.height;\n\t\tif (!width || !height || width < 0 || height < 0) { return; }\n\n\t\t// var filters = this._view.getFilters();\n\t\t// ctx.setFilters(filters);\n\n\t\ttry {\n\t\t\tvar render = this._view.render;\n\t\t\tif (render && !render.isFake) {\n\t\t\t\tif (!this._canvas) {\n\t\t\t\t\tvar canvas = new Canvas();\n\t\t\t\t\tthis._canvas = canvas;\n\t\t\t\t\tthis._node.insertBefore(this._canvas, this._node.firstChild);\n\t\t\t\t\tthis.ctx = this._canvas.getContext('2d');\n\t\t\t\t}\n\n\t\t\t\tvar needsRepaint = this._view._needsRepaint;\n\n\t\t\t\t// clear the canvas\n\t\t\t\tif ((width | 0) != this._canvas.width || (height | 0) != this._canvas.height) {\n\t\t\t\t\tneedsRepaint = true;\n\t\t\t\t\tthis._canvas.width = width;\n\t\t\t\t\tthis._canvas.height = height;\n\t\t\t\t}\n\n\t\t\t\tif (needsRepaint) {\n\t\t\t\t\tthis._view._needsRepaint = false;\n\t\t\t\t\tthis._canvas.style.display = 'none';\n\t\t\t\t\tthis.ctx.clear();\n\t\t\t\t\t// this.ctx.fillStyle = 'red';\n\t\t\t\t\t// this.ctx.fillRect(0, 0, 1000, 1000);\n\t\t\t\t\tthis.ctx.save();\n\t\t\t\t\trender.call(this._view, this.ctx, opts);\n\t\t\t\t\tthis.ctx.restore();\n\t\t\t\t\tthis._canvas.style.display = 'block';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderSubviews(ctx, opts);\n\t\t} catch(e) {\n\t\t \tlogger.error(this, e.message, e.stack);\n\t\t}\n\t}\n\n\tthis._renderSubviews = function(ctx, opts) {\n\t\tvar i = 0;\n\t\tvar view;\n\t\tvar subviews = this._subviews;\n\t\twhile (view = subviews[i++]) {\n\t\t\tview.__view.wrapRender(ctx, opts);\n\t\t}\n\t}\n\n\tthis.localizePoint = function(pt) {\n\t\tvar s = this._computed;\n\t\tpt.x -= s.x + s.anchorX;\n\t\tpt.y -= s.y + s.anchorY;\n\t\tif (s.r) { pt.rotate(-s.r); }\n\t\tpt.scale(1 / s.scale);\n\t\tpt.x += s.anchorX;\n\t\tpt.y += s.anchorY;\n\t\treturn pt;\n\t}\n\n\t// exports the current style object\n\tthis.copy = function() {\n\t\treturn merge({}, this._computed);\n\t}\n\n\tthis.update = function(style) { this._setProps(style); }\n\n\t//****************************************************************\n\t// ANIMATION\n\n\tfunction getEasing(fn) {\n\t\tif (typeof fn == 'string') { return fn; }\n\t\tif (fn == transitions.easeIn) { return 'ease-in'; }\n\t\tif (fn == transitions.easeOut) { return 'ease-out'; }\n\t\tif (fn == transitions.easeInOut) { return 'ease-in-out'; }\n\t\tif (fn == transitions.linear) { return 'linear'; }\n\t\treturn 'ease';\n\t};\n\n\tthis._updateOrigin = function () {\n\t\tvar s = this._node.style;\n\t\tif (this._circle) {\n\t\t\ts.webkitTransformOrigin = '50% 50%';\n\t\t} else {\n\t\t\ts.webkitTransformOrigin = (this._computed.anchorX || 0) + 'px ' + (this._computed.anchorY || 0) + 'px';\n\t\t}\n\n\t}\n\n\t// {\n\t// \t'x': {value: 0, cb: '_onPosition'},\n\t// \t'y': {value: 0, cb: '_onPosition'},\n\t// }\n\n\tthis._onPosition = function (key, value) {\n\t\tvalue = Math.floor(value);\n\t\tthis._setMatrix();\n\t}\n\n\tthis._onResize = function () {\n\t\t// order matters\n\t\tthis._setMatrix();\n\t\tthis._setCenter();\n\t\tthis._view.needsReflow();\n\t}\n\n\tthis._setProps = function (props, anim) {\n\t\tvar setMatrix = false;\n\t\tvar s = this._node.style;\n\t\tvar animCount = 0;\n\t\tvar resized = false;\n\t\tvar previous = {};\n\t\tfor (var key in props) {\n\t\t\tvar value = props[key];\n\t\t\tif (key == \"dx\" || key == \"dy\") {\n\t\t\t\tkey = key.substr(1);\n\t\t\t\tvalue = this._computed[key] + value;\n\t\t\t}\n\t\t\tswitch (key) {\n\t\t\t\tcase \"circle\":\n\t\t\t\t\tthis._circle = value;\n\t\t\t\t\tthis._setCenter();\n\t\t\t\t\tthis._updateOrigin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"anchorX\":\n\t\t\t\tcase \"anchorY\":\n\t\t\t\t\tthis._computed[key] = value;\n\t\t\t\t\tthis._updateOrigin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"clip\":\n\t\t\t\t\tthis._computed.clip = value;\n\t\t\t\t\ts.overflow = value ? 'hidden' : 'visible';\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zIndex\":\n\t\t\t\t\tif (this._computed.zIndex != value) {\n\t\t\t\t\t\tthis._computed.zIndex = value;\n\t\t\t\t\t\ts.zIndex = value;\n\t\t\t\t\t\tthis._onZIndex(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"x\":\n\t\t\t\tcase \"y\":\n\t\t\t\t\tvalue = Math.floor(value);\n\t\t\t\tcase \"r\":\n\t\t\t\tcase \"scale\":\n\t\t\t\t\tif (this._computed[key] != value) {\n\t\t\t\t\t\tprevious[key] = this._computed[key];\n\t\t\t\t\t\tthis._computed[key] = value;\n\t\t\t\t\t\tsetMatrix = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (this._computed[key] != value) {\n\t\t\t\t\t\t++animCount;\n\t\t\t\t\t    this._computed[key] = value;\n\t\t\t\t\t\tif (key == 'width' || key == 'height') {\n\t\t\t\t\t\t\ts[key] = value + 'px';\n\t\t\t\t\t\t\tresized = true;\n\t\t\t\t\t\t} else if (key == 'visible') {\n\t\t\t\t\t\t\ts.display = (value ? this._displayStyle || 'block' : 'none');\n\t\t\t\t\t\t\t//s.visibility = (value ? 'visible' : 'hidden');\n\t\t\t\t\t\t\t// chrome has an obscure rendering bug where visibility:hidden won't\n\t\t\t\t\t\t\t// hide the canvas element child nodes sometimes. If you set opacity to zero, it will.\n\t\t\t\t\t\t\t//s.opacity = (value ? this._computed['opacity'] : 0);\n\n\t\t\t\t\t\t} else if (key == 'opacity') {\n\t\t\t\t\t\t\ts[key] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts[key] = value;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!CUSTOM_KEYS[key]) {\n\t\t\t\t\t\t\t\tthis[key] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (setMatrix) {\n\t\t\t++animCount;\n\t\t\tif (AVOID_CSS_ANIM) {\n\t\t\t\tvar obj = {\n\t\t\t\t\tscale: previous.scale || this._computed.scale,\n\t\t\t\t\tr: previous.r || this._computed.r\n\t\t\t\t};\n\t\t\t\t// because of android bugs,\n\t\t\t\t// we must never animate -webkit-transform.\n\t\t\t\t// http://code.google.com/p/android/issues/detail?id=12451\n\t\t\t\tif (anim && ((obj.scale != this._computed.scale) ||\n\t\t\t\t\t\t\t (obj.r != this._computed.r))) {\n\t\t\t\t\t// logger.log('set transform animated', obj.scale, this._computed.scale, obj.r, this._computed.r);\n\t\t\t\t\tanimate(obj).now({\n\t\t\t\t\t\tscale: this._computed.scale,\n\t\t\t\t\t\tr: this._computed.r\n\t\t\t\t\t}, anim.duration, anim.easing, bind(this, function() {\n\t\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? obj.scale * -1 : obj.scale) +\n\t\t\t\t\t\t\t\t\t\t\t ',' + (this._computed.flipY ? obj.scale * -1 : obj.scale) + ') ' +\n\t\t\t\t\t\t\t\t\t\t\t 'rotate(' + obj.r + 'rad)');\n\t\t\t\t\t})).then(bind(this, function() {\n\t\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? obj.scale * -1 : obj.scale) +\n\t\t\t\t\t\t\t\t\t\t\t ',' + (this._computed.flipY ? obj.scale * -1 : obj.scale) + ') '  +\n\t\t\t\t\t\t\t\t\t\t\t 'rotate(' + this._computed.r + 'rad)');\n\t\t\t\t\t}));\n\n\t\t\t\t} else if ((obj.scale != this._computed.scale) ||\n\t\t\t\t\t\t   (obj.r != this._computed.r)) {\n\t\t\t\t\t// logger.log('set transform', this._computed.scale, this._computed.r);\n\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? this._computed.scale * -1 : this._computed.scale) +\n\t\t\t\t\t\t\t\t\t\t\t',' + (this._computed.flipY ? this._computed.scale * -1 : this._computed.scale) + ') ' +\n\t\t\t\t\t\t\t\t\t\t 'rotate(' + this._computed.r + 'rad)');\n\t\t\t\t}\n\t\t\t\t// use CSS animations for left and top though, since\n\t\t\t\t// those can still be taken out of javascript.\n\t\t\t\ts.left = (this._center ? -this.width / 2 | 0 : 0) + this._computed.x + 'px';\n\t\t\t\ts.top = (this._center ? -this.height / 2 | 0 : 0) + this._computed.y + 'px';\n\t\t\t} else {\n\t\t\t\tvar matrix = new WebKitCSSMatrix();\n\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\tthis._computed.x,\n\t\t\t\t\tthis._computed.y\n\t\t\t\t);\n\n\t\t\t\tmatrix = matrix.rotate(this._computed.r * 180 / 3.14159);\n\t\t\t\tmatrix = matrix.scale(this._computed.scale);\n\n\t\t\t\tif(this._computed.flipX || this._computed.flipY) {\n\t\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\t\tthis._computed.flipX ? -this._computed.width : 0,\n\t\t\t\t\t\tthis._computed.flipY ? this._computed.height / 2 : 0\n\t\t\t\t\t);\n\t\t\t\t\tmatrix = matrix.scale(\n\t\t\t\t\t\tthis._computed.flipX ? -1 : 1,\n\t\t\t\t\t\tthis._computed.flipY ? -1 : 1\n\t\t\t\t\t);\n\t\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\t\tthis._computed.flipX ? this._computed.width : 0,\n\t\t\t\t\t\tthis._computed.flipY ? -this._computed.height / 2 : 0\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// on iOS, forcing a 3D matrix provides huge performance gains.\n\t\t\t\t// Rotate it about the y axis 360 degrees to achieve this.\n\t\t\t\tmatrix = matrix.rotate(0, 360, 0);\n\t\t\t\ts.WebkitTransform = matrix;\n\t\t\t}\n\n\t\t}\n\t\tif (resized) {\n\t\t\tthis._onSizeChanged && this._onSizeChanged();\n\t\t}\n\n\t\treturn animCount;\n\t};\n\n\tthis._setCenter = function() {\n\t\tvar s = this._node.style;\n\t\tvar origin = {\n\t\t\tx: (!this._circle ? 0 : -(this.width / 2 | 0)),\n\t\t\ty: (!this._circle ? 0 : -(this.height / 2 | 0))\n\t\t};\n\t\tif (AVOID_CSS_ANIM) {\n\t\t\torigin.x += this._computed.x;\n\t\t\torigin.y += this._computed.y;\n\t\t}\n\t\ts.left = origin.x + 'px';\n\t\ts.top = origin.y + 'px';\n\t}\n\n\tthis._onSizeChanged = function() {\n\t\tthis._setCenter();\n\t\tthis._view.needsReflow();\n\t}\n\n\t// ----- zIndex -----\n\n\tvar LEN_Z = 8;\n\tvar MAX_Z = 99999999;\n\tvar MIN_Z = -99999999;\n\tvar PAD = \"00000000\";\n\n\tthis._sortIndex = \"00000000\";\n\n\tthis._onZIndex = function(zIndex) {\n\t\tzIndex = ~~zIndex;\n\n\t\tif (zIndex < MIN_Z) { zIndex = this._zIndex = MIN_Z; }\n\t\tif (zIndex > MAX_Z) { zIndex = this._zIndex = MAX_Z; }\n\t\tif (zIndex < 0) {\n\t\t\tzIndex *= -1;\n\t\t\tthis._sortIndex = '-' + PAD.substring(0, LEN_Z - ('' + zIndex).length) + zIndex;\n\t\t} else {\n\t\t\tthis._sortIndex = PAD.substring(0, LEN_Z - ('' + zIndex).length) + zIndex;\n\t\t}\n\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setAddedAt = function(addedAt) {\n\t\tthis._addedAt = addedAt;\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setSortKey = function() {\n\t\tthis.__sortKey = this._sortIndex + this._addedAt;\n\t}\n\n\t// ----- ANIMATION -----\n\n\tthis._transitionEnd = function (evt) {\n\t\t$.stopEvent(evt);\n\t\tif (this.transitionCallback.fired()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.transitionCallback.fire();\n\t\tthis.transitionCallback.reset();\n\n\t\tif (evt) {\n\t\t\tevt.cancelBubble = true;\n\t\t} else if (this._transitionEndTimeout) {\n\t\t\tthis._transitionEndTimeout = null;\n\t\t}\n\n\t\tthis._node.style.webkitTransition = \"none\";\n\n\t\tthis._animating = false;\n\t\tif (this._animationCallback) {\n\t\t\tvar callback = this._animationCallback;\n\t\t\tthis._animationCallback = null;\n\t\t\tcallback();\n\t\t}\n\n\t\tthis._processAnimation();\n\t};\n\n\n\tthis._processAnimation = function (doNow) {\n\t\tif (this._animationQueue.length == 0 || this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tif (doNow) {\n\t\t\t\tclearTimeout(this._queuedTimeout);\n\t\t\t\tthis._queuedTimeout = null;\n\t\t}\n\t\tif (this._queuedTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tif (!doNow) {\n\t\t\tif (!this._queuedTimeout) {\n\t\t\t\tthis._queuedTimeout = setTimeout(bind(this, function() {\n\t\t\t\t\tthis._queuedTimeout = false;\n\t\t\t\t\tthis._processAnimation(true);\n\t\t\t\t}), 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar anim = this._animationQueue.shift();\n\t\tswitch (anim.type) {\n\t\tcase \"animate\":\n\t\t\tvar s = this._node.style;\n\t\t\tif (AVOID_CSS_ANIM) {\n\t\t\t\ts.webkitTransitionProperty = \"left, top, opacity, width, height\";\n\t\t\t} else {\n\t\t\t\ts.webkitTransitionProperty = \"-webkit-transform, opacity, width, height\";\n\t\t\t}\n\t\t\ts.webkitTransitionDuration = (anim.duration|0) + \"ms\";\n\t\t\ts.webkitTransitionTimingFunction = getEasing(anim.easing);\n\t\t\tthis._setProps(anim.props, anim);\n\n\t\t\t// fall through\n\t\tcase \"wait\":\n\t\t\tthis._animating = true;\n\t\t\tthis._animationCallback = anim.callback || null;\n\n\t\t\tthis.transitionCallback = new Callback();\n\n\t\t\tthis.transitionCallback.runOrTimeout(function() {\n\t\t\t\t// if webkitTransitionEnd fires, do nothing\n\t\t\t}, bind(this, function(evt) {\n\t\t\t\t// webkitTransitionEnd is too late, baby, it's too late\n\t\t\t\tthis._transitionEnd(evt);\n\t\t\t}), anim.duration);\n\t\t\tbreak;\n\t\tcase \"callback\":\n\t\t\t//logger.log('doing callback', anim.callback, doNow);\n\t\t\tanim.callback();\n\t\t\tif (!this._animating) {\n\t\t\t\tthis._processAnimation();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t};\n\n\tthis.getQueue = function() {\n\t\treturn [];\n\t}\n\tthis.getAnimation = function() {\n\t\treturn this;\n\t}\n\n\tthis.animate = function() {\n\t\tif (!arguments[0]) {\n\t\t\treturn this;\n\t\t}\n\t\treturn this.next.apply(this, arguments);\n\t}\n\n\tthis.clear = function() {\n\t\tthis.transitionCallback && this.transitionCallback.fire();\n\t\tif (this._transitionEndTimeout) {\n\t\t\tclearTimeout(this._transitionEndTimeout);\n\t\t}\n\t\tthis._animationQueue = [];\n\t\tthis._animationCallback = null;\n\t\tthis._animating = false;\n\t\treturn this;\n\t};\n\n\tthis.finishNow = function() {\n\t\tthis._node.style.webkitTransition = 'none';\n\t\t// TODO: this isn't really right; you need to actually finish the queue\n\n\t\treturn this;\n\t}\n\n\tvar DURATION = 600;\n\n\tthis.pause = function() {\n\t\tthis._isPaused = true;\n\t}\n\n\tthis.resume = function() {\n\t\tthis._isPaused = false;\n\t\tthis._processAnimation();\n\t}\n\n\tthis.animate = function (props, duration, easing, callback) {\n\t\t//this.clear();\n\t\treturn this.then(props, duration, easing, callback);\n\t};\n\n\tthis.now = function (props, duration, easing, callback) {\n\t\tthis.clear();\n\t\treturn this.then(props, duration, easing, callback);\n\t}\n\n\tthis.then = function (props, duration, easing, callback) {\n\t\tif (arguments.length == 1 && typeof props === 'function') {\n\t\t\treturn this.callback(props);\n\t\t}\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"animate\",\n\t\t\tprops: props,\n\t\t\tduration: duration || DURATION,\n\t\t\tcallback: callback && bind(this, callback),\n\t\t\teasing: easing\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.callback = function(fn) {\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"callback\",\n\t\t\tduration: 0,\n\t\t\tcallback: fn && bind(this, fn)\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t}\n\n\tthis.wait = function (duration, callback) {\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"wait\",\n\t\t\tduration: duration,\n\t\t\tcallback: callback\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.fadeIn = function (duration, callback) {\n\t\tthis.show();\n\n\t\tif (this._node.style.opacity == 1) {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.then({\n\t\t\topacity: 1\n\t\t}, duration, null, callback);\n\t\treturn this;\n\t};\n\n\tthis.fadeOut = function (duration, callback) {\n\t\tif (this._node.style.opacity == 0) {\n\t\t\tthis.hide();\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.then({\n\t\t\topacity: 0\n\t\t}, duration, null, bind(this, function () {\n\t\t\tthis.hide();\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}));\n\n\t\treturn this;\n\t};\n\n});\n\n","pre":true},"sdk/timestep/ui/backend/canvas/ImageView.js":{"path":"sdk/timestep/ui/backend/canvas/ImageView.js","friendlyPath":".backend.canvas.ImageView","directory":"sdk/timestep/ui/backend/canvas/","filename":"ImageView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package ui.backend.canvas.ImageView;\n *\n * canvas.ImageView implementation.\n */\n\njsio(\"import util.path\");\njsio(\"import std.uri as URI\");\n\njsio(\"import ui.View as View\")\njsio(\"import ui.resource.Image as Image\");\n\n/**\n * @extends ui.View\n */\nvar sdk_timestep_ui_backend_canvas_ImageView=__class__;var ImageView = exports=sdk_timestep_ui_backend_canvas_ImageView(function sdk_timestep_ui_backend_canvas_ImageView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\n\t/** \n\t * Options:\n\t *   autoSize - See .setImage()\n\t */\n\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\t\topts = merge(opts, {\n\t\t\timage: null,\n\t\t\tautoSize: false\n\t\t});\n\t\t\n\t\tif (opts.image) {\n\t\t\tthis.setImage(opts.image, opts);\n\t\t}\n\t};\n\n\t/**\n\t * Return this view's Image object.\n\t */\n\n\tthis.getImage = function() {\n\t\treturn this._img;\n\t};\n\n\t/**\n\t * Set the image of the view from an Image object or string.\n\t * Options:\n\t *   autoSize - Automatically set view size from image dimensions.\n\t */\n\n\tthis.setImage = function(img, opts) {\n\t\tif (typeof img == 'string') {\n\t\t\tthis._img = new Image({url: img});\n\t\t} else {\n\t\t\tthis._img = img;\n\t\t}\n\n\t\tif (this._img) {\n\t\t\tif (opts && opts.autoSize) {\n\t\t\t\t// sprited resources will know their dimensions immediately\n\t\t\t\tif (this._img.getWidth() > 0 && this._img.getHeight() > 0) {\n\t\t\t\t\tthis.autoSize();\n\t\t\t\t} else {\n\t\t\t\t\t// non-sprited resources need to load first\n\t\t\t\t\tthis._img.doOnLoad(this, 'autoSize');\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._img.doOnLoad(this, 'needsRepaint');\n\t\t}\n\t};\n\n\t/**\n\t * Pass a function to load once the Image object is loaded, or a list of\n\t * arguments that call lib.Callback::run() implicitly.\n\t */\n\t\n\tthis.doOnLoad = function() {\n\t\tif (arguments.length == 1) {\n\t\t\tthis._img.doOnLoad(this, arguments[0]);\n\t\t} else {\n\t\t\tthis._img.doOnLoad.apply(this._img, arguments);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Automatically resize the view to the size of the image.\n\t */\n\t\n\tthis.autoSize = function() {\n\t\tif (this._img) {\n\t\t\tthis.style.width = this._img.getWidth();\n\t\t\tthis.style.height = this._img.getHeight();\n\n\t\t\tif (this.style.fixedAspectRatio) {\n\t\t\t\tthis.style.updateAspectRatio();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get original width of the Image object.\n\t */\n\t\n\tthis.getOrigWidth = this.getOrigW = function () {\n\t\treturn this._img.getOrigW();\n\t};\n\n\t/**\n\t * Get original height of the Image object.\n\t */\n\n\tthis.getOrigHeight = this.getOrigH = function () {\n\t\treturn this._img.getOrigH();\n\t};\n\n\t/**\n\t * Render this image onto a canvas.\n\t */\n\n\tthis.render = function(ctx) {\n\t\tif (!this._img) { return; }\n\n\t\tvar s = this.style;\n\t\tvar w = s.width;\n\t\tvar h = s.height;\n\t\tthis._img.render(ctx, 0, 0, w, h);\n\t}\n\n\t/**\n\t * Return a human-readable tag for this view.\n\t */\n\n\tvar _loc = window.location.toString();\n\tvar _host = window.location.hostname;\n\t\n\tthis.getTag = function() {\n\t\tvar tag;\n\t\tif (this._img) {\n\t\t\tvar url = this._img.getOriginalURL();\n\t\t\tif (this._cachedTag && url == this._cachedTag.url) {\n\t\t\t\ttag = this._cachedTag.tag;\n\t\t\t} else {\n\t\t\t\tvar uri = URI.relativeTo(url, _loc);\n\t\t\t\tvar host = uri.getHost();\n\t\t\t\ttag = util.path.splitExt(uri.getFile()).basename + (host && host != _host ? ':' + host : '');\n\n\t\t\t\tthis._cachedTag = {\n\t\t\t\t\turl: url,\n\t\t\t\t\ttag: tag\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\treturn (tag || '') + ':ImageView' + this.uid;\n\t}\n});\n\n","pre":true},"sdk/timestep/ui/backend/canvas/TextView.js":{"path":"sdk/timestep/ui/backend/canvas/TextView.js","friendlyPath":".backend.canvas.TextView","directory":"sdk/timestep/ui/backend/canvas/","filename":"TextView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package ui.backend.canvas.TextView;\n *\n * canvas.TextView implementation.\n */\n\njsio(\"import ui.View as View\");\njsio(\"import ui.layout.Padding as Padding\");\njsio(\"import device\");\njsio(\"import .util.FragmentBuffer as FragmentBuffer\");\njsio(\"import .TextFlow\");\n\njsio(\"import ...legacySettings as legacySettings\");\n\nvar messageMultiline = true;\nvar messageTextAlign = true;\nvar messageFont = true;\n\n/**\n * @extends ui.View\n */\nvar sdk_timestep_ui_backend_canvas_TextView=__class__;var TextView = exports=sdk_timestep_ui_backend_canvas_TextView(function sdk_timestep_ui_backend_canvas_TextView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\n\tvar defaults = {\n\t\t// layout properties...\n\t\twrap: false,\n\t\tautoSize: false,\n\t\tautoFontSize: true,\n\t\tpadding: new Padding(0),\n\t\tlineHeight: 1.2,\n\n\t\t// font properties...\n\t\tcolor: \"#000000\",\n\t\tfontFamily: device.defaultFontFamily,\n\t\tfontWeight: \"\",\n\t\tsize: 12,\n\t\tlineWidth: 2,\n\t\toutlineColor: null,\n\t\tshadowColor: null,\n\n\t\t// alignment properties...\n\t\tverticalAlign: \"middle\",\n\t\thorizontalAlign: \"center\",\n\n\t\t// misc properties...\n\t\tbackgroundColor: null\n\t};\n\n\tvar clearCache = {\n\t\t// basic widget properties...\n\t\twidth: true,\n\t\theight: true,\n\n\t\t// layout properties...\n\t\twrap: true,\n\t\tautoSize: true,\n\t\tautoFontSize: true,\n\t\tpadding: true,\n\t\tlineHeight: true,\n\n\t\t// font properties...\n\t\tcolor: false,\n\t\tfontFamily: true,\n\t\tfontWeight: true,\n\t\tsize: true,\n\t\tlineWidth: false,\n\t\toutlineColor: false,\n\t\tshadowColor: false,\n\n\t\t// alignment properties...\n\t\tverticalAlign: true,\n\t\thorizontalAlign: true,\n\n\t\t// misc properties...\n\t\tbackgroundColor: false,\n\t\ttext: true\n\t};\n\tvar clearCacheKeys = Object.keys(clearCache);\n\n\tvar savedOpts = [\n\t\t\"width\",\n\t\t\"height\",\n\t\t\"size\"\n\t];\n\n\tvar fontBuffer = new FragmentBuffer();\n\n\tfontBuffer.onGetHash = function (desc) {\n\t\tif (!desc.hash) {\n\t\t\tvar i = clearCacheKeys.length;\n\t\t\tdesc.hash = \"\";\n\t\t\twhile (i) {\n\t\t\t\tdesc.hash += desc[clearCacheKeys[--i]] || \"\";\n\t\t\t}\n\t\t}\n\t\treturn desc.hash;\n\t};\n\n\tthis.init = function (opts) {\n\t\tthis._opts = {};\n\t\tthis._optsLast = {};\n\t\tthis._cacheUpdate = true;\n\n\t\tthis._textFlow = new TextFlow({target: this});\n\t\tthis._textFlow.subscribe(\"ChangeWidth\", this, \"onChangeWidth\");\n\t\tthis._textFlow.subscribe(\"ChangeHeight\", this, \"onChangeHeight\");\n\t\tthis._textFlow.subscribe(\"ChangeSize\", this, \"onChangeSize\");\n\n\t\tsupr(this, 'init', [merge(opts, defaults)]);\n\t};\n\n\tthis.onChangeWidth = function (width) {\n\t\tthis.updateOpts({width: width}, true);\n\t};\n\n\tthis.onChangeHeight = function (height) {\n\t\tthis.updateOpts({height: height}, true);\n\t};\n\n\tthis.onChangeSize = function (size, ctx) {\n\t\tthis.updateOpts({size: size}, true);\n\t\tif (ctx) {\n\t\t\tctx.font = this._opts.fontWeight + \" \" + this._opts.size + \"px \" + this._opts.fontFamily;\n\t\t}\n\t};\n\n\t// These options might have been changed to make the text fit, restore them...\n\tthis._restoreOpts = function () {\n\t\tvar optsLast = this._optsLast;\n\t\tvar optsKey;\n\t\tvar i = savedOpts.length;\n\t\twhile (i) {\n\t\t\toptsKey = savedOpts[--i];\n\t\t\tif (optsKey in optsLast) {\n\t\t\t\tthis._opts[optsKey] = optsLast[optsKey];\n\t\t\t}\n\t\t}\n\t};\n\n\t// Check if the cache should be updated...\n\tthis._checkOpts = function (opts) {\n\t\tvar optsLast = this._optsLast;\n\t\tvar optsKey;\n\t\tvar i = clearCacheKeys.length;\n\n\t\tthis._cacheUpdate = !Object.keys(this._opts).length;\n\t\twhile (i) {\n\t\t\toptsKey = clearCacheKeys[--i];\n\t\t\tif ((optsKey in opts) && clearCache[optsKey] && (optsLast[optsKey] !== opts[optsKey])) {\n\t\t\t\tthis._cacheUpdate = true;\n\t\t\t}\n\t\t\tif (optsKey in opts) {\n\t\t\t\toptsLast[optsKey] = opts[optsKey];\n\t\t\t} else if (optsKey in this._opts) {\n\t\t\t\toptsLast[optsKey] = this._opts[optsKey];\n\t\t\t} else {\n\t\t\t\toptsLast[optsKey] = defaults[optsKey];\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._checkDeprecatedOpts = function (opts) {\n\t\topts.allowVerticalSizing = !legacySettings.disableVerticalAutoSize;\n\n\t\tif (\"multiline\" in opts) {\n\t\t\tif (DEBUG && messageMultiline) {\n\t\t\t\tconsole.warn(\"TextView opts.multiline is deprecated, please use wrap...\");\n\t\t\t\tmessageMultiline = false;\n\t\t\t}\n\t\t\topts.wrap = opts.multiline;\n\t\t}\n\t\tif (\"textAlign\" in opts) {\n\t\t\tif (DEBUG && messageTextAlign) {\n\t\t\t\tconsole.warn(\"TextView opts.multiline is deprecated, please use wrap...\");\n\t\t\t\tmessageTextAlign = false;\n\t\t\t}\n\t\t\topts.horizontalAlign = opts.textAlign;\n\t\t}\n\t\tvar font = opts.font;\n\t\tif (font) {\n\t\t\tif (DEBUG && messageFont) {\n\t\t\t\tconsole.warn(\"TextView opts.font is deprecated, please use fontFamily and size...\");\n\t\t\t\tmessageFont = false;\n\t\t\t}\n\t\t\twhile (font.length && (font[0] === ' ')) {\n\t\t\t\tfont = font.substr(1 - font.length);\n\t\t\t}\n\t\t\tvar i = font.indexOf(' ');\n\t\t\tif (i !== -1) {\n\t\t\t\topts.size = parseInt(font.substr(0, i).replace(/[pxtem\\s]/gi, ''), 10);\n\t\t\t\topts.fontFamily = font.substr(i + 1 - font.length);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.updateOpts = function (opts, dontCheck) {\n\t\tthis._checkDeprecatedOpts(opts);\n\n\t\tif (\"padding\" in opts) {\n\t\t\tthis.style.padding = new Padding(opts.padding);\n\t\t}\n\n\t\tif (!dontCheck) {\n\t\t\tthis._restoreOpts();\n\t\t\tthis._checkOpts(opts);\n\t\t\tif (this._cacheUpdate) {\n\t\t\t\topts.hash = false;\n\t\t\t} else {\n\t\t\t\tsupr(this, 'updateOpts', arguments);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\topts = supr(this, 'updateOpts', arguments);\n\n\t\t(\"text\" in opts) && this.setText(opts.text);\n\t\t!dontCheck && this._textFlow.setOpts(this._opts);\n\n\t\treturn opts;\n\t};\n\n\tthis._updateCtx = function (ctx) {\n\t\tvar opts = this._opts;\n\n\t\tctx.textBaseline = \"top\";\n\t\tctx.fillStyle = opts.color;\n\t\tctx.font = opts.fontWeight + \" \" + opts.size + \"px \" + opts.fontFamily;\n\t\tctx.lineWidth = opts.lineWidth;\n\t};\n\n\tthis._renderToCtx = function (ctx, offsetX, offsetY) {\n\t\tvar opts = this._opts;\n\t\tvar cache = this._textFlow.getCache();\n\t\tvar maxWidth = opts.autoFontSize ? this._textFlow.getActualWidth() : 1000000;\n\t\tvar item;\n\t\tvar word;\n\t\tvar color = opts.color;\n\t\tvar strokeColor = opts.strokeStyle;\n\t\tvar outlineColor = opts.outlineColor;\n\t\tvar shadowColor = opts.shadowColor;\n\t\tvar lineOffset = opts.lineWidth / 2;\n\t\tvar x, y;\n\t\tvar i = cache.length;\n\n\t\tif (legacySettings.textViewColor && this.color) {\n\t\t\tcolor = this.color;\n\t\t}\n\n\t\tthis._updateCtx(ctx);\n\n\t\tif (strokeColor) {\n\t\t\tctx.strokeStyle = strokeColor;\n\t\t}\n\n\t\twhile (i) {\n\t\t\titem = cache[--i];\n\t\t\tword = item.word;\n\t\t\tx = offsetX + item.x;\n\t\t\ty = offsetY + item.y;\n\n\t\t\tif (strokeColor) {\n\t\t\t\tctx.strokeText(word, x, y, maxWidth);\n\t\t\t}\n\t\t\tif (outlineColor) {\n\t\t\t\tctx.fillStyle = outlineColor;\n\t\t\t\tctx.fillText(word, x - lineOffset, y, maxWidth);\n\t\t\t\tctx.fillText(word, x + lineOffset, y, maxWidth);\n\t\t\t\tctx.fillText(word, x, y - lineOffset, maxWidth);\n\t\t\t\tctx.fillText(word, x, y + lineOffset, maxWidth);\n\t\t\t}\n\t\t\tif (shadowColor) {\n\t\t\t\tctx.fillStyle = shadowColor;\n\t\t\t\tctx.fillText(word, x + lineOffset, y + lineOffset, maxWidth);\n\t\t\t}\n\n\t\t\tctx.fillStyle = color;\n\t\t\tctx.fillText(word, x, y, maxWidth);\n\t\t}\n\t};\n\n\tthis._renderBuffer = function (ctx) {\n\t\tvar opts = this._opts;\n\t\tvar fonctBufferCtx = fontBuffer.getContext();\n\t\tvar offsetRect = this._textFlow.getOffsetRect();\n\t\tvar width = offsetRect.width;\n\t\tvar height = offsetRect.height;\n\t\tvar cache = this._textFlow.getCache();\n\t\tvar desc;\n\n\t\topts.lineCount = cache[cache.length - 1].line;\n\t\tdesc = fontBuffer.getPositionForText(opts);\n\t\tif (desc != null) {\n\t\t\tthis._cacheUpdate && this._renderToCtx(fonctBufferCtx, desc.x - offsetRect.x, desc.y - offsetRect.y);\n\t\t\tctx.drawImage(fontBuffer.getCanvas(), desc.x, desc.y, width, height, offsetRect.x, offsetRect.y, width, height);\n\t\t} else {\n\t\t\tthis._opts.buffered = false;\n\t\t}\n\t};\n\n\tthis.render = function (ctx) {\n\t\tvar opts = this._opts;\n\n\t\tif (this._cacheUpdate) {\n\t\t\tthis._updateCtx(ctx);\n\t\t\tthis._textFlow.reflow(ctx, 1 + (opts.autoFontSize ? 4 : 0) + (opts.autoSize ? 2 : 0) + (opts.wrap ? 1 : 0));\n\t\t}\n\t\tif (!this._textFlow.getCache().length) {\n\t\t\tthis._cacheUpdate = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._opts.buffer && (fontBuffer !== null)) {\n\t\t\tthis._renderBuffer(ctx);\n\t\t} else {\n\t\t\tthis._renderToCtx(ctx, 0, 0);\n\t\t}\n\n\t\tthis._cacheUpdate = false;\n\t};\n\n\tthis.clearBuffers = function() {\n\t\tvar ctx;\n\n\t\tif (fontBuffer !== null) {\n\t\t\tctx = fontBuffer.getContext();\n\t\t\tctx.clear();\n\t\t\tctx.globalCompositeOperation = \"source-over\";\n\n\t\t\tfontBuffer.clearBuffer();\n\t\t}\n\t};\n\n\tthis.getFontBuffer = function() {\n\t\treturn fontBuffer;\n\t};\n\n\tthis.setText = function (text) {\n\t\tthis._restoreOpts();\n\t\tthis._opts.text = (text != undefined) ? text.toString() : '';\n\t\tthis._cacheUpdate = true;\n\t\tthis.needsRepaint();\n\t};\n\n\tthis.getText = function () {\n\t\treturn this._opts.text;\n\t};\n\n\tthis.getTag = function() {\n\t\treturn \"TextView\" + this.uid + \":\" + (this._lines && this._lines.join(\" \").substring(0, 20));\n\t};\n\n\tthis.reflow = function () {\n\t\tthis._restoreOpts();\n\t\tthis._cacheUpdate = true;\n\t};\n});\n\nexports.clearBuffers = TextView.prototype.clearBuffers;\nexports.getFontBuffer = TextView.prototype.getFontBuffer;\n","pre":true},"sdk/timestep/ui/layout/Padding.js":{"path":"sdk/timestep/ui/layout/Padding.js","friendlyPath":"ui.layout.Padding","directory":"sdk/timestep/ui/layout/","filename":"Padding.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @package ui.layout.Padding;\n *\n * A simple class to express padding views.\n */\n\nPadding=__class__;exports = Padding=Padding(function Padding(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init =\n\tthis.update = function (args) {\n\t\tif (args instanceof Padding) {\n\t\t\tthis.top = args.top;\n\t\t\tthis.right = args.right;\n\t\t\tthis.bottom = args.bottom;\n\t\t\tthis.left = args.left;\n\t\t\treturn;\n\t\t}\n\t\tif (typeof args == 'string') {\n\t\t\targs = args.split(/\\s+/).map(function (piece) { return parseFloat(piece); });\n\t\t}\n\n\t\tif (!args || !args.length) { args = [args || 0]; }\n\n\t\tswitch (args.length) {\n\t\t\tcase 1:\n\t\t\t\tthis.left = this.right = this.top = this.bottom = args[0];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.top = this.bottom = args[0];\n\t\t\t\tthis.left = this.right = args[1];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.top = args[0];\n\t\t\t\tthis.left = this.right = args[1];\n\t\t\t\tthis.bottom = args[2];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tthis.top = args[0];\n\t\t\t\tthis.right = args[1];\n\t\t\t\tthis.bottom = args[2];\n\t\t\t\tthis.left = args[3];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis.getVertical = function () { return this.top + this.bottom; }\n\tthis.getHorizontal = function () { return this.left + this.right; }\n\n\tthis.toString = function () { return [this.top, this.right, this.bottom, this.left].join(' '); }\n});","pre":true},"sdk/timestep/ui/backend/canvas/util/FragmentBuffer.js":{"path":"sdk/timestep/ui/backend/canvas/util/FragmentBuffer.js","friendlyPath":".util.FragmentBuffer","directory":"sdk/timestep/ui/backend/canvas/util/","filename":"FragmentBuffer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import device\");\njsio(\"import .FragmentBin\");\njsio(\"import .SortedLinkedList as SortedList\");\n\nvar sdk_timestep_ui_backend_canvas_util_FragmentBuffer=__class__;var FragmentBuffer = exports=sdk_timestep_ui_backend_canvas_util_FragmentBuffer(function sdk_timestep_ui_backend_canvas_util_FragmentBuffer(){return this.init&&this.init.apply(this,arguments)},function () {\n\tvar debug = false;\n\tthis.init = function (opts) {\n\t\tthis.opts = merge(opts, {});\n\t};\n\n\tvar sort = function (a, b) {\n\t\treturn a.size() > b.size();\n\t};\n\n\tthis._build = function () {\n\t    var Canvas = device.get('Canvas');\n        this._canvas = new Canvas({width: 1024, height: 1024});\n        this._ctx = this.getCanvas().getContext('2d');\n\t\tthis._ctx.clearRect(0, 0, 1024, 1024);\n\t\tthis._ctx.textAlign = 'left';\n\t\tthis._ctx.textBaseline = 'middle';\n\t\tthis._ctx.globalCompositeOperation = 'source-over';\n\t\tthis._cache = {};\n\t\tthis._binList = new SortedList(sort);\n\t\tvar head = new FragmentBin({\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: 1024,\n\t\t\theight: 1024\n\t\t});\n\t\tthis._binList.insert(head);\n\t};\n\n\tthis.getCanvas = function () {\n\t\tif (!this._canvas) {\n\t\t\tthis._build();\n\t\t}\n\t\treturn this._canvas;\n\t};\n\n\tthis.getContext = function () {\n\t\tif (!this._ctx) {\n\t\t\tthis._build();\n\t\t}\n\t\treturn this._ctx;\n\t};\n\n\tthis.onGetHash = function (desc) {\n\t\tthrow Error(\"onGetHash should be implemented.\");\n\t};\n\n\tvar randomColor = function () {\n\t\tvar color = 'rgba(' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t'0.3)';\n\t\treturn color;\n\t};\n\n\tthis._insertText = function (desc) {\n\t\tvar width = desc.width;\n\t\tvar height = desc.height;\n\t\tvar iter = this._binList.iterator();\n\t\tvar bin = null;\n\t\tvar found = false;\n\t\twhile (iter.hasNext() && !found) {\n\t\t\tbin = iter.next();\n\t\t\tif (!bin.filled && bin.width >= width && bin.height >= height) {\n\t\t\t\tfound = true;\n\t\t\t} else {\n\t\t\t\t//we don't want to insert in filled bins\n\t\t\t\tbin = null;\n\t\t\t}\n\t\t}\n\t\tif (bin) {\n\t\t\tnewBins = bin.split(width, height);\n\t\t\tfor (var i = 0; i < newBins.length; i++) {\n\t\t\t\tthis._binList.insert(newBins[i]);\n\t\t\t}\n\t\t\tif (debug) {\n\t\t\t\t/*\n\t\t\t\t* If we're debugging, fill each bin with a different color\n\t\t\t\t* so we can see where they are.\n\t\t\t\t*/\n\t\t\t\tthis._ctx.fillStyle = randomColor();\n\t\t\t\tthis._ctx.fillRect(bin.x, bin.y, bin.width, bin.height);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.log('buffer full, further TextViews will not be cached');\n\t\t}\n\t\treturn bin;\n\t};\n\n\t/**\n\t* debugging code to verify overlapping bins aren't created.\n\t*/\n\tvar rectIntersectsRect = function (r1, r2) {\n\t\tvar ax1 = r1.x;\n\t\tvar ax2 = r1.x + r1.width;\n\t\tvar ay1 = r1.y;\n\t\tvar ay2 = r1.y + r1.height;\n\t\tvar bx1 = r2.x;\n\t\tvar bx2 = r2.x + r2.width;\n\t\tvar by1 = r2.y;\n\t\tvar by2 = r2.y + r2.height;\n\t\treturn ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\n\t};\n\n\tvar debugCheck = function (bin, list) {\n\t\tif (!bin) { return;}\n\t\tvar iter = list.iterator();\n\t\tvar ok = true;\n\t\twhile (iter.hasNext() && ok) {\n\t\t\tvar next = iter.next();\n\t\t\tok = next == bin || !rectIntersectsRect(next, bin);\n\t\t\tif (!ok) {\n\t\t\t\tlogger.error('rect overlaps');\n\t\t\t\tlogger.error(iter.current(), bin);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.getPositionForText = function (desc) {\n\t\tvar hash = this.onGetHash(desc);\n\n\t\tif (!this._cache[hash] && desc.width > 0) {\n\t\t\tthis._cache[hash] = this._insertText(desc);\n\t\t}\n\t\tif (debug && false) {\n\t\t\tdebugCheck(desc, this._binHead);\n\t\t}\n\t\treturn this._cache[hash];\n\t};\n\n\tthis.clearBuffer = function () {\n\t\tthis._cache = {};\n\t\tthis._binList = new SortedList(sort);\n\t\tthis._binList.insert(new FragmentBin({\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: 1024,\n\t\t\theight: 1024\n\t\t}));\n\t};\n});","pre":true},"sdk/timestep/ui/backend/canvas/util/FragmentBin.js":{"path":"sdk/timestep/ui/backend/canvas/util/FragmentBin.js","friendlyPath":".FragmentBin","directory":"sdk/timestep/ui/backend/canvas/util/","filename":"FragmentBin.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * TextBins are used in the FragmentBuffer caching of TextViews.\n **/\nvar sdk_timestep_ui_backend_canvas_util_FragmentBin=__class__;var FragmentBin = exports=sdk_timestep_ui_backend_canvas_util_FragmentBin(function sdk_timestep_ui_backend_canvas_util_FragmentBin(){return this.init&&this.init.apply(this,arguments)},'TextBin', function(logger, supr) {\n\tthis.init = function(opts) {\n\t\tthis.width = opts.width;\n\t\tthis.height = opts.height;\n\t\tthis.x = opts.x;\n\t\tthis.y = opts.y;\n\t};\n\n\tthis.size = function() {\n\t\treturn this.width * this.height;\n\t};\n\n\tthis.split = function(x, y) {\n\t\tvar newBins = [this];\n\t\tif (this.width > 10 && this.height > 10) {\n\t\t\tif (this.height - y > 10) {\n\t\t\t\tvar bin1 = new FragmentBin({\n\t\t\t\t\tx: this.x,\n\t\t\t\t\ty: this.y + y,\n\t\t\t\t\twidth: this.width,\n\t\t\t\t\theight: this.height - y\n\t\t\t\t});\n\t\t\t\tnewBins.push(bin1);\n\t\t\t}\n\t\t\tif (this.width -x > 10) {\n\t\t\t\tvar bin2 = new FragmentBin({\n\t\t\t\t\tx: this.x + x,\n\t\t\t\t\ty: this.y,\n\t\t\t\t\twidth: this.width - x,\n\t\t\t\t\theight: y\n\t\t\t\t});\n\t\t\t\tnewBins.push(bin2);\n\t\t\t}\n\t\t}\n\t\tthis.width = x;\n\t\tthis.height = y;\n\t\tthis.filled = true;\n\n\t\treturn newBins;\n\t};\n});","pre":true},"sdk/timestep/ui/backend/canvas/util/SortedLinkedList.js":{"path":"sdk/timestep/ui/backend/canvas/util/SortedLinkedList.js","friendlyPath":".SortedLinkedList","directory":"sdk/timestep/ui/backend/canvas/util/","filename":"SortedLinkedList.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nIterator=__class__;var Iterator=Iterator(function Iterator(){return this.init&&this.init.apply(this,arguments)},'Iterator', function(logger, supr) {\n\tthis.init = this.update = function(list) {\n\t\tthis._list = list || this._list;\n\t\tthis._current = list.head;\n\t\tthis._count = 0;\n\t};\n\n\tthis.next = function() {\n\t\tvar data = this._current.data;\n\t\tthis._current = this._current.next;\n\t\tthis._count++;\n\t\treturn data;\n\t};\n\n\tthis.current = function() {\n\t\treturn this._current.data;\n\t};\n\n\tthis.insertBefore = function(data) {\n\t\tthis._current.insertBefore(data);\t\n\t\tthis._list.count++;\n\t};\n\n\tthis.insertAfter = function(data) {\n\t\tthis._current.insertAfter(data);\t\n\t\tthis._list.count++;\n\t};\n\n\tthis.remove = function() {\n\t\tthis._current.prev.remove();\n\t\tif (this._current.prev == this._current) {\n\t\t\tthis._list.head = null;\n\t\t}\n\t\tthis._list.count--;\n\t};\n\n\tthis.hasNext = function() {\n\t\treturn this._count < this._list.count;\n\t};\n\n\tthis.atHead = function() {\n\t\treturn this._current == this._list.head;\n\t};\n});\n\nItem=__class__;var Item=Item(function Item(){return this.init&&this.init.apply(this,arguments)},'Item', function(logger, supr) {\n\tthis.init = function(data, prev, next) {\n\t\tthis.data = data;\n\t\tthis.prev = prev || this; \n\t\tthis.next = next || this;\n\t};\n\n\tthis.insertBefore = function(data) {\n\t\tvar item = new Item(data, this.prev, this);\n\t\tthis.prev.next = item;\n\t\tthis.prev = item;\n\t};\n\t\n\tthis.insertAfter = function(data) {\n\t\tvar item = new Item(data, this, this.next);\n\t\tthis.next.prev = item;\n\t\tthis.next = item;\n\t};\n\n\tthis.remove = function() {\n\t\tthis.prev.next = this.next;\n\t\tthis.next.prev = this.prev;\n\t};\n});\n\nvar sdk_timestep_ui_backend_canvas_util_SortedLinkedList=__class__;exports=sdk_timestep_ui_backend_canvas_util_SortedLinkedList(function sdk_timestep_ui_backend_canvas_util_SortedLinkedList(){return this.init&&this.init.apply(this,arguments)},'SortedLinkedList', function(logger, supr) {\n\tthis.init = function(comparator) {\n\t\tthis.head = null;\n\t\tthis._comparator = comparator;\n\t\tthis.count = 0;\n\t};\n\n\tthis.append = function(data) {\n\t\tthis._head.insertAfter(data);\n\t\tthis.count++;\n\t};\n\n\tthis.insert = function(data) {\n\t\tif (!this.head) {\n\t\t\tthis.head = new Item(data);\n\t\t\tthis.count++;\n\t\t} else {\n\t\t\tvar i = this.iterator();\n\t\t\tvar d = i.current();\t\n\t\t\tvar found = false;\n\t\t\twhile (i.hasNext() && !found) {\n\t\t\t\tfound = !this._comparator(data, d);\n\t\t\t\tif (!found) {\n\t\t\t\t\ti.next();\t\n\t\t\t\t\td = i.current();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti.insertBefore(data);\n\t\t\tif (found && i.atHead()) {\n\t\t\t\tthis.head = this.head.prev;\t\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.iterator = function() {\n\t\treturn new Iterator(this);\n\t};\n});\n","pre":true},"sdk/timestep/ui/backend/canvas/TextFlow.js":{"path":"sdk/timestep/ui/backend/canvas/TextFlow.js","friendlyPath":".TextFlow","directory":"sdk/timestep/ui/backend/canvas/","filename":"TextFlow.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.Enum as Enum\");\njsio(\"import lib.PubSub as PubSub\");\n\nvar textFlowMode = Enum(\n\t\"NONE\",\n\t\"WRAP\",\n\t\"AUTOSIZE\",\n\t\"AUTOSIZE_WRAP\",\n\t\"AUTOFONTSIZE\",\n\t\"AUTOFONTSIZE_WRAP\",\n\t\"AUTOFONTSIZE_AUTOSIZE\",\n\t\"AUTOFONTSIZE_WRAP_AUTOSIZE\"\n);\n\nvar sdk_timestep_ui_backend_canvas_TextFlow=__class__;var TextFlow = exports=sdk_timestep_ui_backend_canvas_TextFlow(function sdk_timestep_ui_backend_canvas_TextFlow(){return this.init&&this.init.apply(this,arguments)},PubSub, function (supr) {\n\tthis.init = function (opts) {\n\t\tsupr(this, \"init\", arguments);\n\n\t\tthis._target = opts.target;\n\t\tthis._lineWidth = 0;\n\t\tthis._line = [];\n\t\tthis._lines = [];\n\n\t\tthis._cache = [];\n\t\tthis._cacheSize = 0;\n\n\t\tthis._maxWordWidth = 0;\n\t\tthis._maxWidth = 0;\n\t\tthis._maxHeight = 0;\n\n\t\tthis._heightFound = -1;\n\n\t\tthis._offsetRect = {x: 0, y: 0, width: 0, height: 0};\n\t};\n\n\t// Split the text into a list containing the word and the width of the word...\n\tthis._lineSplit = function (ctx) {\n\t\tvar spaceWidth = ctx.measureText(\" \").width;\n\t\tvar opts = this._opts;\n\t\tvar text = opts.text || \"\";\n\t\tvar words = (opts.wrap || (opts.horizontalAlign === \"justify\")) ? (text.replace(/\\t/g, \" \").match(/\\S+|[\\n]| +(?= )/g) || []) : text.split(\"\\n\");\n\t\tvar word;\n\t\tvar currentWord = 0;\n\t\tvar wordCount = words.length;\n\n\t\tthis._line = [];\n\t\tthis._lineWidth = 0;\n\t\tthis._maxWordWidth = 0;\n\n\t\twhile (currentWord < wordCount) {\n\t\t\tword = {word: words[currentWord], width: ctx.measureText(words[currentWord]).width, line: 1};\n\t\t\tthis._line.push(word);\n\t\t\tthis._lineWidth += word.width + spaceWidth;\n\t\t\tthis._maxWordWidth = Math.max(this._maxWordWidth, word.width);\n\t\t\tcurrentWord++;\n\t\t}\n\t\tthis._lineWidth -= spaceWidth;\n\t};\n\n\tthis._measureWords = function (ctx) {\n\t\tvar spaceWidth = ctx.measureText(\" \").width;\n\t\tvar currentWord = 0;\n\t\tvar wordCount = this._line.length;\n\n\t\tthis._lineWidth = 0;\n\t\tthis._maxWordWidth = 0;\n\n\t\twhile (currentWord < wordCount) {\n\t\t\tword = this._line[currentWord];\n\t\t\tword.line = 1;\n\t\t\tword.width = ctx.measureText(word.word).width;\n\t\t\tthis._lineWidth += word.width + spaceWidth;\n\t\t\tthis._maxWordWidth = Math.max(this._maxWordWidth, word.width);\n\t\t\tcurrentWord++;\n\t\t}\n\t\tthis._lineWidth -= spaceWidth;\n\t};\n\n\t// Split the single line into multiple lines which fit into the available width...\n\tthis._wrap = function (ctx, width) {\n\t\tvar spaceWidth = ctx.measureText(\" \").width;\n\t\tvar word;\n\t\tvar currentWidth = 0;\n\t\tvar lines = [];\n\t\tvar line = [];\n\t\tvar s = \"\";\n\n\t\tthis._lines = lines;\n\t\tthis._maxWidth = 0;\n\n\t\tvar currentWord = 0;\n\t\tvar wordCount = this._line.length;\n\n\t\tif (this._opts.horizontalAlign === \"justify\") {\n\t\t\twhile (currentWord < wordCount) {\n\t\t\t\tword = this._line[currentWord++];\n\t\t\t\tcurrentWidth += word.width + spaceWidth;\n\t\t\t\tif (word.word === \"\\n\") {\n\t\t\t\t\tlines.push(line);\n\t\t\t\t\tline = [];\n\t\t\t\t\tcurrentWidth = 0;\n\t\t\t\t} else if (currentWidth > width) {\n\t\t\t\t\tline.length && lines.push(line);\n\t\t\t\t\tline = [word];\n\t\t\t\t\tcurrentWidth = word.width + spaceWidth;\n\t\t\t\t} else {\n\t\t\t\t\tline.push(word);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tline.length && lines.push(line);\n\t\t} else {\n\t\t\twhile (currentWord < wordCount) {\n\t\t\t\tword = this._line[currentWord++];\n\t\t\t\tcurrentWidth = ctx.measureText(s).width;\n\t\t\t\tif (word.word === \"\\n\") {\n\t\t\t\t\tlines.push([{word: s, width: currentWidth, line: lines.length}]);\n\t\t\t\t\ts = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tif (currentWidth + word.width + spaceWidth > width) {\n\t\t\t\t\t\t(s !== \"\") && lines.push([{word: s, width: currentWidth, line: lines.length}]);\n\t\t\t\t\t\ts = word.word;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts += (s !== \"\" ? \" \" : \"\") + word.word;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (s !== \"\") {\n\t\t\t\tlines.push([{word: s, width: ctx.measureText(s).width, line: lines.length}]);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._getLineSize = function (lineCount) {\n\t\tvar opts = this._opts;\n\t\treturn ((lineCount <= 1) ? 1 : opts.lineHeight) * opts.size;\n\t};\n\n\t// Calculate the position of each word on the line...\n\tthis._wordFlow = function (ctx) {\n\t\tvar spaceWidth = ctx.measureText(\" \").width;\n\t\tvar lines = this._lines;\n\n\t\tthis._cache = [];\n\t\tthis._cacheSize = 0;\n\n\t\tthis._maxWidth = 0;\n\t\tthis._maxHeight = 0;\n\n\t\tvar currentLine = 0;\n\t\tvar lineCount = lines.length;\n\t\tvar lineSize = this._getLineSize(lineCount);\n\t\tvar y = 0;\n\n\t\twhile (currentLine < lineCount) {\n\t\t\tvar line = lines[currentLine++];\n\t\t\tvar currentWord = 0;\n\t\t\tvar wordCount = line.length;\n\t\t\tvar x = 0;\n\n\t\t\twhile (currentWord < wordCount) {\n\t\t\t\tvar word = line[currentWord++];\n\n\t\t\t\tword.x = x;\n\t\t\t\tword.y = y;\n\t\t\t\tword.line = currentLine;\n\t\t\t\tthis._cache[this._cacheSize++] = word;\n\n\t\t\t\tx += word.width + spaceWidth;\n\t\t\t}\n\n\t\t\ty += lineSize;\n\t\t\tx -= spaceWidth;\n\n\t\t\tthis._maxWidth = Math.max(this._maxWidth, x);\n\t\t\tthis._maxHeight = Math.max(this._maxHeight, y);\n\t\t}\n\t};\n\n\t// Check if the given width fits into the available size, if not the resize the font...\n\tthis._checkWidth = function (ctx, width) {\n\t\tif (this._opts.text === \"\") {\n\t\t\treturn false;\n\t\t}\n\t\tvar opts = this._opts;\n\n\t\tif (width > this.getActualWidth()) {\n\t\t\tvar size = (opts.size * this._target.style.width / width) | 0;\n\t\t\t(opts.size !== size) && this.publish(\"ChangeSize\", size, ctx);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis._checkHeight = function (ctx, loSize, hiSize, cb) {\n\t\tif (this._opts.text === \"\") {\n\t\t\treturn;\n\t\t}\n\t\tif (Math.abs(hiSize - loSize) < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar pivot = Math.max((loSize + hiSize) >> 1, 1);\n\t\tthis.publish(\"ChangeSize\", pivot, ctx);\n\t\tcb();\n\t\tif (pivot === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar opts = this._opts;\n\t\tvar lineSize = this._getLineSize(this._lines.length);\n\t\tif ((this._lines.length * lineSize > this.getActualHeight())) {\n\t\t\tthis._checkHeight(ctx, loSize, pivot, cb);\n\t\t} else {\n\t\t\tthis._heightFound = opts.size;\n\t\t\tthis._checkHeight(ctx, pivot, hiSize, cb);\n\t\t}\n\t};\n\n\tthis._horizontalAlign = function (ctx) {\n\t\tvar paddingLeft = this.getPaddingLeft();\n\t\tvar spaceWidth = ctx.measureText(\" \").width;\n\t\tvar div = {left: -1, center: 2, right: 1, justify: 3}[this._opts.horizontalAlign];\n\t\tvar cache = this._cache;\n\t\tvar actualWidth = this.getActualWidth();\n\t\tvar width;\n\t\tvar offset;\n\t\tvar line;\n\t\tvar x;\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\t\tif (div === 3) {\n\t\t\tspaceWidth = 0;\n\t\t}\n\n\t\tvar firstWordOnLine;\n\t\tvar currentWord = 0;\n\t\tvar wordCount = cache.length;\n\t\twhile (currentWord < wordCount) {\n\t\t\tfirstWordOnLine = currentWord;\n\t\t\tline = cache[currentWord].line;\n\t\t\twidth = 0;\n\t\t\twhile ((currentWord < wordCount) && (line === cache[currentWord].line)) {\n\t\t\t\twidth += cache[currentWord].width + spaceWidth;\n\t\t\t\tcurrentWord++;\n\t\t\t}\n\t\t\tif (div === -1) { // left...\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine++].x += paddingLeft;\n\t\t\t\t}\n\t\t\t} else if (div === 3) { // justify...\n\t\t\t\toffset = (line < cache[cache.length - 1].line) ? (actualWidth - width) / (currentWord - firstWordOnLine - 1) : spaceWidth;\n\t\t\t\tx = paddingLeft;\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine].x = x;\n\t\t\t\t\tx += cache[firstWordOnLine].width + offset;\n\t\t\t\t\tfirstWordOnLine++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toffset = (actualWidth - width + spaceWidth) / div + paddingLeft;\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine++].x += offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._verticalAlign = function () {\n\t\tvar lineCount = this._lines.length;\n\t\tvar div = {top: -1, middle: 2, bottom: 1}[this._opts.verticalAlign];\n\t\tvar cache = this._cache;\n\t\tvar actualHeight = this.getActualHeight();\n\t\tvar offset;\n\t\tvar i = cache.length;\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (div === -1) {\n\t\t\toffset = this.getPaddingTop();\n\t\t} else {\n\t\t\tvar lineSize = this._getLineSize(lineCount);\n\t\t\toffset = (actualHeight - lineCount * lineSize) / div + this.getPaddingTop();\n\t\t}\n\t\twhile (i) {\n\t\t\tcache[--i].y += offset;\n\t\t}\n\n\t\tthis._offsetRect.y += offset;\n\t};\n\n\tthis.reflow = function (ctx, mode) {\n\t\tvar opts = this._opts;\n\t\tvar actualWidth = this.getActualWidth();\n\t\tvar actualHeight = this.getActualHeight();\n\n\t\tthis._lineSplit(ctx);\n\n\t\tswitch (mode) {\n\t\t\tcase textFlowMode.NONE:\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOSIZE:\n\t\t\tcase textFlowMode.AUTOFONTSIZE_AUTOSIZE:\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualWidth < this._maxWidth) && this.publish(\"ChangeWidth\", this._maxWidth + this.getHorizontalPadding());\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOSIZE_WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualWidth < this._maxWidth) && this.publish(\"ChangeWidth\", this._maxWidth + this.getHorizontalPadding());\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE:\n\t\t\t\tthis._checkWidth(ctx, this._lineWidth) && this._lineSplit(ctx);\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\t// Don't use the lineHeight here because it's a single line\n\t\t\t\tif (opts.allowVerticalSizing && opts.size > this.getActualHeight()) {\n\t\t\t\t\tvar cb = bind(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tthis._measureWords(ctx);\n\t\t\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._checkHeight(ctx, 1, opts.size, cb);\n\t\t\t\t\tthis.publish(\"ChangeSize\", this._heightFound, ctx);\n\t\t\t\t\tcb();\n\t\t\t\t} else {\n\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE_WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tif (this._checkWidth(ctx, this._maxWordWidth)) {\n\t\t\t\t\tthis._lineSplit(ctx);\n\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t}\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\tvar lineCount = this._lines.length;\n\t\t\t\tvar lineSize = this._getLineSize(lineCount);\n\t\t\t\tif (opts.allowVerticalSizing && lineCount * lineSize > this.getActualHeight()) {\n\t\t\t\t\tvar cb = bind(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tthis._measureWords(ctx);\n\t\t\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._checkHeight(ctx, 1, opts.size, cb);\n\t\t\t\t\tthis.publish(\"ChangeSize\", this._heightFound, ctx);\n\t\t\t\t\tcb();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE_WRAP_AUTOSIZE:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tif (this._checkWidth(ctx, this._maxWordWidth)) {\n\t\t\t\t\tthis._lineSplit(ctx);\n\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t}\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar cache = this._cache;\n\t\tvar lastCacheItem = cache[cache.length - 1];\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar lineSize = this._getLineSize(this._lines.length);\n\t\tthis._offsetRect.x = 0;\n\t\tthis._offsetRect.y = 0;\n\t\tthis._offsetRect.width = this.getActualWidth();\n\t\tthis._offsetRect.height = lastCacheItem.line * lineSize;\n\n\t\tthis._horizontalAlign(ctx);\n\t\tthis._verticalAlign();\n\n\t\tif (lastCacheItem.line === 1) {\n\t\t\tthis._offsetRect.x = cache[0].x;\n\t\t\tthis._offsetRect.width = lastCacheItem.x + lastCacheItem.width - cache[0].x;\n\t\t}\n\t};\n\n\tthis.setOpts = function (opts) {\n\t\tthis._opts = opts;\n\t};\n\n\tthis.getCache = function () {\n\t\treturn this._cache;\n\t};\n\n\tthis.getHorizontalPadding = function () {\n\t\tvar padding = this._target.style.padding;\n\n\t\treturn padding.left + padding.right;\n\t};\n\n\tthis.getPaddingLeft = function () {\n\t\treturn this._target.style.padding.left;\n\t};\n\n\tthis.getActualWidth = function () {\n\t\treturn this._target.style.width - this.getHorizontalPadding();\n\t};\n\n\tthis.getVerticalPadding = function () {\n\t\tvar padding = this._target.style.padding;\n\n\t\treturn padding.top + padding.bottom;\n\t};\n\n\tthis.getPaddingTop = function () {\n\t\treturn this._target.style.padding.top;\n\t};\n\n\tthis.getActualHeight = function () {\n\t\treturn this._target.style.height - this.getVerticalPadding();\n\t};\n\n\tthis.getOffsetRect = function () {\n\t\treturn this._offsetRect;\n\t};\n});\n","pre":true},"sdk/timestep/ui/legacySettings.js":{"path":"sdk/timestep/ui/legacySettings.js","friendlyPath":"...legacySettings","directory":"sdk/timestep/ui/","filename":"legacySettings.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nexports = {\n\tdisableVerticalAutoSize: false,\n\ttextViewColor: false // use this.color in TextView if true\n}\n","pre":true},"sdk/timestep/ui/backend/canvas/ViewDebugger.js":{"path":"sdk/timestep/ui/backend/canvas/ViewDebugger.js","friendlyPath":".backend.canvas.ViewDebugger","directory":"sdk/timestep/ui/backend/canvas/","filename":"ViewDebugger.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import std.js as JS\");\n\nvar sdk_timestep_ui_backend_canvas_ViewDebugger=__class__;exports=sdk_timestep_ui_backend_canvas_ViewDebugger(function sdk_timestep_ui_backend_canvas_ViewDebugger(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\tthis.init = function(target, opts) {\n\t\tthis._target = target;\n\t\tthis._opts = opts = JS.merge(opts, {\n\t\t\ttrackClicks: false,\n\t\t\toutline: false,\n\t\t\tflash: false\n\t\t});\n\t\t\n\t\tthis.outline = opts.outline;\n\t\tthis.trackClicks = opts.trackClicks;\n\t\tthis.flash = opts.flash;\n\t\t\n\t\tthis._flashState = 0;\n\t\tthis._nextFlash = 0;\n\t}\n\t\n\tthis.preRender = function(ctx) {\n\t\tif (!this._time) { this._time = +new Date(); }\n\t\tvar prevTime = this._time;\n\t\tthis._time = +new Date();\n\t\tthis._dt = this._time - prevTime;\n\t\t\n\t\tvar s = this._target.style;\n\t\tif (this.outline) {\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = 0.2;\n\t\t\tctx.strokeStyle = 'black';\n\t\t\tif (this._target._circle) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(0, 0, s.radius, 0, 360, false);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t} else {\n\t\t\t\tctx.lineWidth = 1.0;\n\t\t\t\tctx.strokeRect(0, 0, s.width, s.height);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n\t\n\tthis.postRender = function(ctx) {\n\t\t\tvar s = this._target.style;\n\n\t\tvar t = this._target;\n\t\tif (this.trackClicks) {\n\t\t\tfor (var i = t._clicks.length - 1; i >= 0; --i) {\n\t\t\t\tvar c = t._clicks[i];\n\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, ' + c.o + ')');\n\t\t\t\tc.o -= 0.4 * this._dt / 1000;\n\t\t\t\tif (c.o > 0) {\n\t\t\t\t\tctx.circle(c.x, c.y, 15);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else {\n\t\t\t\t\tt._clicks.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.flash) {\n\t\t\tswitch(this._flashState) {\n\t\t\t\tcase 0:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0.5)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tctx.setFillStyle('rgba(255, 255, 255, 0.5)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0)');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvar now = +new Date();\n\t\t\tif (now > this._nextFlash) {\n\t\t\t\tthis._flashState = (this._flashState + 1) % 4;\n\t\t\t\tthis._nextFlash = now + 300;\n\t\t\t}\n\t\t\t\n\t\t\tif (t._circle) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tctx.fillRect(0, 0, t.style.width, t.style.height);\n\t\t\t}\n\t\t}\n\t}\n});\n","pre":true},"sdk/timestep/ui/init.js":{"path":"sdk/timestep/ui/init.js","friendlyPath":"ui.init","directory":"sdk/timestep/ui/","filename":"init.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import .View\");\njsio(\"import .layout.BackingExtension\");\njsio(\"import .Engine\");","pre":true},"sdk/timestep/ui/layout/BackingExtension.js":{"path":"sdk/timestep/ui/layout/BackingExtension.js","friendlyPath":".layout.BackingExtension","directory":"sdk/timestep/ui/layout/","filename":"BackingExtension.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import ..View\");\njsio(\"import ..backend.strPad as strPad\");\njsio(\"import ..backend.BaseBacking\");\njsio(\"import .BoxLayout\");\njsio(\"import .LinearLayout\");\njsio(\"import .Padding\");\n\njsio(\"import util.setProperty\");\n\nvar layoutProps = {\n\t\t'layout': {value: false, cb: '_onSetLayout'},\n\t\t'inLayout': {value: true, cb: '_onInLayout'},\n\t\t'order': {value: 0, cb: '_onOrder'},\n\t\t'direction': {value: 'down', cb: '_onLayoutChange'},\n\t\t'flex': {value: 0, cb: '_onLayoutChange'},\n\t\t'halign': {value: 'start'}, 'halignSelf': {value: undefined},\n\t\t'valign': {value: 'start'}, 'valignSelf': {value: undefined},\n\n\t\t'centerX': {value: false},\n\t\t'centerY': {value: false},\n\n\t\t'top': {value: undefined, cb: '_onLayoutChange'},\n\t\t'right': {value: undefined, cb: '_onLayoutChange'},\n\t\t'bottom': {value: undefined, cb: '_onLayoutChange'},\n\t\t'left': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'justifyContent': {value: 'start', cb: '_onLayoutChange'},\n\t\t'sizeContainerToFit': {value: false, cb: '_onLayoutChange'},\n\n\t\t'minWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'minHeight': {value: undefined, cb: '_onLayoutChange'},\n\t\t'maxWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'maxHeight': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'layoutWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'layoutHeight': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'fixedAspectRatio': {value: false, cb: '_onFixedAspectRatio'},\n\t\t'aspectRatio': {value: null, cb: '_onLayoutChange'},\n\n\t\t'margin': {value: null, cb: '_onMarginChange'}\n\t};\n\nfor (var key in layoutProps) {\n\tbackend.BaseBacking.addProperty(key, layoutProps[key]);\n}\n\nutil.setProperty(backend.BaseBacking.prototype, 'padding', {\n\tget: function () {\n\t\treturn this._padding || (this._padding = new Padding());\n\t},\n\tset: function (value) {\n\t\tif (this._padding) {\n\t\t\tthis._padding.update(value);\n\t\t} else {\n\t\t\tthis._padding = new Padding(value);\n\t\t}\n\n\t\tthis._onLayoutChange();\n\t}\n});\n\nView.addExtension({\n\textend: function (ViewBacking) {\n\n\t\tvar proto = ViewBacking.prototype;\n\n\t\tproto._sortOrder = strPad.initialValue;\n\t\tproto._onOrder = function(_, order) {\n\t\t\tthis._sortOrder = strPad.pad(order);\n\t\t\tthis._onLayoutChange();\n\t\t};\n\t\t\n\t\tproto._onMarginChange = function (key, value) {\n\t\t\tif (this._cachedMargin) {\n\t\t\t\tthis._cachedMargin.update(value);\n\t\t\t} else {\n\t\t\t\tthis._cachedMargin = new Padding(value);\n\t\t\t}\n\n\t\t\tthis.top = this._cachedMargin.top;\n\t\t\tthis.bottom = this._cachedMargin.bottom;\n\t\t\tthis.left = this._cachedMargin.left;\n\t\t\tthis.right = this._cachedMargin.right;\n\n\t\t\tthis._onLayoutChange();\n\t\t}\n\n\t\tproto._onFixedAspectRatio = function (key, value) {\n\t\t\tif (value) {\n\t\t\t\tthis.updateAspectRatio();\n\t\t\t}\n\t\t}\n\n\t\tproto.updateAspectRatio = function (w, h) {\n\t\t\tthis.aspectRatio = (w || this.width) / (h || this.height);\n\t\t}\n\n\t\tproto._onSetLayout = function (key, which) {\n\t\t\tswitch (which) {\n\t\t\t\tcase 'linear':\n\t\t\t\t\tthis._view.__layout = new LinearLayout({view: this._view});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'box':\n\t\t\t\t\tthis._view.__layout = new BoxLayout({view: this._view});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tproto._onInLayout = function (key, value) {\n\t\t\tvar layout = this._superview && this._superview.__layout;\n\t\t\tif (layout) {\n\t\t\t\tif (value) {\n\t\t\t\t\tlayout.add(this._view);\n\t\t\t\t} else {\n\t\t\t\t\tlayout.remove(this._view);\n\t\t\t\t\tthis._view.needsReflow();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// var isPercent = /%$/;\n\t\t// proto._onLayoutSizeChange = function (key, value, oldValue) {\n\t\t// \t// Subscribes a view to parent resize events when the view is in the hierarchy and\n\t\t// \t// contains a percentage height or width.\n\t\t// \t//\n\t\t// \t// NOTE: a view only sets up resize listeners once -- if layoutWidth is set to a percent and then reset\n\t\t// \t// to not have a percent, it will still get reflow events when its superview resizes.  We could\n\t\t// \t// remove the listeners once the view no longer has percentages.\n\t\t// \tif (!this._hasResizeListeners && (isPercent.test(this._layoutWidth) || isPercent.test(this._layoutHeight))) {\n\t\t// \t\tthis._hasResizeListeners = true;\n\t\t// \t\tthis._view.on('ViewAdded', bind(this, function () {\n\t\t// \t\t\tif (this.__superviewResize) {\n\t\t// \t\t\t\tthis.__superviewResize();\n\t\t// \t\t\t}\n\t\t\t\t\t\n\t\t// \t\t\tvar superview = this._view.getSuperview();\n\t\t// \t\t\tvar onResize = bind(this._view, 'needsReflow');\n\t\t// \t\t\tsuperview.on('Resize', onResize);\n\t\t\t\t\t\n\t\t// \t\t\tthis.__superviewResize = bind(this, function () {\n\t\t// \t\t\t\tthis.__superviewResize = null;\n\t\t// \t\t\t\tsuperview.removeListener('Resize', onResize);\n\t\t// \t\t\t});\n\t\t// \t\t}));\n\t\t\t\t\n\t\t// \t\tthis._view.on('ViewRemoved', bind(this, function (superview) {\n\t\t// \t\t\tif (this.__superviewResize) { this.__superviewResize(); }\n\t\t// \t\t}));\n\t\t// \t}\n\t\t\t\n\t\t// \tthis._onLayoutChange();\n\t\t// }\n\n\t\tproto._onLayoutChange = function () {\n\t\t\tvar superview = this.getSuperview();\n\t\t\tif (superview && superview.__layout) {\n\t\t\t\tsuperview.needsReflow();\n\t\t\t}\n\n\t\t\tthis._view.needsReflow();\n\t\t}\n\t}\n});\n","pre":true},"sdk/timestep/ui/layout/BoxLayout.js":{"path":"sdk/timestep/ui/layout/BoxLayout.js","friendlyPath":".BoxLayout","directory":"sdk/timestep/ui/layout/","filename":"BoxLayout.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvar sdk_timestep_ui_layout_BoxLayout=__class__;var BoxLayout = exports=sdk_timestep_ui_layout_BoxLayout(function sdk_timestep_ui_layout_BoxLayout(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\tvar cls = this.constructor;\n\n\tthis.reflowsChildren = false;\n\n\tthis.init = function (opts) {\n\t\tthis._view = opts.view;\n\n\t\tcls.initParentListener(opts.view);\n\t}\n\n\tthis.reflow = function (force) {\n\t\tvar view = this._view;\n\t\tvar sv = view.getSuperview();\n\t\tvar style = view.style;\n\n\t\tif (sv && (force || !style.inLayout || !sv.style.layout || !sv.__layout.reflowsChildren)) {\n\t\t\tcls.reflowX(view, sv.style.width);\n\t\t\tcls.reflowY(view, sv.style.height);\n\t\t}\n\n\n\t}\n\n\tcls.addParentListener = function (view) {\n\t\tif (view.style.__removeSuperviewResize) {\n\t\t\tview.style.__removeSuperviewResize();\n\t\t}\n\n\t\t// reflow on parent view resize\n\t\tvar onResize = bind(view, 'needsReflow');\n\t\tvar superview = view.getSuperview();\n\t\tsuperview && superview.on('Resize', onResize);\n\n\t\t// store a closure to unsubscribe this event\n\t\tview.style.__removeSuperviewResize = bind(view.style, function () {\n\t\t\tthis.__removeSuperviewResize = null;\n\t\t\tsuperview && superview.removeListener('Resize', onResize);\n\t\t});\n\t}\n\n\tcls.initParentListener = function (view) {\n\t\tif (view.__root) { this.addParentListener(view); }\n\n\t\tview.on('ViewAdded', bind(this, 'addParentListener', view));\n\t\tview.on('ViewRemoved', bind(view.style, function () {\n\t\t\tthis.__removeSuperviewResize && this.__removeSuperviewResize();\n\t\t}));\n\t}\n\n\tvar isPercent = /%$/;\n\tcls.reflowX = function (view, svWidth, padding) {\n\t\tif (!svWidth) { return; }\n\n\t\tvar s = view.style;\n\t\tvar availWidth = (svWidth - (padding && padding.getHorizontal() || 0));\n\n\t\t// compute the width\n\t\tvar w = 0;\n\t\tif (s.layoutWidth == 'wrapContent') {\n\t\t\t// find the maximal right edge\n\t\t\tvar views = view.getSubviews();\n\t\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\t\tvar right = v.style.x + v.style.width * v.style.scale;\n\t\t\t\tif (right > w) {\n\t\t\t\t\tw = right;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tw = s.right != undefined && s.left != undefined ? availWidth / s.scale - (s.left || 0) - (s.right || 0)\n\t\t\t\t: isPercent.test(s.layoutWidth) ? availWidth / s.scale * parseFloat(s.layoutWidth) / 100\n\t\t\t\t: s.aspectRatio ? s.height * s.aspectRatio\n\t\t\t\t: s.width || availWidth / s.scale;\n\t\t}\n\n\t\tif (s.centerX) { s.x = (availWidth - s.scale * w) / 2 + (padding && padding.left || 0); }\n\t\tif (s.left == undefined && s.right != undefined) { s.x = availWidth - s.scale * w - s.right - (padding && padding.right || 0); }\n\t\tif (s.left != undefined) { s.x = s.left + (padding && padding.left || 0); }\n\n\t\ts.width = w;\n\n\t\tif (s.centerAnchor) {\n\t\t\ts.anchorX = w / 2;\n\t\t}\n\t}\n\n\tcls.reflowY = function (view, svHeight, padding) {\n\t\tif (!svHeight) { return; }\n\n\t\tvar s = view.style;\n\t\tvar availHeight = (svHeight - (padding && padding.getVertical() || 0));\n\n\t\t// compute the height\n\t\tvar h = 0;\n\t\tif (s.layoutHeight == 'wrapContent') {\n\t\t\t// find the maximal right edge\n\t\t\tvar views = view.getSubviews();\n\t\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\t\tvar bottom = v.style.y + v.style.height * v.style.scale;\n\t\t\t\tif (bottom > h) {\n\t\t\t\t\th = bottom;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\th = s.top != undefined && s.bottom != undefined ? availHeight / s.scale - (s.top || 0) - (s.bottom || 0)\n\t\t\t\t: isPercent.test(s.layoutHeight) ? availHeight / s.scale * parseFloat(s.layoutHeight) / 100\n\t\t\t\t: s.aspectRatio ? s.width / s.aspectRatio\n\t\t\t\t: s.height || availHeight / s.scale;\n\t\t}\n\n\t\tif (s.centerY) { s.y = (availHeight - s.scale * h) / 2 + (padding && padding.top || 0); }\n\t\tif (s.top == undefined && s.bottom != undefined) { s.y = availHeight - s.scale * h - s.bottom - (padding && padding.bottom || 0); }\n\t\tif (s.top != undefined) { s.y = s.top + (padding && padding.top || 0); }\n\n\t\ts.height = h;\n\n\t\tif (s.centerAnchor) {\n\t\t\ts.anchorY = h / 2;\n\t\t}\n\t}\n});\n\n\n","pre":true},"sdk/timestep/ui/layout/LinearLayout.js":{"path":"sdk/timestep/ui/layout/LinearLayout.js","friendlyPath":".LinearLayout","directory":"sdk/timestep/ui/layout/","filename":"LinearLayout.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * package ui.layout.LinearLayout;\n *\n * A class to direct the layout of its parent view, set through opts.parent.\n */\n\njsio(\"import ui.layout.Padding as Padding\");\n\njsio(\"import .BoxLayout\");\n\nvar DEBUG = false;\n\n// TODO: native\n// TODO: Resize event on width/height change\n// TODO: reflow on subview visibility change\n\nvar sdk_timestep_ui_layout_LinearLayout=__class__;exports=sdk_timestep_ui_layout_LinearLayout(function sdk_timestep_ui_layout_LinearLayout(){return this.init&&this.init.apply(this,arguments)},BoxLayout, function (supr) {\n\n\t// set to true to tell other layouts not to try to control the child layout\n\tthis.reflowsChildren = true;\n\n\tthis.init = function(opts) {\n\t\tthis._view = opts.view;\n\t\tthis._view.subscribe('SubviewAdded', this, '_onSubviewAdded');\n\t\tthis._view.subscribe('SubviewRemoved', this, '_onSubviewRemoved');\n\n\t\tthis.setDirection(opts.isVertical ? 'vertical' : 'horizontal');\n\n\t\tthis._views = [];\n\t\tvar subviews = this._view.getSubviews();\n\t\tfor (var i = 0, view; view = subviews[i]; ++i) {\n\t\t\tif (view.style.inLayout) {\n\t\t\t\tthis._views.push(this._initLayoutView(view));\n\t\t\t}\n\t\t}\n\n\t\tthis._forwardEvents();\n\n\t\tthis._debug = DEBUG;\n\t}\n\n\tthis._onSubviewRemoved = function (view) {\n\t\tif (view.style.inLayout) {\n\t\t\tthis.remove(view);\n\t\t}\n\t}\n\n\tthis._onSubviewAdded = function (view) {\n\t\tif (view.style.inLayout) {\n\t\t\tthis.add(view);\n\t\t}\n\t}\n\n\tthis.debug = function () { this._debug = true; return this; }\n\n\t/**\n\t * Set which language to use, for horizontal or vertical layout.\n\t * @param String direction One of \"horizontal\" or \"vertical\".\n\t */\n\n\tthis.setDirection = function (direction) {\n\t\tthis._direction = direction;\n\n\t\tvar isVertical = direction == 'vertical';\n\t\tthis._propPos = isVertical ? 'y' : 'x';\n\t\tthis._propPosOpp = isVertical ? 'x' : 'y';\n\t\tthis._propDim = isVertical ? 'height' : 'width';\n\t\tthis._minPropDim = isVertical ? 'minHeight' : 'minWidth';\n\t\tthis._maxPropDim = isVertical ? 'maxHeight' : 'maxWidth';\n\t\tthis._propDimOpp = isVertical ? 'width' : 'height';\n\t\tthis._propSideA = isVertical ? 'top' : 'left';\n\t\tthis._propSideB = isVertical ? 'bottom' : 'right';\n\n\t\tthis._flexProp = isVertical ? 'vflex' : 'hflex';\n\n\t\tthis._view.needsReflow();\n\t\treturn this;\n\t}\n\n\tthis.getDirection = function () { return this._direction; }\n\n\t/**\n\t * Events to proxy to the parent view from this layout.\n\t */\n\tthis._events = ['ViewWillAppear', 'ViewDidAppear', 'ViewWillDisappear', 'ViewDidDisappear'];\n\n\tthis._forwardEvents = function() {\n\t\tfor (var i = 0, a; a = this._events[i]; ++i) {\n\t\t\tthis._view.subscribe(a, this, '_forwardSignal', a);\n\t\t}\n\t};\n\n\tthis._events = ['ViewWillAppear', 'ViewDidAppear', 'ViewWillDisappear', 'ViewDidDisappear'];\n\n\t/**\n\t * Emit events on the children. Variable arguments.\n\t */\n\n\tthis._forwardSignal = function () {\n\t\tfor (var i = 0, v; v = this._views[i]; ++i) {\n\t\t\tv.view.publish.apply(v.view, arguments);\n\t\t}\n\t};\n\n\t/**\n\t * Initialize a subview controlled by this layout.\n\t */\n\n\tthis._initLayoutView = function(view) {\n\t\tview.style.inLayout = true;\n\n\t\tthis._debug && logger.log(this._view.uid, 'adding view', view.uid, this._propDim, view.style[this._propDim]);\n\n\t\tthis._view.connectEvent(view, 'Resize', bind(this, 'reflow'));\n\n\t\treturn {\n\t\t\tview: view,\n\t\t\tindex: 0,\n\t\t\ttoString: toStringSort\n\t\t};\n\t};\n\n\tfunction toStringSort () {\n\t\treturn this.view.style._sortOrder + this.index;\n\t}\n\n\t/**\n\t * Return the size of this element (in its cardinal direction).\n\t */\n\n\tthis.getSize = function () {\n\t\treturn this._size;\n\t};\n\n\t/**\n\t * Return the index of a subview.\n\t */\n\n\tthis.getViewIndex = function (view) {\n\t\tfor (var i = 0, d; d = this._views[i]; ++i) {\n\t\t\tif (d.view == view) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t * Add an array of subviews to this element in batch (prevent reflow each\n\t * time).\n\t */\n\n\tthis.addSubviews = function (views) {\n\t\tthis._debug && logger.log(this._view.uid, \"adding\", views.length, \"views\");\n\t\tif (isArray(views)) {\n\t\t\tfor (var i = 0, n = views.length; i < n; ++i) {\n\t\t\t\tvar view = views[i];\n\t\t\t\tif (view) {\n\t\t\t\t\tthis._views.push(this._initLayoutView(view));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._view.needsReflow();\n\t\t} else {\n\t\t\tthis.insertBefore(views);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the list of subviews controlled by this layout.\n\t */\n\n\tthis.getSubviews = function () {\n\t\treturn this._views.map(function (v) { return v.view; });\n\t};\n\n\t/**\n\t * Remove a subview controlled by this layout.\n\t */\n\n\tthis.remove = function (view) {\n\t\tvar i = this.getViewIndex(view);\n\t\tif (i != -1) {\n\t\t\tthis._views.splice(i, 1);\n\t\t\tthis._view.disconnectEvent(view, 'Resize');\n\t\t\tthis._view.needsReflow();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Insert a subview before another subview in this hierarchy.\n\t */\n\n\tthis.add =\n\tthis.insertBefore = function (view, before) {\n\n\t\tif (this.getViewIndex(view) != -1) { return; }\n\n\t\tvar item = this._initLayoutView(view);\n\t\tvar added = false;\n\t\tif (before) {\n\t\t\tvar i = this.getViewIndex(before);\n\t\t\tif (i != -1) {\n\t\t\t\tthis._views.splice(i, 0, item);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!added) {\n\t\t\tthis._views.push(item);\n\t\t}\n\n\t\tthis._view.needsReflow();\n\t}\n\n\t/**\n\t * Insert a subview after another subview in this hierarchy.\n\t */\n\n\tthis.insertAfter = function (view, after) {\n\n\t\tif (this.getViewIndex(view) != -1) { return; }\n\n\t\tvar item = this._initLayoutView(view);\n\t\tvar added = false;\n\t\tif (after) {\n\t\t\tvar i = this.getViewIndex(after);\n\t\t\tif (i != -1) {\n\t\t\t\tthis._views.splice(i + 1, 0, item);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!added) {\n\t\t\tthis._views.unshift(item);\n\t\t}\n\n\t\tthis._view.needsReflow();\n\t}\n\n\t/**\n\t * Reflow logic.\n\t */\n\n\tthis.reflow = function () {\n\t\tsupr(this, 'reflow', arguments);\n\n\t\t// style.order is first, then default to standard view sort order\n\t\tvar n = 0;\n\t\tfor (var i = 0, v; v = this._views[i]; ++i) {\n\t\t\tif (v.view.style.visible) {\n\t\t\t\t// TODO: this won't work on native\n\t\t\t\tv.index = v.view.style.__sortKey;\n\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\n\t\tif (!n) { return; }\n\n\t\tthis._views.sort();\n\n\t\tif (DEBUG) {\n\t\t\tvar uid = this._view.uid;\n\t\t\t// _debug.views[uid] = +new Date();\n\t\t}\n\n\t\tvar layoutStyle = this._view.style;\n\t\tif (layoutStyle.direction != this._direction) {\n\t\t\tthis.setDirection(layoutStyle.direction);\n\t\t}\n\n\t\tvar scale = this._view.getPosition().scale;\n\n\t\tvar isVertical = this._direction == 'vertical';\n\t\tvar propDim = this._propDim;\n\t\tvar propDimOpp = this._propDimOpp;\n\t\tvar minPropDim = this._minPropDim;\n\t\tvar propA = this._propSideA;\n\t\tvar propB = this._propSideB;\n\t\tvar padding = layoutStyle.padding;\n\t\tvar paddingSum = padding && (isVertical ? padding.getVertical() : padding.getHorizontal()) || 0;\n\t\tvar parentDim = layoutStyle[propDim];\n\t\tvar views = this._views;\n\n\t\tthis._debug && logger.log('reflow() view', uid + ':', views.length, 'subview(s)');\n\n\t\t// compute the total size of the fixed views and count\n\t\t// how many dynamically sized views we have\n\t\tvar sum = 0;\n\t\tvar flexSum = 0;\n\t\tvar paddingOpp = padding && (isVertical ? padding.getHorizontal() : padding.getVertical()) || 0;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\tv.margins = (s[propA] || 0) + (s[propB] || 0);\n\n\t\t\tif (s.flex) {\n\t\t\t\tflexSum += s.flex;\n\t\t\t\tv.baseSize = s[minPropDim] || 0;\n\t\t\t\tsum += v.baseSize;\n\t\t\t} else {\n\t\t\t\tsum += (s[propDim] || 0) * s.scale + v.margins;\n\t\t\t}\n\n\t\t\t// LinearViews should reflow the opposite direction\n\t\t\tif (padding) {\n\t\t\t\ts.x = padding.left;\n\t\t\t\ts.y = padding.top;\n\t\t\t}\n\n//\t\t\tif (v.view.style.layout == 'box') {\n\t\t\t\tBoxLayout.reflowX(v.view, layoutStyle.width, padding);\n\t\t\t\tBoxLayout.reflowY(v.view, layoutStyle.height, padding);\n//\t\t\t}\n\t\t}\n\n\t\tif (flexSum && parentDim == undefined) { return; }\n\n\t\t// compute available space\n\t\tvar availableSpace = parentDim - paddingSum;\n\t\tif (availableSpace < 0) { return; }\n\n\t\t// if there's a flex subview or (?), the total size is the availableSpace\n\t\t// otherwise the totalSize is the sum of the subview sizes\n\t\tvar justifyContent = layoutStyle.justifyContent;\n\t\tvar totalSize = (flexSum || justifyContent != 'start' ? availableSpace : sum) + paddingSum;\n\t\tvar flexSize = availableSpace - sum;\n\n\t\t//\n\t\tvar layoutDim = isVertical ? 'layoutHeight' : 'layoutWidth';\n\t\tif (!flexSum && layoutStyle[layoutDim] == 'wrapContent') {\n\t\t\tthis._debug && logger.log('  view', uid, '(sizing to fit)', propDim, '=', totalSize + 'px', '(' + paddingSum + 'px padding)');\n\t\t\tlayoutStyle[propDim] = totalSize;\n\t\t}\n\n\t\t// compute the space for each flexible view\n\t\tvar flexUsed = 0;\n\t\tvar balance = 0;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\tif (s.flex) {\n\t\t\t\t// compute the ideal space for the flex view\n\t\t\t\tvar idealSpace = v.baseSize + flexSize * (s.flex / flexSum) / s.scale + balance;\n\n\t\t\t\t// round to the nearest screen pixel (take into account the global scale of the layout view)\n\t\t\t\tvar roundedSpace = Math.round(idealSpace / scale) * scale;\n\n\t\t\t\t// propogate the balance into the next view space computation\n\t\t\t\tbalance = idealSpace - roundedSpace;\n\n\t\t\t\t// store the actual space for the view, which is the computed space minus the margins\n\t\t\t\tv.dim = roundedSpace - v.margins;\n\n\t\t\t\t// account for maximal bound\n\t\t\t\tif (v.dim > s[this._maxPropDim]) {\n\t\t\t\t\tv.dim = s[this._maxPropDim];\n\t\t\t\t}\n\n\t\t\t\t// keep track of used flex space\n\t\t\t\tflexUsed += roundedSpace;\n\t\t\t}\n\t\t}\n\n\t\tvar flexRemaining = flexSize - flexUsed;\n\n\t\t// set the position of the views\n\t\tvar pos = padding && padding[propA] || 0;\n\t\tvar gap = 0;\n\t\tif (flexRemaining > 0) {\n\t\t\t// there's unused space, so justify our views\n\t\t\tswitch (justifyContent) {\n\t\t\t\tcase 'end':\n\t\t\t\t\tpos += flexRemaining;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'center':\n\t\t\t\t\tpos += flexRemaining / 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'space':\n\t\t\t\t\tgap = flexRemaining / (n - 1) || 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'space-outside':\n\t\t\t\t\tgap = flexRemaining / (n + 1) || 0;\n\t\t\t\t\tpos += gap;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'start':\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// position and size views!\n\t\tvar propPos = this._propPos;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\t// set position\n\t\t\ts[propPos] = pos + (s[propA] || 0);\n\n\t\t\tthis._debug && logger.log('  view', uid, 'layout subview', v.view.uid, propPos, '=', s[propPos]);\n\n\t\t\tif (s.flex) {\n\t\t\t\t// set width\n\t\t\t\ts[propDim] = v.dim;\n\n\t\t\t\tthis._debug && logger.log('  view', uid, 'layout subview', v.view.uid, propDim, '=', s[propDim]);\n\t\t\t}\n\n\t\t\t// advance position\n\t\t\tpos += gap + (s[propDim] || 0) * s.scale + v.margins;\n\t\t}\n\n\t\tif (this._size != totalSize) {\n\t\t\tthis._size = totalSize;\n\t\t\tthis._view.publish('LayoutResize', totalSize);\n\t\t}\n\t};\n});\n\n","pre":true},"sdk/gc/debugging/connect.js":{"path":"sdk/gc/debugging/connect.js","friendlyPath":"..debugging.connect","directory":"sdk/gc/debugging/","filename":"connect.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\tjsio(\"import net\");\n\tjsio(\"import net.protocols.Cuppa\");\n\n\tjsio(\"import ._DEBUG\");\n\n\tvar _conn;\n\tGLOBAL._DEBUG = new _DEBUG();\n\n\texports.getConn = function () { return _conn; }\n\n\texports.connect = function (opts, cb) {\n\t\tvar transport = opts && opts.transport;\n\t\tvar connectOpts = opts && opts.opts;\n\n\t\tif (!transport) {\n\t\t\tif (window.parent != window) {\n\t\t\t\t// in iframe\n\t\t\t\ttransport = 'postmessage';\n\t\t\t\tconnectOpts = {\n\t\t\t\t\tport: '__debug_timestep_inspector_' + window.location.port + '__',\n\t\t\t\t\twin: window.parent\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// assume we're on a mobile device\n\t\t\t\ttransport = 'csp';\n\t\t\t\tconnectOpts = {\n\t\t\t\t\turl: 'http://' + window.location.host + '/plugins/native_debugger/mobile_csp'\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t_conn = new DebugConn();\n\t\t_conn.onConnect(bind(GLOBAL, cb, _conn));\n\t\tnet.connect(_conn, transport, connectOpts);\n\n\t\treturn _conn;\n\t}\n\nDebugConn=__class__;\tvar DebugConn=DebugConn(function DebugConn(){return this.init&&this.init.apply(this,arguments)},net.protocols.Cuppa, function (supr) {\n\n\t\tthis.init = function () {\n\t\t\tsupr(this, 'init', arguments);\n\n\t\t\tthis._clients = [];\n\t\t}\n\n\t\tthis.setApp = function (app) {\n\t\t\tthis._clients.forEach(function (client) {\n\t\t\t\tif (client.setApp) {\n\t\t\t\t\tclient.setApp(app);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.addClient = function (client) {\n\t\t\tthis._clients.push(client);\n\t\t\tclient.setConn(this);\n\t\t}\n\n\t\tthis.initLogProxy = function () {\n\t\t\tjsio(\"import .logProxy\");\n\t\t\tlogProxy.install(this);\n\t\t}\n\n\t\tthis.initRemoteEval = function () {\n\t\t\tjsio(\"import .remoteEval\");\n\t\t\tremoteEval.install(this);\t\t\n\t\t}\n\t});\n}\n","pre":true},"sdk/jsio/net.js":{"path":"sdk/jsio/net.js","friendlyPath":"net","directory":"sdk/jsio/","filename":"net.js","baseMod":"net","basePath":"sdk/jsio","src":"jsio('import net.env');\njsio('import std.JSON as JSON');\n\nJSON.createGlobal(); // create the global JSON object if it doesn't already exist\n\n/**\n * @namespace\n */\n\nexports.listen = function(server, transportName, opts) {\n\tif (!transportName) {\n\t\tthrow logger.error('No transport provided for net.listen');\n\t}\n\t\n\tvar ctor = typeof transportName == 'string' ? net.env.getListener(transportName) : transportName,\n\t\tlistener = new ctor(server, opts);\n\n\tlistener.listen();\n\treturn listener;\n}\n\nexports.connect = function(protocolInstance, transportName, opts) {\n\tvar ctor = typeof transportName == 'string' ? net.env.getConnector(transportName) : transportName,\n\t\tconnector = new ctor(protocolInstance, opts);\n\tconnector.connect();\n\treturn connector;\n}\n\nexports.quickServer = function(protocolClass) {\n\tjsio('import net.interfaces');\n\treturn new net.interfaces.Server(protocolClass);\n}\n","pre":true},"sdk/jsio/net/env/browser/csp.js":{"path":"sdk/jsio/net/env/browser/csp.js","friendlyPath":"net.env.browser.csp","directory":"sdk/jsio/net/env/browser/","filename":"csp.js","src":"jsio('import net.interfaces');\njsio('from net.csp.client import CometSession');\njsio('import std.utf8 as utf8');\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\t\t\n\t\tvar conn = new CometSession();\n\t\tconn.onconnect = bind(this, 'cometSessionOnConnect', conn);\n\t\tconn.ondisconnect = bind(this, 'onDisconnect');\n\t\t\n\t\tlogger.debug('opening the connection');\n\t\tif (!this._opts.encoding) { this._opts.encoding = 'plain'; }\n\t\tconn.connect(this._opts.url, this._opts);//{encoding: 'plain'});\n\t}\n\t\n\tthis.cometSessionOnConnect = function(conn) {\n\t\tlogger.debug('conn has opened');\n\t\tthis.onConnect(new Transport(conn));\n\t}\n});\n\nTransport=__class__;var Transport=Transport(function Transport(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Transport, function() {\n\tthis.init = function(conn) {\n\t\tthis._conn = conn;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._conn.onread = bind(protocol, 'dataReceived');\n\t}\n\t\n\tthis.write = function(data) {\n\t\tthis._conn.write(data);\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._conn.close();\n\t}\n});\n","pre":true},"sdk/jsio/net/interfaces.js":{"path":"sdk/jsio/net/interfaces.js","friendlyPath":"net.interfaces","directory":"sdk/jsio/net/","filename":"interfaces.js","src":"// Sort of like a twisted protocol\njsio('import net');\njsio('import lib.Enum as Enum');\n\nvar ctx = jsio.__env.global;\n\nexports.Protocol=__class__;exports.Protocol=exports.Protocol(function exports_Protocol(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.connectionMade = function(isReconnect) {}\n\tthis.dataReceived = function(data) {}\n\tthis.connectionLost = function(reason) {}\n\t\n\tthis._connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionMade.apply(this, arguments);\n\t}\n\n\tthis._connectionLost = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionLost.apply(this, arguments);\n\t}\n\n\tthis._isConnected = false;\n\tthis.isConnected = function() {\n\t\treturn !!this._isConnected;\n\t}\n\t\n\t\n});\n\nexports.Client=__class__;exports.Client=exports.Client(function exports_Client(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.connect = function(transportName, opts) {\n\t\tthis._remote = new this._protocol();\n\t\tthis._remote._client = this;\n\t\tnet.connect(this._remote, transportName, opts);\n\t}\n});\n\n// Sort of like a twisted factory\nexports.Server=__class__;exports.Server=exports.Server(function exports_Server(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocolClass) {\n\t\tthis._protocolClass = protocolClass;\n\t}\n\n\tthis.buildProtocol = function() {\n\t\treturn new this._protocolClass();\n\t}\n\t\n\tthis.listen = function(how, port) {\n\t\treturn net.listen(this, how, port);\n\t}\n});\n\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis._encoding = 'plain'\n\tthis.write = function(data, encoding) {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.getPeer = function() {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.setEncoding = function(encoding) {\n\t\tthis._encoding = encoding;\n\t}\n\tthis.getEncoding = function() {\n\t\treturn this._encoding;\n\t}\n});\n\nexports.Listener=__class__;exports.Listener=exports.Listener(function exports_Listener(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(server, opts) {\n\t\tthis._server = server;\n\t\tthis._opts = opts || {};\n\t}\n\t\n\tthis.onConnect = function(transport) {\n\t\t//try {\n\t\t\tvar p = this._server.buildProtocol();\n\t\t\tp.transport = transport;\n\t\t\tp.server = this._server;\n\t\t\ttransport.protocol = p;\n\t\t\ttransport.makeConnection(p);\n\t\t\tp._connectionMade();\n\t\t//} catch(e) {\n\t\t//\tlogger.error(e);\n\t\t//}\n\t}\n\t\n\tthis.listen = function() { throw new Error('Abstract class'); }\n\tthis.stop = function() {}\n});\n\nexports.STATE = Enum('INITIAL', 'DISCONNECTED', 'CONNECTING', 'CONNECTED');\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, opts) {\n\t\tthis._protocol = protocol;\n\t\tthis._opts = opts;\n\t\tthis._state = exports.STATE.INITIAL;\n\t}\n\t\n\tthis.getState = function() { return this._state; }\n\t\n\tthis.onConnect = function(transport) {\n\t\tthis._state = exports.STATE.CONNECTED;\n\n\t\ttransport.makeConnection(this._protocol);\n\t\tthis._protocol.transport = transport;\n\t\ttry {\n\t\t\tthis._protocol._connectionMade();\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\t\n\tthis.onDisconnect = function(err) {\n\t\tvar wasConnected = this._state == exports.STATE.CONNECTED;\n\t\tthis._state = exports.STATE.DISCONNECTED;\n\t\t\n\t\ttry {\n\t\t\tthis._protocol._connectionLost(err, wasConnected);\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\t\n\tthis.getProtocol = function() { return this._protocol; }\n});\n","pre":true},"sdk/jsio/net/csp/client.js":{"path":"sdk/jsio/net/csp/client.js","friendlyPath":"net.csp.client","directory":"sdk/jsio/net/csp/","filename":"client.js","src":"jsio('import std.base64 as base64');\njsio('import std.utf8 as utf8');\njsio('import std.uri as uri'); \njsio('import net.errors as errors');\njsio('import .transports');\njsio('import lib.Enum as Enum');\n\nvar READYSTATE = exports.READYSTATE = Enum({\n\tINITIAL: 0,\n\tCONNECTING: 1,\n\tCONNECTED: 2,\n\tDISCONNECTING: 3,\n\tDISCONNECTED:  4\n});\n\n\nexports.CometSession=__class__;exports.CometSession=exports.CometSession(function exports_CometSession(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tvar id = 0;\n\tvar kDefaultBackoff = 50;\n\tvar kDefaultTimeoutInterval = 45000;\n\tvar kDefaultHandshakeTimeout = 10000;\n\tthis.init = function() {\n\t\tthis._id = ++id;\n\t\tthis._url = null;\n\t\tthis.readyState = READYSTATE.INITIAL;\n\t\tthis._sessionKey = null;\n\t\tthis._transport = null;\n\t\tthis._options = null;\n\t\t\n\t\tthis._utf8ReadBuffer = \"\";\n\t\tthis._writeBuffer = \"\";\n\t\t\n\t\tthis._packetsInFlight = null;\n\t\tthis._lastEventId = null;\n\t\tthis._lastSentId = null;\n\t\t\n\t\tthis._handshakeLater = null;\n\t\tthis._handshakeBackoff = kDefaultBackoff;\n\t\tthis._handshakeRetryTimer = null;\n\t\tthis._handshakeTimeoutTimer = null;\n\n\t\tthis._timeoutTimer = null;\n\n\t\t\n\t\tthis._writeBackoff = kDefaultBackoff;\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\t\n\t\tthis._nullInBuffer = false;\n\t\tthis._nullInFlight= false;\n\t\tthis._nullSent = false;\n\t\tthis._nullReceived = false;\n\t}\n\t\n\t\n\tthis.setEncoding = function(encoding) {\n\t\tif (encoding == this._options.encoding) { \n\t\t\treturn; \n\t\t}\n\t\tif (encoding != 'utf8' && encoding != 'plain') {\n\t\t\tthrow new errors.InvalidEncodingError();\n\t\t}\n\t\tif (encoding == 'plain' && this._buffer) {\n\t\t\tvar buffer = this._utf8ReadBuffer;\n\t\t\tthis._utf8ReadBuffer = \"\";\n\t\t\tthis._doOnRead(buffer);\n\t\t}\n\t\tthis._options.encoding = encoding;\n\t}\n\n\n\tthis.connect = function(url, options) {\n\t\tthis._url = url.replace(/\\/$/,'');\n\t\tthis._options = options || {};\n\t\t\n\t\tthis._options.encoding = this._options.encoding || 'utf8';\n\t\tthis.setEncoding(this._options.encoding); // enforce encoding constraints\n\t\t\n\t\tthis._options.connectTimeout = this._options.connectTimeout || kDefaultHandshakeTimeout;\n\t\t\n\t\tvar transportClass = transports.chooseTransport(url, this._options);\n\t\tthis._transport = new transportClass();\n\t\t\n\t\tthis._transport.handshakeFailure = bind(this, this._handshakeFailure);\n\t\tthis._transport.handshakeSuccess = bind(this, this._handshakeSuccess);\n\t\t\n\t\tthis._transport.cometFailure = bind(this, this._cometFailure);\n\t\tthis._transport.cometSuccess = bind(this, this._cometSuccess);\n\t\t\n\t\tthis._transport.sendFailure = bind(this, this._writeFailure);\n\t\tthis._transport.sendSuccess = bind(this, this._writeSuccess);\n\t\tthis.readyState = READYSTATE.CONNECTING;\n\t\tthis._transport.handshake(this._url, this._options);\n\t\t\n\t\tthis._handshakeTimeoutTimer = setTimeout(bind(this, this._handshakeTimeout), \n\t\t\tthis._options.connectTimeout);\n\t}\n\n\tthis.write = function(data, encoding) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) {\n\t\t\tthrow new errors.ReadyStateError();\n\t\t}\n\t\tencoding = encoding || this._options.encoding || 'utf8';\n\t\tif (encoding == 'utf8') {\n\t\t\tdata = utf8.encode(data);\n\t\t}\n\t\tthis._writeBuffer += data;\n\t\tthis._doWrite();\n\t}\n\t\n\t// Close due to protocol error\n\tthis._protocolError = function(msg) {\n\t\tlogger.debug('_protocolError', msg);\n\t\t// Immediately fire the onclose\n\t\t// send a null packet to the server\n\t\t// don't wait for a null packet back.\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\tthis._doWrite(true);\n\t\tthis._doOnDisconnect(new errors.ServerProtocolError(msg));\n\t}\n\t\n\tthis._receivedNullPacket = function() {\n\t\tlogger.debug('_receivedNullPacket');\n\t\t// send a null packet back to the server\n\t\tthis._receivedNull = true;\n\t\t\n\t\t// send our own null packet back. (maybe)\n\t\tif (!(this._nullInFlight || this._nullInBuffer || this._nullSent)) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\tthis._doWrite(true);\n\t\t}\n\t\telse {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\t// fire an onclose\n\t\tthis._doOnDisconnect(new errors.ConnectionClosedCleanly());\n\n\t}\n\t\n\tthis._sentNullPacket = function() {\n\t\tlogger.debug('_sentNullPacket');\n\t\tthis._nullSent = true;\n\t\tif (this._nullSent && this._nullReceived) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t}\n\t\n\t\n\t// User Calls close\n\tthis.close = function(err) {\n\t\tlogger.debug('close called', err, 'readyState', this.readyState);\n\n\t\t// \n\t\tswitch(this.readyState) {\n\t\t\tcase READYSTATE.CONNECTING:\n\t\t\t\tclearTimeout(this._handshakeRetryTimer);\n\t\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\t\tthis._doOnDisconnect(err);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.CONNECTED:\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\t\tthis._doWrite(true);\n\t\t\t\tclearTimeout(this._timeoutTimer);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.DISCONNECTED:\n\t\t\t\tthrow new errors.ReadyStateError(\"Session is already disconnected\");\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tthis._opened = false; // what is this used for???\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\n\t\tthis._doOnDisconnect(err);\n\t\tthis._sessionKey = null;\n\t}\n\t\n\tthis._handshakeTimeout = function() {\n\t\tlogger.debug('handshake timeout');\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tclearTimeout(this._handshakeRetryTimer);\n\t\tif (this.readyState == READYSTATE.CONNECTING) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\tthis._doOnDisconnect(new errors.ServerUnreachable());\n\t}\n\t\n\tthis._handshakeSuccess = function(data) {\n\t\tlogger.debug('handshake success', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { \n\t\t\tlogger.debug('received handshake success in invalid readyState:', this.readyState);\n\t\t\treturn; \n\t\t}\n\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tthis._sessionKey = data.response.session;\n\t\tthis._opened = true;\n\t\tthis.readyState = READYSTATE.CONNECTED;\n\t\tthis._doOnConnect();\n\t\tthis._doConnectComet();\n\t}\n\t\n\tthis._handshakeFailure = function(data) {\n\t\tlogger.debug('handshake failure', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { return; }\n\t\tif (data.status == 404) {\n\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\treturn this._doOnDisconnect(new errors.ServerUnreachable());\n\t\t}\n\t\t\n\t\tlogger.debug('trying again in ', this._handshakeBackoff);\n\t\tthis._handshakeRetryTimer = setTimeout(bind(this, function() {\n\t\t\tthis._handshakeRetryTimer = null;\n\t\t\tthis._transport.handshake(this._url, this._options);\n\t\t}), this._handshakeBackoff);\n\t\t\n\t\tthis._handshakeBackoff *= 2;\n\t}\n\t\n\tthis._writeSuccess = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._nullInFlight) {\n\t\t\treturn this._sentNullPacket();\n\t\t}\n\t\tthis._resetTimeoutTimer();\n\t\tthis.writeBackoff = kDefaultBackoff;\n\t\tthis._packetsInFlight = null;\n\t\tif (this._writeBuffer || this._nullInBuffer) {\n\t\t\tthis._doWrite(this._nullInBuffer);\n\t\t}\n\t}\n\t\n\tthis._writeFailure = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.READYSTATE != READYSTATE.DISCONNECTING) { return; }\n\t\tthis._writeTimer = setTimeout(bind(this, function() {\n\t\t\tthis._writeTimer = null;\n\t\t\tthis.__doWrite(this._nullInBuffer);\n\t\t}), this._writeBackoff);\n\t\tthis._writeBackoff *= 2;\n\t}\t\n\n\tthis._doWrite = function(sendNull) {\n\t\tif (this._packetsInFlight) {\n\t\t\tif (sendNull) {\n\t\t\t\tthis._nullInBuffer = true;\n\t\t\t\treturn; \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.__doWrite(sendNull);\n\t}\n\t\n\tthis.__doWrite = function(sendNull) {\n\t\tlogger.debug('_writeBuffer:', this._writeBuffer);\n\t\tif (!this._packetsInFlight && this._writeBuffer) {\n\t\t\tthis._packetsInFlight = [this._transport.encodePacket(++this._lastSentId, this._writeBuffer, this._options)];\n\t\t\tthis._writeBuffer = \"\";\n\t\t}\n\t\tif (sendNull && !this._writeBuffer) {\n\t\t\tif (!this._packetsInFlight) {\n\t\t\t\tthis._packetsInFlight = [];\n\t\t\t}\n\t\t\tthis._packetsInFlight.push([++this._lastSentId, 0, null]);\n\t\t\tthis._nullInFlight = true;\n\t\t}\n\t\tif (!this._packetsInFlight) {\n\t\t\tlogger.debug(\"no packets to send\");\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug('sending packets:', JSON.stringify(this._packetsInFlight));\n\t\tthis._transport.send(this._url, this._sessionKey, this._lastEventId || 0, JSON.stringify(this._packetsInFlight), this._options);\n\t}\n\t\n\tthis._doConnectComet = function() {\n\t\tlogger.debug('_doConnectComet');\n//\t\treturn;\n\t\tthis._transport.comet(this._url, this._sessionKey, this._lastEventId || 0, this._options);\n\t}\n\n\tthis._cometFailure = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) { return; }\n\t\tif (data.status == 404 && data.response == 'Session not found') {\n\t\t\treturn this.close(new errors.ExpiredSession(data));\n\t\t}\n\t\t\n\t\tthis._cometTimer = setTimeout(bind(this, '_doConnectComet'), this._cometBackoff);\n\t\tthis._cometBackoff *= 2;\n\t}\n\t\n\tthis._cometSuccess = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\tlogger.debug('comet Success:', data);\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\tthis._resetTimeoutTimer();\n\t\t\n\t\tvar response = data.response;\n\t\tfor (var i = 0, packet; (packet = response[i]) || i < response.length; i++) {\n\t\t\tlogger.debug('process packet:', packet);\n\t\t\tif (packet === null) {\n\t\t\t\treturn this.close(new errors.ServerProtocolError(data));\n\t\t\t}\n\t\t\tlogger.debug('process packet', packet);\n\t\t\tvar ackId = packet[0];\n\t\t\tvar encoding = packet[1];\n\t\t\tvar data = packet[2];\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId <= this._lastEventId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId != this._lastEventId+1) {\n\t\t\t\treturn this._protocolError(\"Ack id too high\");\n\t\t\t}\n\t\t\tthis._lastEventId = ackId;\n\t\t\tif (data == null) {\n\t\t\t\treturn this._receivedNullPacket();\n\t\t\t}\n\t\t\tif (encoding == 1) { // base64 encoding\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug('before base64 decode:', data);\n\t\t\t\t\tdata = base64.decode(data);\n\t\t\t\t\tlogger.debug('after base64 decode:', data);\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn this._protocolError(\"Unable to decode base64 payload\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._options.encoding == 'utf8') {\n\t\t\t\t// TODO: need an incremental utf8 decoder for this stuff.\n\t\t\t\tthis._utf8ReadBuffer += data;\n\t\t\t\tlogger.debug('before utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer);\n\t\t\t\tvar result = utf8.decode(this._utf8ReadBuffer);\n\t\t\t\tdata = result[0];\n\t\t\t\tthis._utf8ReadBuffer = this._utf8ReadBuffer.slice(result[1]);\n\t\t\t\tlogger.debug('after utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer, 'data:', data );\n\t\t\t}\n\t\t\tlogger.debug('dispatching data:', data);\n\n\t\t\t// TODO: possibly catch this error in production? but not in dev\n\t\t\tthis._doOnRead(data);\n\t\t}\n\t\t\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\t\n\t\t// reconnect comet last, after we process all of the packet ids\n\t\tthis._doConnectComet();\n\t\t\n\t}\n\n\tthis._doOnRead = function(data) {\n\t\tif (typeof(this.onread) == 'function') {\n\t\t\tlogger.debug('call onread function', data);\n\t\t\tthis.onread(data);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onread callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnDisconnect = function(err) {\n\t\tif (typeof(this.ondisconnect) == 'function') {\n\t\t\tlogger.debug('call ondisconnect function', err);\n\t\t\tthis.ondisconnect(err);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping ondisconnect callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnConnect = function() {\n\t\tif (typeof(this.onconnect) == 'function') {\n\t\t\tlogger.debug('call onconnect function');\n\t\t\ttry {\n\t\t\t\tthis.onconnect();\n\t\t\t} catch(e) {\n\t\t\t\tlogger.debug('onconnect caused errror', e);\n\t\t\t\t// throw error later\n\t\t\t\tsetTimeout(function() { throw e }, 0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onconnect callback (function missing)');\n\t\t}\n\t}\n\n\tthis._resetTimeoutTimer = function() {\n\t\tclearTimeout(this._timeoutTimer);\n\t\tthis._timeoutTimer = setTimeout(bind(this, function() {\n\t\t\tlogger.debug('connection timeout expired');\n\t\t\tthis.close(new errors.ConnectionTimeout())\n\t\t}), this._getTimeoutInterval())\n\t}\n\t\n\tthis._getTimeoutInterval = function() {\n\t\treturn kDefaultTimeoutInterval;\n\t}\n\n});\n","pre":true},"sdk/jsio/std/base64.js":{"path":"sdk/jsio/std/base64.js","friendlyPath":"std.base64","directory":"sdk/jsio/std/","filename":"base64.js","src":"/*\n\"URL-safe\" Base64 Codec, by Jacob Rus\n\nThis library happily strips off as many trailing '=' as are included in the\ninput to 'decode', and doesn't worry whether its length is an even multiple\nof 4. It does not include trailing '=' in its own output. It uses the\n'URL safe' base64 alphabet, where the last two characters are '-' and '_'.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\ttrailingPad = '=',\n\tpadChar = alphabet.charAt(alphabet.length - 1);\n\nvar decodeMap = {};\nfor (var i = 0, len = alphabet.length; i < len; i++) {\n\tdecodeMap[alphabet.charAt(i)] = i;\n}\n\n// use this regexp in the decode function to sniff out invalid characters.\nvar alphabet_inverse = new RegExp('[^' + alphabet.replace('-', '\\\\-') + ']');\n\nexports.Base64CodecError=__class__;exports.Base64CodecError=exports.Base64CodecError(function exports_Base64CodecError(){return this.init&&this.init.apply(this,arguments)},Error, function(supr) {\n\tthis.name = 'Base64CodecError';\n\t\n\tthis.init = function(message) {\n\t\tthis.message = message;\n\t}\n});\n\nvar assertOrBadInput = function (exp, message) {\n\tif (!exp) { throw new exports.Base64CodecError(message) };\n};\n\nexports.encode = function (bytes, skipPadding) {\n\tassertOrBadInput(!(/[^\\x00-\\xFF]/.test(bytes)), // disallow two-byte chars\n\t\t'Input contains out-of-range characters.');\n\tvar paddingSize = bytes.length % 3;\n\tvar padding = '\\x00\\x00\\x00'.slice(paddingSize || 3);\n\tbytes += padding; // pad with null bytes\n\tvar out_array = [];\n\tfor (var i=0, n=bytes.length; i < n; i+=3) {\n\t\tvar newchars = (\n\t\t\t(bytes.charCodeAt(i)   << 020) +\n\t\t\t(bytes.charCodeAt(i+1) << 010) +\n\t\t\t(bytes.charCodeAt(i+2)));\n\t\tout_array.push(\n\t\t\talphabet.charAt((newchars >> 18) & 077),\n\t\t\talphabet.charAt((newchars >> 12) & 077),\n\t\t\talphabet.charAt((newchars >> 6)  & 077),\n\t\t\talphabet.charAt((newchars)       & 077));\n\t};\n\t\n\tout_array.length -= padding.length;\n\tvar ret = out_array.join('');\n\tif (!skipPadding) {\n\t\tif (paddingSize == 1) {\n\t\t\tret += '==';\n\t\t} else if (paddingSize == 2) {\n\t\t\tret += '=';\n\t\t}\n\t}\n\t\n\treturn ret;\n};\n\nexports.decode = function (b64text) {\n\tlogger.debug('decode', b64text);\n\tb64text = b64text.replace(/\\s/g, ''); // kill whitespace\n\t\n\t// strip trailing pad characters from input; // XXX maybe some better way?\n\tvar i = b64text.length;\n\twhile (b64text.charAt(--i) === trailingPad) {};\n\tb64text = b64text.slice(0, i + 1);\n\t\n\tassertOrBadInput(!alphabet_inverse.test(b64text), 'Input contains out-of-range characters.');\n\t\n\tvar padLength = 4 - ((b64text.length % 4) || 4),\n\t\tpadding = Array(padLength + 1).join(padChar);\n\t\n\tb64text += padding; // pad with last letter of alphabet\n\t\n\tvar out_array = [],\n\t\tlength = i + padLength + 1; // length of b64text\n\t\n\tfor (var i = 0; i < length; i += 4) {\n\t\tnewchars = (\n\t\t\t(decodeMap[b64text.charAt(i)]   << 18) +\n\t\t\t(decodeMap[b64text.charAt(i+1)] << 12) +\n\t\t\t(decodeMap[b64text.charAt(i+2)] << 6)  +\n\t\t\t(decodeMap[b64text.charAt(i+3)]));\n\t\tout_array.push(\n\t\t\t(newchars >> 020) & 0xFF,\n\t\t\t(newchars >> 010) & 0xFF, \n\t\t\t(newchars)\t\t& 0xFF);\n\t};\n\t\n\tlength = (out_array.length -= padLength);\n\t\n\t// Safari fromCharCode can't be passed more than 65536 arguments at once\n\tvar result,\n\t\tMAX_CHUNK = 65536;\n\t\n\tif (length > MAX_CHUNK) {\n\t\tresult = [];\n\t\tvar i = 0, j = 0;\n\t\twhile (i < length) {\n\t\t\tresult[j++] = String.fromCharCode.apply(String, out_array.slice(i, i + MAX_CHUNK));\n\t\t\ti += MAX_CHUNK;\n\t\t}\n\t\tresult = result.join('');\n\t} else {\n\t\tresult = String.fromCharCode.apply(String, out_array);\n\t}\n\tlogger.debug('decoded', result);\n\treturn result;\n};\n","pre":true},"sdk/jsio/std/utf8.js":{"path":"sdk/jsio/std/utf8.js","friendlyPath":"std.utf8","directory":"sdk/jsio/std/","filename":"utf8.js","src":"/*\nFast incremental JavaScript UTF-8 encoder/decoder, by Jacob Rus.\n\nAPI for decode from Orbited: as far as I know, the first incremental\nJavaScript UTF-8 decoder.\n\nInspired by the observation by Johan Sundström published at:\nhttp://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\nNote that this code throws an error for invalid UTF-8. Because it is so much\nfaster than previous implementations, the recommended way to do lenient\nparsing is to first try this decoder, and then fall back on a slower lenient\ndecoder if necessary for the particular use case.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n//var utf8 = this.utf8 = exports;\n\nexports.UnicodeCodecError = function (message) { \n\tthis.message = message; \n};\n\nvar UnicodeCodecError = exports.UnicodeCodecError;\n\nUnicodeCodecError.prototype.toString = function () {\n\treturn 'UnicodeCodecError' + (this.message ? ': ' + this.message : '');\n};\n\nexports.encode = function (unicode_string) {\n\t// Unicode encoder: Given an arbitrary unicode string, returns a string\n\t// of characters with code points in range 0x00 - 0xFF corresponding to\n\t// the bytes of the utf-8 representation of those characters.\n\ttry {\n\t\treturn unescape(encodeURIComponent(unicode_string));\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid input string');\n\t};\n};\nexports.decode = function (bytes) {\n\t// Unicode decoder: Given a string of characters with code points in\n\t// range 0x00 - 0xFF, which, when interpreted as bytes, are valid UTF-8,\n\t// returns the corresponding Unicode string, along with the number of\n\t// bytes in the input string which were successfully parsed.\n\t//\n\t// Unlike most JavaScript utf-8 encode/decode implementations, properly\n\t// deals with partial multi-byte characters at the end of the byte string.\n\tif (/[^\\x00-\\xFF]/.test(bytes)) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n\tvar len, len_parsed;\n\tlen = len_parsed = bytes.length;\n\tvar last = len - 1;\n\t// test for non-ascii final byte. if last byte is ascii (00-7F) we're done.\n\tif (bytes.charCodeAt(last) >= 0x80) {\n\t\t// loop through last 3 bytes looking for first initial byte of unicode\n\t\t// multi-byte character. If the initial byte is 4th from the end, we'll\n\t\t// parse the whole string.\n\t\tfor (var i = 1; i <= 3; i++) {\n\t\t\t// initial bytes are in range C0-FF\n\t\t\tif (bytes.charCodeAt(len - i) >= 0xC0) {\n\t\t\t\tlen_parsed = len - i;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t\ttry {\n\t\t\t// if the last few bytes are a complete multi-byte character, parse\n\t\t\t// everything (by setting len_parsed)\n\t\t\tdecodeURIComponent(escape(bytes.slice(len_parsed)));\n\t\t\tlen_parsed = len;\n\t\t}\n\t\tcatch (err) { /* pass */ };\n\t};\n\ttry {\n\t\treturn [\n\t\t\tdecodeURIComponent(escape(bytes.slice(0, len_parsed))),\n\t\t\tlen_parsed\n\t\t];\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n};\n","pre":true},"sdk/jsio/net/errors.js":{"path":"sdk/jsio/net/errors.js","friendlyPath":"net.errors","directory":"sdk/jsio/net/","filename":"errors.js","src":"var makeErrorClass = function(name, _code) {\n\tvar toString = function() {\n\t\treturn name + (this.message ? ': ' + this.message : '');\n\t}\n\n\tvar ctor = function(data) {\n\t\tif (typeof data == 'string') {\n\t\t\tthis.message = data;\n\t\t} else {\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\t\n\tctor.prototype = {\n\t\ttype: name,\n\t\ttoString: toString\n\t};\n\t\n\treturn ctor;\n}\n\nexports.ReadyStateError = makeErrorClass(\"ReadyStateError\");\nexports.InvalidEncodingError = makeErrorClass(\"InvalidEncodingError\");\nexports.ExpiredSession = makeErrorClass(\"ExpiredSession\");\n\nexports.ServerUnreachable = makeErrorClass(\"ServerUnreachable\", 100);\nexports.ConnectionTimeout = makeErrorClass(\"ConnectionTimeout\", 101);\n\nexports.ServerProtocolError = makeErrorClass(\"ServerProtocolError\", 200);\n\nexports.ServerClosedConnection = makeErrorClass(\"ServerClosedConnection\", 301);\nexports.ConnectionClosedCleanly = makeErrorClass(\"ConnectionClosedCleanly\", 300);","pre":true},"sdk/jsio/net/csp/transports.js":{"path":"sdk/jsio/net/csp/transports.js","friendlyPath":".transports","directory":"sdk/jsio/net/csp/","filename":"transports.js","src":"jsio('import std.uri as uri'); \njsio('import std.base64 as base64');\njsio('from util.browserdetect import BrowserDetect');\n\n;(function() {\n\tvar doc;\n\texports.getDoc = function() {\n\t\tif (doc) { return doc; }\n\t\ttry {\n\t\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\t\tif (doc) {\n\t\t\t\tdoc.open().write('<html></html>');\n\t\t\t\tdoc.close();\n\t\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\t\tdoc = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch(e) {}\n\t\t\n\t\tif (!doc) { doc = document; }\n\t\treturn doc;\n\t};\n\n\texports.XHR = function() {\n\t\tvar win = window,\n\t\t\tdoc = exports.getDoc();\n\t\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\t\n\t\treturn new (exports.XHR = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n\t}\n\t\n\texports.createXHR = function() { return new exports.XHR(); }\n\n})();\n\nfunction isLocalFile(url) { return /^file:\\/\\//.test(url); }\nfunction isWindowDomain(url) { return uri.isSameDomain(url, window.location.href); }\n\nvar xhrSupportsBinary = undefined;\nfunction checkXHRBinarySupport(xhr) {\n\txhrSupportsBinary = !!xhr.sendAsBinary;\n}\n\nfunction canUseXHR(url) {\n\t// always use jsonp for local files\n\tif (isLocalFile(url)) { return false; }\n\t\n\t// try to create an XHR using the same function the XHR transport uses\n\tvar xhr = new exports.XHR();\n\tif (!xhr) { return false; }\n\t\n\tcheckXHRBinarySupport(xhr);\n\t\n\t// if the URL requested is the same domain as the window,\n\t// then we can use same-domain XHRs\n\tif (isWindowDomain(url)) { return true; }\n\t\n\t// if the URL requested is a different domain than the window,\n\t// then we need to check for cross-domain support\n\tif (window.XMLHttpRequest\n\t\t\t&& (xhr.__proto__ == XMLHttpRequest.prototype // WebKit Bug 25205\n\t\t\t\t|| xhr instanceof window.XMLHttpRequest)\n\t\t\t&& xhr.withCredentials !== undefined\n\t\t|| window.XDomainRequest \n\t\t\t&& xhr instanceof window.XDomainRequest) {\n\t\treturn true;\n\t}\n};\n\nvar transports = exports.transports = {};\n\nexports.chooseTransport = function(url, options) {\n\tswitch(options.preferredTransport) {\n\t\tcase 'jsonp':\n\t\t\treturn transports.jsonp;\n\t\tcase 'xhr':\n\t\tdefault:\n\t\t\tif (canUseXHR(url)) { return transports.xhr; };\n\t\t\treturn transports.jsonp;\n\t}\n};\n\n// TODO: would be nice to use these somewhere...\n\nvar PARAMS = {\n\t'xhrstream':   {\"is\": \"1\", \"bs\": \"\\n\"},\n\t'xhrpoll':     {\"du\": \"0\"},\n\t'xhrlongpoll': {},\n\t'sselongpoll': {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\"},\n\t'ssestream':   {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\", \"is\": \"1\"}\n};\n\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tthis.handshake = function(url, options) {\n\t\tthrow new Error(\"handshake Not Implemented\"); \n\t};\n\tthis.comet = function(url, sessionKey, lastEventId, options) { \n\t\tthrow new Error(\"comet Not Implemented\"); \n\t};\n\tthis.send = function(url, sessionKey, data, options) { \n\t\tthrow new Error(\"send Not Implemented\");\n\t};\n\tthis.encodePacket = function(packetId, data, options) { \n\t\tthrow new Error(\"encodePacket Not Implemented\"); \n\t};\n\tthis.abort = function() { \n\t\tthrow new Error(\"abort Not Implemented\"); \n\t};\n});\n\nbaseTransport=__class__;var baseTransport=baseTransport(function baseTransport(){return this.init&&this.init.apply(this,arguments)},exports.Transport, function(supr) {\n\tthis.init = function() {\n\t\tthis._aborted = false;\n\t\tthis._handshakeArgs = {ct:'application/javascript'};\n\t\tthis._handshakeData = '{}'\n\t};\n\t\n\tthis.handshake = function(url, options) {\n\t\tlogger.debug('handshake:', url, options);\n\t\tthis._makeRequest('send', url + '/handshake', \n\t\t\t\t\t\t  this._handshakeArgs,\n\t\t\t\t\t\t  this._handshakeData,\n\t\t\t\t\t\t  this.handshakeSuccess, \n\t\t\t\t\t\t  this.handshakeFailure);\n\t};\n\t\n\tthis.comet = function(url, sessionKey, lastEventId, options) {\n\t\tlogger.debug('comet:', url, sessionKey, lastEventId, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('comet', url + '/comet', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  this.cometSuccess, \n\t\t\t\t\t\t  this.cometFailure);\n\t};\n\t\n\tthis.send = function(url, sessionKey, lastEventId, data, options) {\n\t\t//logger.debug('send:', url, sessionKey, data, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('send', url + '/send', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  data,\n\t\t\t\t\t\t  this.sendSuccess, \n\t\t\t\t\t\t  this.sendFailure);\n\t};\n});\n\ntransports.xhr=__class__;transports.xhr=transports.xhr(function transports_xhr(){return this.init&&this.init.apply(this,arguments)},baseTransport, function(supr) {\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\t\n\t\tthis._xhr = {\n\t\t\t'send': new exports.XHR(),\n\t\t\t'comet': new exports.XHR()\n\t\t};\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._xhr) {\n\t\t\tif(this._xhr.hasOwnProperty(i)) {\n\t\t\t\tthis._abortXHR(i);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._abortXHR = function(type) {\n\t\tlogger.debug('aborting XHR');\n\n\t\tvar xhr = this._xhr[type];\n\t\ttry {\n\t\t\tif('onload' in xhr) {\n\t\t\t\txhr.onload = xhr.onerror = xhr.ontimeout = null;\n\t\t\t} else if('onreadystatechange' in xhr) {\n\t\t\t\txhr.onreadystatechange = null;\n\t\t\t}\n\t\t\tif(xhr.abort) { xhr.abort(); }\n\t\t} catch(e) {\n\t\t\tlogger.debug('error aborting xhr', e);\n\t\t}\n\t\t\n\t\t// do not reuse aborted XHRs\n\t\tthis._xhr[type] = new exports.XHR();\n\t};\n\t\n\tthis.encodePacket = function(packetId, data, options) {\n\t\t// we don't need to base64 encode things unless there's a null character in there\n\t\treturn !xhrSupportsBinary ? [ packetId, 1, base64.encode(data) ] : [ packetId, 0, data ];\n\t};\n\n\tfunction onReadyStateChange(xhr, rType, cb, eb) {\n\t\ttry {\n\t\t\tvar data = {status: xhr.status};\n\t\t} catch(e) { eb({response: 'Could not access status'}); }\n\t\t\n\t\ttry {\n\t\t\tif(xhr.readyState != 4) { return; }\n\t\t\t\n\t\t\tdata.response = eval(xhr.responseText);\n\t\t\tif(data.status != 200) { \n\t\t\t\tlogger.debug('XHR failed with status ', xhr.status);\n\t\t\t\teb(data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlogger.debug('XHR data received');\n\t\t} catch(e) {\n\t\t\tlogger.debug('Error in XHR::onReadyStateChange', e);\n\t\t\teb(data);\n\t\t\tthis._abortXHR(rType);\n\t\t\tlogger.debug('done handling XHR error');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcb(data);\n\t};\n\n\t/**\n\t * even though we encode the POST body as in application/x-www-form-urlencoded\n\t */\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif (this._aborted) { return; }\n\t\tvar xhr = this._xhr[rType];\n\t\txhr.open('POST', url + '?' + uri.buildQuery(args)); // must open XHR first\n\t\txhr.setRequestHeader('Content-Type', 'text/plain'); // avoid preflighting\n\t\tif('onload' in xhr) {\n\t\t\txhr.onload = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t\txhr.onerror = xhr.ontimeout = eb;\n\t\t} else if('onreadystatechange' in xhr) {\n\t\t\txhr.onreadystatechange = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t}\n\t\t// NOTE WELL: Firefox (and probably everyone else) likes to encode our nice\n\t\t//\t\t\t\t\t\tbinary strings as utf8. Don't let them! Say no to double utf8\n\t\t//\t\t\t\t\t\tencoding. Once is good, twice isn't better.\n\t\t// if (xhrSupportsBinary) {\n\t\t// \t\txhr.setRequestHeader('x-CSP-SendAsBinary', 'true');\n\t\t// }\n\t\tsetTimeout(function() {\n\t\t\txhr[xhrSupportsBinary ? 'sendAsBinary' : 'send'](data || null)\n\t\t}, 0);\n\t};\n});\n\nvar EMPTY_FUNCTION = function() {},\n\tSLICE = Array.prototype.slice;\n\ntransports.jsonp=__class__;transports.jsonp=transports.jsonp(function transports_jsonp(){return this.init&&this.init.apply(this,arguments)},baseTransport, function(supr) {\n\tvar doc;\n\t\n\tvar createIframe = function() {\n\t\tvar doc = exports.getDoc();\n\t\tif (!doc.body) { return false; }\n\t\t\n\t\tvar i = doc.createElement(\"iframe\");\n\t\twith(i.style) { display = 'block'; width = height = border = margin = padding = '0'; overflow = visibility = 'hidden'; position = 'absolute'; top = left = '-999px'; }\n\t\ti.cbId = 0;\n\t\tdoc.body.appendChild(i);\n\t\ti.src = 'about:blank';\n\t\treturn i;\n\t};\n\n\tvar cleanupIframe = function(ifr) {\n\t\tvar win = ifr.contentWindow, doc = win.document;\n\t\tlogger.debug('removing script tags');\n\t\t\n\t\tvar scripts = doc.getElementsByTagName('script');\n\t\tfor (var i = scripts.length - 1; i >= 0; --i) {\n\t\t\tdoc.body.removeChild(scripts[i]);\n\t\t}\n\t\t\n\t\tlogger.debug('deleting iframe callbacks');\n\t\twin['cb' + ifr.cbId] = win['eb' + ifr.cbId] = EMPTY_FUNCTION;\n\t};\n\n\tvar removeIframe = function(ifr) {\n\t\tsetTimeout(function() {\n\t\t\tif(ifr && ifr.parentNode) { ifr.parentNode.removeChild(ifr); }\n\t\t}, 60000);\n\t};\n\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\n\t\tthis._onReady = [];\n\t\tthis._isReady = false;\n\n\t\tthis._createIframes();\n\t};\n\n\tthis._createIframes = function() {\n\t\tthis._ifr = {\n\t\t\tsend: createIframe(),\n\t\t\tcomet: createIframe()\n\t\t};\n\t\t\n\t\tif(this._ifr.send === false) { return setTimeout(bind(this, '_createIframes'), 100); }\n\t\t\n\t\tthis._isReady = true;\n\n\t\tvar readyArgs = this._onReady;\n\t\tthis._onReady = [];\n\t\tfor(var i = 0, args; args = readyArgs[i]; ++i) {\n\t\t\tthis._makeRequest.apply(this, args);\n\t\t}\n\t};\n\n\tthis.encodePacket = function(packetId, data, options) {\n\t\treturn [ packetId, 1, base64.encode(data) ];\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._ifr) {\n\t\t\tif(this._ifr.hasOwnProperty(i)) {\n\t\t\t\tvar ifr = this._ifr[i];\n\t\t\t\tcleanupIframe(ifr);\n\t\t\t\tremoveIframe(ifr);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif(!this._isReady) { return this._onReady.push(arguments); }\n\t\t\n\t\tvar ifr = this._ifr[rType],\n\t\t\tid = ++ifr.cbId,\n\t\t\treq = {\n\t\t\t\ttype: rType,\n\t\t\t\tid: id,\n\t\t\t\tcb: cb,\n\t\t\t\teb: eb,\n\t\t\t\tcbName: 'cb' + id,\n\t\t\t\tebName: 'eb' + id,\n\t\t\t\tcompleted: false\n\t\t\t};\n\t\t\n\t\targs.d = data;\n\t\targs.n = Math.random();\t\n\t\tswitch(rType) {\n\t\t\tcase 'send': args.rs = ';'; args.rp = req.cbName; break;\n\t\t\tcase 'comet': args.bs = ';'; args.bp = req.cbName; break;\n\t\t}\n\t\t\n\t\treq.url = url + '?' + uri.buildQuery(args)\n\t\t\n\t\tsetTimeout(bind(this, '_request', req), 0);\n\t}\n\t\n\tthis._request = function(req) {\n\t\tvar ifr = this._ifr[req.type],\n\t\t\twin = ifr.contentWindow,\n\t\t\tdoc = win.document,\n\t\t\tbody = doc.body;\n                /*added by skysbird for opera support*/\n                if (!body){return setTimeout(bind(this,'_request',req),100); }\n\t\twin[req.ebName] = bind(this, checkForError, req);\n\t\twin[req.cbName] = bind(this, onSuccess, req);\n\t\t\n\t\tif(BrowserDetect.isWebKit) {\n\t\t\t// this will probably cause loading bars in Safari -- might want to rethink?\n\t\t\tdoc.open();\n\t\t\tdoc.write('<scr'+'ipt src=\"'+req.url+'\"></scr'+'ipt><scr'+'ipt>'+ebName+'(false)</scr'+'ipt>');\n\t\t\tdoc.close();\n\t\t} else {\n\t\t\tvar s = doc.createElement('script');\n\t\t\ts.src = req.url;\n\t\t\t\n\t\t\t// IE\n\t\t\tif(s.onreadystatechange === null) { s.onreadystatechange = bind(this, onReadyStateChange, req, s); }\n\t\t\tbody.appendChild(s);\n\t\t\t\n\t\t\tif(!BrowserDetect.isIE) {\n\t\t\t\tvar s = doc.createElement('script');\n\t\t\t\ts.innerHTML = req.ebName+'(false)';\n\t\t\t\tbody.appendChild(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tkillLoadingBar();\n\t};\n\t\n\tfunction onSuccess(req, response) {\n\t\tlogger.debug('successful: ', req.url, response);\n\t\treq.completed = true;\n\t\t\n\t\tlogger.debug('calling the cb');\n\t\treq.cb.call(GLOBAL, {status: 200, response: response});\n\t\tlogger.debug('cb called');\n\t}\n\t\n\t// IE6/7 onReadyStateChange\n\tfunction onReadyStateChange(req, scriptTag) {\n\t\tif (scriptTag && scriptTag.readyState != 'loaded') { return; }\n\t\tscriptTag.onreadystatechange = function() {};\n\t\tcheckForError.call(this, req);\n\t}\n\n\tfunction checkForError(req, response) {\n\t\tcleanupIframe(this._ifr[req.type]);\n\t\t\n\t\tif (!req.completed) {\n\t\t\tvar data = {\n\t\t\t\tstatus: response ? 200 : 404,\n\t\t\t\tresponse: response || 'Unable to load resouce'\n\t\t\t};\n\t\t\t\n\t\t\tlogger.debug('error making request:', req.url, data);\n\t\t\tlogger.debug('calling eb');\n\t\t\treq.eb.call(GLOBAL, data);\n\t\t}\n\t}\n\t\n\tvar killLoadingBar = BrowserDetect.isFirefox || BrowserDetect.isOpera ? function() {\n\t\tvar b = document.body;\n\t\tif (!b) { return; }\n\t\t\n\t\tif (!killLoadingBar.iframe) { killLoadingBar.iframe = document.createElement('iframe'); }\n\t\tb.insertBefore(killLoadingBar.iframe, b.firstChild);\n\t\tb.removeChild(killLoadingBar.iframe);\n\t} : function() {};\n});\n\t\n","pre":true},"sdk/jsio/util/browserdetect.js":{"path":"sdk/jsio/util/browserdetect.js","friendlyPath":"util.browserdetect","directory":"sdk/jsio/util/","filename":"browserdetect.js","src":"exports.BrowserDetect = new function() {\n\tvar versionSearchString;\n\tvar dataBrowser = [\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Chrome\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"OmniWeb\",\n\t\t\tversionSearch: \"OmniWeb/\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Apple\",\n\t\t\tidentity: \"Safari\",\n\t\t\tversionSearch: \"Version\"\n\t\t},\n\t\t{\n\t\t\tprop: window.opera,\n\t\t\tidentity: \"Opera\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"iCab\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"KDE\",\n\t\t\tidentity: \"Konqueror\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Firefox\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Camino\"\n\t\t},\n\t\t{\t\t// for newer Netscapes (6+)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Netscape\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"MSIE\",\n\t\t\tidentity: \"IE\",\n\t\t\tversionSearch: \"MSIE\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Gecko\",\n\t\t\tidentity: \"Mozilla\",\n\t\t\tversionSearch: \"rv\"\n\t\t},\n\t\t{ \t\t// for older Netscapes (4-)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Mozilla\",\n\t\t\tidentity: \"Netscape\",\n\t\t\tversionSearch: \"Mozilla\"\n\t\t}\n\t];\n\t\n\tvar dataOS = [\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Win\",\n\t\t\tidentity: \"Windows\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Mac\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"iPhone\",\n\t\t\tidentity: \"iPhone/iPod\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Linux\"\n\t\t}\n\t];\n\t\n\tfunction searchString(data) {\n\t\tfor (var i=0,item;item=data[i];i++)\t{\n\t\t\tvar dataString = item.string;\n\t\t\tvar dataProp = item.prop;\n\t\t\titem.identity = item.identity || item.subString;\n\t\t\tversionSearchString = item.versionSearch || item.identity;\n\t\t\tif (dataString) {\n\t\t\t\tif (dataString.indexOf(item.subString) != -1)\n\t\t\t\t\treturn item.identity;\n\t\t\t} else if (dataProp)\n\t\t\t\treturn item.identity;\n\t\t}\n\t}\n\t\n\tfunction searchVersion(dataString) {\n\t\tvar index = dataString.indexOf(versionSearchString);\n\t\tif (index == -1) return;\n\t\treturn parseFloat(dataString.substring(index+versionSearchString.length+1));\n\t}\n\t\n\tthis.browser = searchString(dataBrowser) || \"unknown\";\n\tthis.version = searchVersion(navigator.userAgent)\n\t\t|| searchVersion(navigator.appVersion)\n\t\t|| \"unknown\";\n\tthis.OS = searchString(dataOS) || \"unknown\";\n\tthis.isWebKit = RegExp(\" AppleWebKit/\").test(navigator.userAgent);\n\tthis['is'+this.browser] = this.version;\n};","pre":true},"sdk/jsio/net/env/browser/postmessage.js":{"path":"sdk/jsio/net/env/browser/postmessage.js","friendlyPath":"net.env.browser.postmessage","directory":"sdk/jsio/net/env/browser/","filename":"postmessage.js","src":"jsio(\"import net.interfaces\");\njsio(\"from util.browser import $\");\njsio(\"import std.uuid\");\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener=__class__;exports.Listener=exports.Listener(function exports_Listener(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Listener, function(supr) {\n\tvar ID = 0;\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._clients = {};\n\t\tif (!this._opts.clientUrl) {\n\t\t\tthis._opts.clientUrl = jsio.__dir + '/networkConsole.html';\n\t\t}\n\n\t\tthis._port = '' + (this._opts.port || '');\n\t}\n\n\tthis.listen = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t}\n\n\tthis.getButton = function(url, text) {\n\t\tvar button = $({\n\t\t\ttagName: 'button',\n\t\t\ttext: text || 'launch client',\n\t\t\tclassName: 'clientButton'\n\t\t});\n\t\t$.onEvent(button, 'click', bind(this, 'openWindow', url || this._opts.clientUrl));\n\t\treturn button; \n\t}\n\t\n\tvar uniqueId = 1;\n\tthis.openWindow = function (url) {\n\t\tvar options = { menubar: 'no', location: 'no', toolbar: 'no',\n\t\t\twidth: 550, height: 350, // left: 200, top: 200,\n\t\t\tscrollbars: 'yes', status: 'yes', resizable: 'yes' };\n\t\t\n\t\tvar arr = [];\n\t\tfor (var i in options) { arr.push(i + '=' + options[i]) }\n\t\tvar win = window.open(url, 'W' + uniqueId++, arr.join(','));\n\t\twin.focus();\n\t}\n\t\n\tthis._onMessage = function (evt) {\n\t\tif (this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tvar transport = this._clients[data.uid] = new exports.Transport(evt.source, this._port, data.uid);\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"open\", uid: data.uid}), '*');\n\t\t\t\tthis.onConnect(transport);\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onData(data.payload); }\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onClose(); }\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"close\", uid: data.uid}), '*');\n\t\t\t\tdelete this._clients[data.uid];\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._port = '' + (this._opts.port || '');\n\t\tthis._win = this._opts.win || window.opener || window.parent;\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\n\t\tthis._uid = std.uuid.uuid();\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'open', uid: this._uid}), '*');\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tif (this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\t// At the moment, we include the uid in the data.  If we have many clients\n\t\t// on the same port with different UIDs then this would get expensive, but\n\t\t// this is a very rare use case for postmessage.\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._transport = new exports.Transport(evt.source, this._port, this._uid);\n\t\t\t\tthis.onConnect(this._transport);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onClose();\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onData(data.payload);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Transport\n */\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Transport, function() {\n\tthis.init = function (win, port, uid) {if (!uid) debugger\n\t\tthis._win = win;\n\t\tthis._port = port;\n\t\tthis._uid = uid; // unique identifier for clients\n\t}\n\t\n\tthis.makeConnection = function (protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.write = function (data, encoding) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: utf8.encode(data)}), '*');\n\t\t} else {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: data}), '*');\n\t\t} \n\t}\n\t\n\tthis.loseConnection = function (protocol) {\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'close', uid: this._uid, code: 301}), '*');\n\t}\n\t\n\tthis.onData = function () { this._protocol.dataReceived.apply(this._protocol, arguments); }\n\tthis.onClose = function () { this._protocol._connectionLost.apply(this._protocol, arguments); }\n});\n","pre":true},"sdk/jsio/std/uuid.js":{"path":"sdk/jsio/std/uuid.js","friendlyPath":"std.uuid","directory":"sdk/jsio/std/","filename":"uuid.js","src":"/*\nBased on Math.uuid.js 1.4 by Robert Kieffer\n\n----\nCopyright (c) 2008, Robert Kieffer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in the\n\tdocumentation and/or other materials provided with the distribution.\n  * Neither the name of Robert Kieffer nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n  \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n\n\n/*\n * Generate a random uuid.\n *\n * USAGE: uuid.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> std.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n * \n *   // One argument - returns ID of the specified length\n *   >>> std.uuid(15)\t // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> std.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> std.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> std.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n\n\nvar CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); \nexports.uuid = function (len, radix) {\n\tvar chars = CHARS, uuid = [], rnd = Math.random;\n\tradix = radix || chars.length;\n\n\tif (len) {\n\t\t// Compact form\n\t\tfor (var i = 0; i < len; i++) uuid[i] = chars[0 | rnd()*radix];\n\t} else {\n\t\t// rfc4122, version 4 form\n\t\tvar r;\n\n\t\t// rfc4122 requires these characters\n\t\tuuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\t\tuuid[14] = '4';\n\n\t\t// Fill in random data.  At i==19 set the high bits of clock sequence as\n\t\t// per rfc4122, sec. 4.1.5\n\t\tfor (var i = 0; i < 36; i++) {\n\t\t\tif (!uuid[i]) {\n\t\t\t\tr = 0 | rnd()*16;\n\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n\t\t\t}\n\t\t}\n\t}\n\treturn uuid.join('');\n};\n\n","pre":true},"sdk/jsio/net/env.js":{"path":"sdk/jsio/net/env.js","friendlyPath":"net.env","directory":"sdk/jsio/net/","filename":"env.js","src":"function getObj(objectName, transportName, envName) {\n\t\n\ttry {\n\t\tvar DYNAMIC_IMPORT_ENV = 'from .env.' + (envName || jsio.__env.name) + '.' + transportName + ' import ' + objectName + ' as result';\n\t\tjsio(DYNAMIC_IMPORT_ENV);\n\t} catch(e) {\n\t\tthrow logger.error('Invalid transport (', transportName, ') or environment (', envName, ')');\n\t}\n\treturn result;\n}\n\nexports.getListener = bind(this, getObj, 'Listener');\nexports.getConnector = bind(this, getObj, 'Connector');\n","pre":true},"sdk/jsio/net/protocols/Cuppa.js":{"path":"sdk/jsio/net/protocols/Cuppa.js","friendlyPath":"net.protocols.Cuppa","directory":"sdk/jsio/net/protocols/","filename":"Cuppa.js","src":"\"use import\";\n\njsio(\"import lib.Callback\");\njsio(\"import lib.PubSub\");\n\njsio(\"from net.protocols.rtjp import RTJPProtocol\");\n\nError=__class__;var Error=Error(function Error(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id, msg, details, requestId) {\n\t\tthis.id = id;\n\t\tthis.msg = msg;\n\t\tthis.details = details;\n\t\tthis.requestId = requestId;\n\t}\n});\n\nRPCRequest=__class__;var RPCRequest=RPCRequest(function RPCRequest(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id) {\n\t\tthis.protocol = protocol;\n\t\tthis.id = id;\n\t\tthis._onError = new lib.Callback();\n\t\tthis._onSuccess = new lib.Callback();\n\t}\n\n\tthis.onError = function() { this._onError.forward(arguments); }\n\tthis.onSuccess = function() { this._onSuccess.forward(arguments); }\n\t\n\tthis.bindLater = function(l) {\n\t\tvar args = [].slice(arguments, 1);\n\t\tthis._onError.forward([l, l.fail].concat(args));\n\t\tthis._onSuccess.forward([l, l.succed].concat(args));\n\t\treturn l;\n\t}\n\t\n\t\n});\n\nReceivedRequest=__class__;var ReceivedRequest=ReceivedRequest(function ReceivedRequest(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.type = \"request\"\n\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.protocol = protocol\n\t\tthis.id = id;\n\t\tthis.name = name\n\t\tthis.responded = false;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n\n\tthis.error = function(msg, details) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\targs = {\n\t\t\tid: this.id,\n\t\t\tmsg: msg + \"\"\n\t\t}\n\t\tif (details !== undefined) { args.details = details }\n\t\tthis.responded = true;        \n\t\tthis.protocol.sendFrame('ERROR', args);\n\t}\n\n\tthis.respond = function(args) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\tthis.responded = true;\n\t\tthis.protocol.sendFrame('RESPONSE', {\n\t\t\tid: this.id,\n\t\t\targs: args == undefined ? {} : args // python cuppa ignores responses with undefined args\n\t\t});\n\t}\n\t\n\tthis.timeoutAfter = function(duration, msg) {\n\t\tif (this.responded) { return; }\n\t\tif (this._timer) { clearTimeout(this._timer); }\n\t\tthis._timer = setTimeout(bind(this, '_timeout', msg), duration);\n\t}\n\t\n\tthis._timeout = function(msg) {\n\t\tif (!this.responded) {\n\t\t\tthis.error(msg);\n\t\t}\n\t}\n    \n});\n\nReceivedEvent=__class__;var ReceivedEvent=ReceivedEvent(function ReceivedEvent(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n});\n\n/**\n * @extends net.protocols.rtjp.RTJPProtocol;\n */\nvar sdk_jsio_net_protocols_Cuppa=__class__;exports=sdk_jsio_net_protocols_Cuppa(function sdk_jsio_net_protocols_Cuppa(){return this.init&&this.init.apply(this,arguments)},RTJPProtocol, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\t\n\t\tthis._onConnect = new lib.Callback();\n\t\tthis._onDisconnect = new lib.Callback();\n\t\t\n\t\tthis._requests = {};\n\t\t\n\t\tthis.onEvent = new lib.PubSub();\n\t\tthis.onRequest = new lib.PubSub();\n\t}\n\t\n\tthis.disconnect = function() { this.transport.loseConnection(); }\n\t\n\t// pass something to call (ctx, method, args...) when connected\n\tthis.onConnect = function() { this._onConnect.forward(arguments); }\n\tthis.onDisconnect = function() { this._onDisconnect.forward(arguments); }\n\t\n\tthis.reset = function() {\n\t\tthis._onConnect.reset();\n\t\tthis._onDisconnect.reset();\n\t}\n\t\n\t// called when we're connected\n\tthis.connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis._onConnect.fire();\n\t}\n\t\n\tthis.connectionLost = function(err) {\n\t\tfor (var i in this._requests) {\n\t\t\tvar req = this._requests[i];\n\t\t\tdelete this._requests[i];\n\t\t\treq._onError.fire(err);\n\t\t}\n\t\t\n\t\tthis._isConnected = false;\n\t\tthis._onDisconnect.fire(err);\n\t}\n\t\n\tthis.sendRequest = function(name, args, target, cb) {\n\t\tif (arguments.length > 4) { // allow bound functions (e.g. [this, 'onResponse', 123])\n\t\t\tcb = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 3));\n\t\t}\n\t\t\n\t\tvar frameArgs = {\n\t\t\tname: name,\n\t\t\targs: args\n\t\t};\n\t\t\n\t\tif (target) { frameArgs.target = target; }\n\t\t\n\t\tvar id = this.sendFrame('RPC', frameArgs),\n\t\t\treq = this._requests[id] = new RPCRequest(this, id);\n\t\t\n\t\tif (cb) {\n\t\t\treq.onSuccess(GLOBAL, cb, false); // will call cb(false, args...)\n\t\t\treq.onError(GLOBAL, cb); // will call cb(err)\n\t\t}\n\t\t\n\t\treturn req;\n\t}\n\t\n\tthis.sendEvent = function(name, args, target) {\n\t\tthis.sendFrame('EVENT', {name: name, args: args, target: target || null});\n\t}\n\t\n\tthis.frameReceived = function(id, name, args) {\n\t\tlogger.debug('RECEIVED', id, name, args);\n\t\tswitch(name.toUpperCase()) {\n\t\t\tcase 'RESPONSE':\n\t\t\t\tvar req = this._requests[args.id];\n\t\t\t\tif (!req) { return; }\n\t\t\t\tdelete this._requests[args.id];\n\t\t\t\treq._onSuccess.fire(args.args);\n\t\t\t\tbreak;\n\t\t\tcase 'ERROR':\n\t\t\t\tvar msg = args.msg || 'unknown',\n\t\t\t\t\trequestId = args.id,\n\t\t\t\t\treq = this._requests[requestId],\n\t\t\t\t\terr = new Error(this, id, msg, args.details, requestId);\n\t\t\t\t\n\t\t\t\tif (!req) {\n\t\t\t\t\treturn this.errorReceived && this.errorReceived(err);\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._requests[requestId];\n\t\t\t\t\treq._onError.fire(err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RPC':\n\t\t\tcase 'EVENT':\n\t\t\t\tif (!args.name) {\n\t\t\t\t\treturn self.sendFrame('ERROR', { 'id': args.id || id, 'msg': 'missing \"name\"' });\n\t\t\t\t}\n\t\t\t\tvar frameArgs = args.args || {},\n\t\t\t\t\ttarget = args.target || null,\n\t\t\t\t\tisRPC = name.toUpperCase() == 'RPC',\n\t\t\t\t\treqCtor = isRPC ? ReceivedRequest : ReceivedEvent,\n\t\t\t\t\tpubTarget = isRPC ? this.onRequest : this.onEvent,\n\t\t\t\t\treq = new reqCtor(this, args.id || id, args.name, frameArgs, target);\n\t\t\t\t\n\t\t\t\tpubTarget.publish(req.name, req);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n","pre":true},"sdk/jsio/net/protocols/rtjp.js":{"path":"sdk/jsio/net/protocols/rtjp.js","friendlyPath":"net.protocols.rtjp","directory":"sdk/jsio/net/protocols/","filename":"rtjp.js","src":"jsio('import net.interfaces');\njsio('from net.protocols.delimited import DelimitedProtocol');\n\n/**\n * @extends net.protocols.delimited.DelimitedProtocol\n */\nexports.RTJPProtocol=__class__;exports.RTJPProtocol=exports.RTJPProtocol(function exports_RTJPProtocol(){return this.init&&this.init.apply(this,arguments)},DelimitedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tvar delimiter = '\\r\\n';\n\t\tsupr(this, 'init', [delimiter]);\n\t\tthis.frameId = 0;\n\t}\n\n\tthis.connectionMade = function() {\n\t\tif (this._client && this._client.connectionMade) { this._client.connectionMade(); }\n\t\tlogger.debug(\"connectionMade\");\n\t}\n\t\n\tvar error = function(e) {\n\t\tlogger.error(e);\n\t}\n\t\n\t// Inherit and overwrite\n\tthis.frameReceived = function(id, name, args) {\n\t}\n\n\t// Public\n\tthis.sendFrame = function(name, args) {\n\t\tif (!args) {\n\t\t\targs = {}\n\t\t}\n\t\tlogger.debug('sendFrame', name, JSON.stringify(args));\n\t\tthis.sendLine(JSON.stringify([++this.frameId, name, args]));\n\t\treturn this.frameId;\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\ttry {\n\t\t\tvar frame = JSON.parse(line);\n\t\t\tif (frame.length != 3) {\n\t\t\t\treturn error.call(this, \"Invalid frame length\");\n\t\t\t}\n\t\t\tif (typeof(frame[0]) != \"number\") {\n\t\t\t\treturn error.call(this, \"Invalid frame id\");\n\t\t\t}\n\t\t\tif (typeof(frame[1]) != \"string\") {\n\t\t\t\treturn error.call(this, \"Invalid frame name\");\n\t\t\t}\n\t\t\tlogger.debug(\"frameReceived:\", frame[0], frame[1], JSON.stringify(frame[2]));\n\t\t} catch(e) {\n\t\t\terror.call(this, e);\n\t\t}\n\t\t\n\t\tif (frame) {\n\t\t\tthis.frameReceived(frame[0], frame[1], frame[2]);\n\t\t}\n\t}\n\n\tthis.connectionLost = function() {\n\t\tlogger.debug('conn lost');\n\t}\n});\n\n\n\n","pre":true},"sdk/jsio/net/protocols/delimited.js":{"path":"sdk/jsio/net/protocols/delimited.js","friendlyPath":"net.protocols.delimited","directory":"sdk/jsio/net/protocols/","filename":"delimited.js","src":"jsio('import net.interfaces');\n\n/**\n * @extends net.interfaces.Protocol\n */\nexports.DelimitedProtocol=__class__;exports.DelimitedProtocol=exports.DelimitedProtocol(function exports_DelimitedProtocol(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Protocol, function(supr) {\n\n\tthis.init = function(delimiter) {\n\t\tif (!delimiter) {\n\t\t\tdelimiter = '\\r\\n'\n\t\t}\n\t\tthis.delimiter = delimiter;\n\t\tthis.buffer = \"\"\n\t}\n\t\n\tthis.connectionMade = function() {\n\t\tlogger.debug('connectionMade');\n\t}\n\t\n\tthis.dataReceived = function(data) {\n\t\tif (!data) { return; }\n\t\tlogger.debug('dataReceived:(' + data.length + ')', data);\n\t\tlogger.debug('last 2:', JSON.stringify(data.slice(data.length-2)));\n\t\tthis.buffer += data;\n\t\tvar i;\n\t\twhile ((i = this.buffer.indexOf(this.delimiter)) != -1) {\n\t\t\tvar line = this.buffer.slice(0, i);\n\t\t\tthis.buffer = this.buffer.slice(i + this.delimiter.length);\n\t\t\tthis.lineReceived(line);\n\t\t}\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\tlogger.debug('Not implemented, lineReceived:', line);\n\t}\n\tthis.sendLine = function(line) {\n\t\tlogger.debug('WRITE:', JSON.stringify(line + this.delimiter));\n\t\tthis.transport.write(line + this.delimiter);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('connectionLost');\n\t}\n});\n\n","pre":true},"sdk/gc/debugging/_DEBUG.js":{"path":"sdk/gc/debugging/_DEBUG.js","friendlyPath":"._DEBUG","directory":"sdk/gc/debugging/","filename":"_DEBUG.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\n\t/*\n\t * Tools for traversing views from the JS console.\n\t * This class ends up being in the global scope:\n\t *   GLOBAL._DEBUG = new exports();\n\t */\nvar sdk_gc_debugging__DEBUG=__class__;\texports=sdk_gc_debugging__DEBUG(function sdk_gc_debugging__DEBUG(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\t\tthis.traverse = function (f) { return GC.app && this.traverseView(f, GC.app.view); }\n\t\tthis.traverseView = function(f, view) {\n\t\t\treturn {\n\t\t\t\tuid: view.uid,\n\t\t\t\tdata: f(view),\n\t\t\t\tsubviews: view.getSubviews().map(bind(this, 'traverseView', f))\n\t\t\t};\n\t\t}\n\n\t\tthis.find = function (f) { return GC.app && this.findView(f, GC.app.view); }\n\t\tthis.findView = function (f, view) {\n\t\t\tif (f(view)) { return view; }\n\t\t\tvar subviews = view.getSubviews();\n\t\t\tfor (var i = 0, sub; sub = subviews[i]; ++i) {\n\t\t\t\tvar res = this.findView(f, sub);\n\t\t\t\tif (res) { return res; }\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.getViewByID = function (uid) { return this.find(function (view) { return view.uid == uid; }); }\n\n\t\tthis.pack = function () { return GC.app && this.packView(GC.app.view); }\n\t\tthis.packView = function (view) {\n\t\t\tjsio(\"import ui.ImageView\");\n\t\t\tjsio(\"import ui.TextView\");\n\n\t\t\treturn this.traverseView(function (view) {\n\n\t\t\t\tif (view instanceof ui.ImageView) {\n\t\t\t\t\tvar img = view.getImage();\n\t\t\t\t\tif (img) {\n\t\t\t\t\t\tvar imageData = img.getMap();\n\t\t\t\t\t\timageData.type = 'ImageView';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (view instanceof ui.TextView) {\n\t\t\t\t\tvar text = view.getText();\n\t\t\t\t}\n\n\t\t\t\tvar s = view.style;\n\t\t\t\treturn {\n\t\t\t\t\tx: s.x,\n\t\t\t\t\ty: s.y,\n\t\t\t\t\twidth: s.width,\n\t\t\t\t\theight: s.height,\n\t\t\t\t\tscale: s.scale,\n\t\t\t\t\timage: imageData,\n\t\t\t\t\ttext: text,\n\t\t\t\t\tvisible: s.visible,\n\t\t\t\t\topacity: s.opacity,\n\t\t\t\t\ttag: view.getTag()\n\t\t\t\t};\n\t\t\t}, view);\n\t\t}\n\n\t\tthis.unpack = function (data) {\n\t\t\tjsio(\"import ui.View\");\n\t\t\tjsio(\"import ui.ImageView\");\n\t\t\tjsio(\"import ui.resource.Image\");\n\t\t\tjsio(\"import ui.TextView\");\n\n\t\t\tfunction buildView (superview, data) {\n\t\t\t\tvar view;\n\n\t\t\t\tvar opts = data.data;\n\t\t\t\tif (opts.image) {\n\t\t\t\t\tvar img = opts.image;\n\t\t\t\t\tview = new ui.ImageView({\n\t\t\t\t\t\tx: opts.x,\n\t\t\t\t\t\ty: opts.y,\n\t\t\t\t\t\twidth: opts.width,\n\t\t\t\t\t\theight: opts.height,\n\t\t\t\t\t\tscale: opts.scale,\n\n\t\t\t\t\t\tscaleMethod: img.scaleMethod,\n\t\t\t\t\t\tslices: img.slices,\n\n\t\t\t\t\t\tsuperview: superview,\n\t\t\t\t\t\timage: new ui.resource.Image({\n\t\t\t\t\t\t\turl: img.url,\n\t\t\t\t\t\t\tsourceX: img.x,\n\t\t\t\t\t\t\tsourceY: img.y,\n\t\t\t\t\t\t\tsourceW: img.width,\n\t\t\t\t\t\t\tsourceH: img.height,\n\t\t\t\t\t\t\tmarginTop: img.marginTop,\n\t\t\t\t\t\t\tmarginRight: img.marginRight,\n\t\t\t\t\t\t\tmarginBottom: img.marginBottom,\n\t\t\t\t\t\t\tmarginLeft: img.marginLeft\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tvisible: opts.visible,\n\t\t\t\t\t\topacity: opts.opacity,\n\t\t\t\t\t\ttag: opts.tag\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tview = new (opts.text ? ui.TextView : ui.View)({\n\t\t\t\t\t\tx: opts.x,\n\t\t\t\t\t\ty: opts.y,\n\t\t\t\t\t\twidth: opts.width,\n\t\t\t\t\t\theight: opts.height,\n\t\t\t\t\t\ttext: opts.text,\n\t\t\t\t\t\tsuperview: superview,\n\t\t\t\t\t\tscale: opts.scale,\n\t\t\t\t\t\tvisible: opts.visible,\n\t\t\t\t\t\topacity: opts.opacity,\n\t\t\t\t\t\ttag: opts.tag\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tview.uid = data.uid;\n\n\t\t\t\tfor (var i = 0, sub; sub = data.subviews[i]; ++i) {\n\t\t\t\t\tbuildView(view, sub);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGC.app.view.updateOpts(data.data);\n\t\t\tfor (var i = 0, sub; sub = data.subviews[i]; ++i) {\n\t\t\t\tbuildView(GC.app.view, sub);\n\t\t\t}\n\t\t}\n\n\t\tthis.eachView = function (list, f) {\n\t\t\tfor (var i = 0, n = list.length; i < n; ++i) {\n\t\t\t\tvar view = this.getViewByID(list[i]);\n\t\t\t\tif (view) {\n\t\t\t\t\tf(view, list[i]);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn('view', list[i], 'not found');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.hideViews = function (/* id1, id2, id3, ... */) {\n\t\t\tthis.eachView(arguments, function (view) { view.style.visible = false; });\n\t\t}\n\n\t\tthis.showViews = function (/* id1, id2, id3, ... */) {\n\t\t\tthis.eachView(arguments, function (view) { view.style.visible = true; });\n\t\t}\n\n\t\tthis.hideAllViews = function () {\n\t\t\tthis.traverse(function (view) { view.style.visible = false; });\n\t\t}\n\n\t\tthis.showAllViews = function () {\n\t\t\tthis.traverse(function (view) { view.style.visible = true; });\n\t\t}\n\n\t\tthis.hideViewRange = function (a, b) {\n\t\t\tvar range = [];\n\t\t\tfor (var i = a; i < b; ++i) {\n\t\t\t\trange.push(i);\n\t\t\t}\n\n\t\t\tthis.hideViews.apply(this, range);\n\t\t}\n\n\t\tthis.showViewRange = function (a, b) {\n\t\t\tvar range = [];\n\t\t\tfor (var i = a; i < b; ++i) {\n\t\t\t\trange.push(i);\n\t\t\t}\n\n\t\t\tthis.showViews.apply(this, range);\n\t\t}\n\t});\n}","pre":true},"sdk/timestep/ui/ImageView.js":{"path":"sdk/timestep/ui/ImageView.js","friendlyPath":"ui.ImageView","directory":"sdk/timestep/ui/","filename":"ImageView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.ImageView;\n * Import the ImageView from the Canvas/DOM rendering backend.\n *\n * @doc http://doc.gameclosure.com/api/ui-imageview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/imageview.md\n */\n\njsio(\"import device\");\nexports = device.importUI('ImageView');\n","pre":true},"sdk/timestep/ui/TextView.js":{"path":"sdk/timestep/ui/TextView.js","friendlyPath":"ui.TextView","directory":"sdk/timestep/ui/","filename":"TextView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.TextView;\n * Import the Canvas/DOM implementation of TextView.\n *\n * @doc http://doc.gameclosure.com/api/ui-text.html#class-ui.textview\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/text.md\n */\n\njsio(\"import device\");\n\nexports = device.importUI('TextView');\n","pre":true},"sdk/gc/debugging/logProxy.js":{"path":"sdk/gc/debugging/logProxy.js","friendlyPath":".logProxy","directory":"sdk/gc/debugging/","filename":"logProxy.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\tfunction stringify(value) {\n\t\tif (value === null) {\n\t\t\treturn 'null';\n\t\t} else if (typeof value == 'object') {\n\t\t\tif (isArray(value)) {\n\t\t\t\tvalue = value.slice(0);\n\t\t\t\tfor (var i = 0, n = value.length; i < n; ++i) {\n\t\t\t\t\tvalue[i] = stringify(value[i]);\n\t\t\t\t}\n\t\t\t\treturn '[' + value.join(', ') + ']';\n\t\t\t} else if (value.__class__) {\n\t\t\t\treturn '[object ' + value.__class__ + ']';\n\t\t\t} else {\n\t\t\t\treturn Object.prototype.toString.call(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn String(value);\n\t\t}\n\t}\n\n\tvar _logBuffer = [];\n\tvar _isInstalled = false;\n\tvar _isEnabled = true;\n\n\t// insert a hook into the js.io logging system so that calls to logger get routed over the network\n\texports.install = function (conn) {\n\t\tif (_isInstalled) { return; }\n\t\t_isInstalled = true;\n\n\t\tjsio(\"import base\");\n\n\t\tvar oldLog = base.log;\n\n\t\t// don't buffer logs if we haven't connected within 10 seconds\n\t\tvar timeout = setTimeout(function() { _isEnabled = false; }, 10000);\n\t\tconn.onConnect(function() {\n\t\t\tclearTimeout(timeout);\n\t\t\texports.flushBuffer();\n\t\t});\n\n\t\tvar isLocked = false;\n\t\tbase.log = function() {\n\t\t\tif (_isEnabled && !isLocked) {\n\t\t\t\tisLocked = true; // prevent recursive loops if sendEvent decides to log stuff\n\n\t\t\t\t// convert arguments to strings\n\t\t\t\tvar n = arguments.length;\n\t\t\t\tvar args = new Array(n);\n\t\t\t\tfor (var i = 0; i < n; ++i) {\n\t\t\t\t\targs[i] = stringify(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\t// buffer log lines\n\t\t\t\tif (!conn || !conn.isConnected()) {\n\t\t\t\t\t_logBuffer.push(args);\n\t\t\t\t} else {\n\t\t\t\t\t// flush logs\n\t\t\t\t\tif (_logBuffer[0]) {\n\t\t\t\t\t\tfor (var i = 0, log; log = _logBuffer[i]; ++i) {\n\t\t\t\t\t\t\tconn.sendEvent('LOG', log);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_logBuffer = [];\n\t\t\t\t\t}\n\n\t\t\t\t\t// send log\n\t\t\t\t\tconn.sendEvent('LOG', args);\n\t\t\t\t}\n\n\t\t\t\tisLocked = false;\n\t\t\t}\n\n\t\t\treturn oldLog.apply(this, arguments);\n\t\t};\n\t}\n\n\texports.flushBuffer = function () {\n\t\t// we timed out, so bail\n\t\tif (!_logBuffer) { return conn.close(); }\n\n\t\t// if we buffered log messages, send them\n\t\tvar n = _logBuffer.length;\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tconn.sendEvent('LOG', _logBuffer[i]);\n\t\t}\n\n\t\t_logBuffer = [];\n\t}\n}\n","pre":true},"sdk/gc/debugging/remoteEval.js":{"path":"sdk/gc/debugging/remoteEval.js","friendlyPath":".remoteEval","directory":"sdk/gc/debugging/","filename":"remoteEval.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\n\tvar _isInstalled = false;\n\n\texports.install = function (conn) {\n\t\tif (_isInstalled) { return; }\n\t\t_isInstalled = true;\n\n\t\tconn.onError = function(err) {\n\t\t\tlogger.log('log protocol error:', err);\n\t\t}\n\t\t\n\t\tconn.onConnect(function() {\n\t\t\tconn.sendEvent(\"HANDSHAKE\", {\n\t\t\t\t\"type\": jsio.__env.name,\n\t\t\t\t\"appID\": CONFIG.appID,\n\t\t\t\t\"version\": CONFIG.version,\n\t\t\t\t\"title\": CONFIG.title,\n\t\t\t\t\"shortName\": CONFIG.shortName,\n\t\t\t\t\"userAgent\": navigator.userAgent,\n\t\t\t\t\"device\": NATIVE.device\n\t\t\t});\n\n\t\t\tlogger.log('DEBUGGING CONNECTION MADE');\n\t\t});\n\n\t\tconn.onDisconnect(function() {\n\t\t\tlogger.log('DEBUGGING CONNECTION LOST');\n\t\t});\n\n\t\tconn.onRequest.subscribe('EVAL', this, function(req) {\n\t\t\ttry {\n\t\t\t\tvar value;\n\t\t\t\tif (GLOBAL.NATIVE && NATIVE.eval) {\n\t\t\t\t\tvalue = NATIVE.eval(req.args, \"[console]\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue = window.eval(req.args, \"[console]\");\n\t\t\t\t}\n\n\t\t\t\treq.respond(stringify(value));\n\t\t\t} catch (e) {\n\t\t\t\treq.error(e.name + \": \" + e.message);\n\t\t\t}\n\t\t});\n\t}\n}\n","pre":true},"sdk/gc/debugging/TimestepInspector.js":{"path":"sdk/gc/debugging/TimestepInspector.js","friendlyPath":"..debugging.TimestepInspector","directory":"sdk/gc/debugging/","filename":"TimestepInspector.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\tjsio(\"import device\");\n\tjsio(\"import math.geom.Point as Point\");\n\tjsio(\"import ui.resource.Image as Image\");\n\tjsio(\"import ui.ImageView as ImageView\");\n\n\tjsio(\"import .OverlayRenderer\");\n\n\t// mapping for reading/writing style properties on a view\n\t// map: inspector id -> style property\n\tvar _propMap = {\n\t\trelX: 'x',\n\t\trelY: 'y',\n\t\trelR: 'r',\n\t\trelWidthPercent: 'widthPercent',\n\t\trelHeightPercent: 'heightPercent',\n\t\trelWidth: 'width',\n\t\trelHeight: 'height',\n\t\trelScale: 'scale',\n\t\topacity: 'opacity',\n\t\tzIndex: 'zIndex',\n\t\tvisible: 'visible',\n\t\tanchorX: 'anchorX',\n\t\tanchorY: 'anchorY',\n\t\toffsetX: 'offsetX',\n\t\toffsetY: 'offsetY',\n\t\tclip: 'clip',\n\t\tlayout: 'layout',\n\t\tinLayout: 'inLayout',\n\t\ttop: 'top',\n\t\tleft: 'left',\n\t\tbottom: 'bottom',\n\t\tright: 'right',\n\t\tflex: 'flex',\n\t\tdirection: 'direction',\n\t\tjustifyContent: 'justifyContent',\n\t\torder: 'order',\n\n\t\tlayoutWidth: 'layoutWidth',\n\t\tlayoutHeight: 'layoutHeight',\n\t\tcenterX: 'centerX',\n\t\tcenterY: 'centerY',\n\t\tminWidth: 'minWidth',\n\t\tminHeight: 'minHeight',\n\t\tmaxWidth: 'maxWidth',\n\t\tmaxHeight: 'maxHeight',\n\t};\n\nvar sdk_gc_debugging_TimestepInspector=__class__;\texports=sdk_gc_debugging_TimestepInspector(function sdk_gc_debugging_TimestepInspector(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\tthis.init = function (conn) {\n\t\t\tthis._overlay = new OverlayRenderer();\n\t\t}\n\n\t\tthis.setConn = function (conn) {\n\t\t\tthis._conn = conn;\n\n\t\t\tif (CONFIG.splash) {\n\t\t\t\tvar prevHide = CONFIG.splash.hide;\n\t\t\t\tCONFIG.splash.hide = bind(this, function () {\n\t\t\t\t\tprevHide && prevHide.apply(this, arguments);\n\t\t\t\t\tif (this._conn) {\n\t\t\t\t\t\tthis._conn.onConnect(this, function () {\n\t\t\t\t\t\t\tthis._conn.sendEvent('HIDE_LOADING_IMAGE');\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconn.onEvent.subscribe('BATCH', this, function (evt) {\n\t\t\t\tvar i;\n\t\t\t\tfor (i in evt.args) {\n\t\t\t\t\tconn.onEvent.publish(evt.args[i].name, evt.args[i].args);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('SET_NAME', this, function (evt) {\n\t\t\t\tGLOBAL._name = evt.args.name;\n\t\t\t\tlogging.setPrefix(evt.args.name + ': ');\n\t\t\t});\n\n\t\t\tvar _homeScreen = false;\n\t\t\tconn.onEvent.subscribe('HOME_BUTTON', this, function () {\n\t\t\t\tif (!GC) return;\n\n\t\t\t\tvar app = GC.app;\n\n\t\t\t\tif (this._homeScreen) {\n\t\t\t\t\tGC._onShow && GC._onShow();\n\t\t\t\t\tapp.engine.resume();\n\t\t\t\t} else {\n\t\t\t\t\tGC._onHide && GC._onHide();\n\t\t\t\t\tapp.engine.pause();\n\n\t\t\t\t\tvar canvas = document.getElementsByTagName('canvas');\n\t\t\t\t\tif (canvas.length) {\n\t\t\t\t\t\tcanvas = canvas[0];\n\t\t\t\t\t\tif (canvas.getContext) {\n\t\t\t\t\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\t\t\t\t\tctx.fillStyle = '#000000';\n\t\t\t\t\t\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._homeScreen ^= true;\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('BACK_BUTTON', this, function (evt) {\n\t\t\t\tGLOBAL.NATIVE.onBackButton();\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('SCREENSHOT', this, function (req) {\n\t\t\t\tvar canv = GC.app.engine.getElement();\n\t\t\t\tif (canv && canv.toDataURL) {\n\t\t\t\t\treq.respond({\n\t\t\t\t\t\twidth: canv.width,\n\t\t\t\t\t\theight: canv.height,\n\t\t\t\t\t\tcanvasImg: canv.toDataURL('image/png')\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treq.error({\n\t\t\t\t\t\tNOT_SUPPORTED: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('MUTE', this, function (evt) {\n\t\t\t\tGLOBAL.ACCESSIBILITY.mute(evt.args.shouldMute);\n\t\t\t});\n\n\t\t\tvar _paused = false;\n\t\t\tconn.onEvent.subscribe('PAUSE', this, function () {\n\t\t\t\tif (!GC) return;\n\t\t\t\tvar app = GC.app;\n\n\t\t\t\tif (_paused) {\n\t\t\t\t\tapp.engine.resume();\n\t\t\t\t\texports._overlay.stopTick();\n\t\t\t\t} else {\n\t\t\t\t\tapp.engine.pause();\n\t\t\t\t\texports._overlay.startTick();\n\t\t\t\t}\n\t\t\t\t_paused = !_paused;\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('STEP', this, function () {\n\t\t\t\tif (!GC) return;\n\t\t\t\tvar app = GC.app;\n\n\t\t\t\tapp.engine.stepFrame();\n\t\t\t\t_paused = true;\n\t\t\t});\n\n\t\t\tvar _input = null;\n\t\t\tconn.onRequest.subscribe('ADD_MOUSE_EVT', this, function (req) {\n\t\t\t\tif (!_input) { _input = new DebugInputHandler(conn); }\n\t\t\t\treq.respond();\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('REMOVE_MOUSE_EVT', this, function (req) {\n\t\t\t\tif (_input) { _input.destroy(); }\n\t\t\t\treq.respond();\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('SET_HIGHLIGHT', this, function (req) {\n\t\t\t\tthis._overlay.setHighlight(req.args.uid);\n\t\t\t\t//this._overlay.render();\n\t\t\t});\n\n\t\t\tconn.onEvent.subscribe('SET_SELECTED', this, function (req) {\n\t\t\t\tthis._overlay.setSelected(req.args.uid);\n\t\t\t\t//this._overlay.render();\n\t\t\t});\n\n\t\t\tfunction findBetterTag (view) {\n\t\t\t\tvar parent = view.getSuperview();\n\t\t\t\tfor (var key in parent) {\n\t\t\t\t\tif (parent[key] === view) {\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconn.onRequest.subscribe('GET_ROOT_UID', this, function (req) {\n\t\t\t\treq.respond({uid: GC.app.view.uid});\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('GET_VIEW', this, function (req) {\n\t\t\t\tvar view = _DEBUG.getViewByID(req.args.uid);\n\t\t\t\tif (!view) {\n\t\t\t\t\treq.error('no view with id' + req.args.uid, {VIEW_NOT_FOUND: true});\n\t\t\t\t} else {\n\t\t\t\t\tvar sup = view.getSuperview();\n\n\t\t\t\t\t//create the optimal tag\n\t\t\t\t\tvar tag = view.getTag && view.getTag() || view.toString();\n\t\t\t\t\tvar betterTag = findBetterTag(view);\n\t\t\t\t\tif (betterTag) tag = betterTag + \":\" + tag;\n\n\t\t\t\t\treq.respond({\n\t\t\t\t\t\tuid: view.uid,\n\t\t\t\t\t\tsuperviewID: sup && sup.uid,\n\t\t\t\t\t\ttag: tag,\n\t\t\t\t\t\tsubviewIDs: view.getSubviews().map(function (view) { return view.uid; })\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('REPLACE_IMAGE', this, function (req) {\n\t\t\t\tvar args = req.args;\n\t\t\t\tvar imgData = args.imgData;\n\t\t\t\tvar uid = args.uid;\n\n\t\t\t\tvar view = _DEBUG.getViewByID(uid);\n\t\t\t\tvar newImg = new Image();\n\n\t\t\t\tnewImg._srcImg.addEventListener(\"load\", function () {\n\t\t\t\t\tvar map = newImg._map;\n\t\t\t\t\tmap.width = newImg._srcImg.width,\n\t\t\t\t\tmap.height = newImg._srcImg.height,\n\t\t\t\t\tmap.x = 0;\n\t\t\t\t\tmap.y = 0;\n\t\t\t\t\tview.setImage(newImg);\n\t\t\t\t\tview.needsRepaint();\n\t\t\t\t}, false);\n\n\t\t\t\tnewImg._srcImg.src = imgData;\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('GET_VIEW_PROPS', this, function (req) {\n\t\t\t\tvar args = req.args;\n\t\t\t\tvar view = _DEBUG.getViewByID(args.uid);\n\t\t\t\tif (!view) {\n\t\t\t\t\treturn req.error(\"VIEW_NOT_FOUND\");\n\t\t\t\t}\n\n\t\t\t\tvar s = view.style;\n\t\t\t\tvar p = view.getPosition();\n\t\t\t\tvar layout = view.__layout;\n\t\t\t\tvar ret = {};\n\t\t\t\tfor (var key in _propMap) {\n\t\t\t\t\tret[key] = s[_propMap[key]];\n\t\t\t\t}\n\n\t\t\t\tmerge(ret, {\n\t\t\t\t\tabsX: p.x,\n\t\t\t\t\tabsY: p.y,\n\t\t\t\t\tabsR: p.r,\n\t\t\t\t\tabsWidth: p.width,\n\t\t\t\t\tabsHeight: p.height,\n\t\t\t\t\tabsScale: p.scale,\n\n\t\t\t\t\tsubviews: layout && (typeof layout.getSubviews == 'function') && layout.getSubviews().length,\n\t\t\t\t\tdirection: layout && (typeof layout.getDirection == 'function') && layout.getDirection(),\n\t\t\t\t\tpadding: s.padding && s.padding.toString()\n\t\t\t\t});\n\n\t\t\t\tfor (var key in ret) {\n\t\t\t\t\tif (ret[key] == undefined) {\n\t\t\t\t\t\tret[key] = '-';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret.isImageView = view instanceof ImageView;\n\n\t\t\t\tif (ret.isImageView) {\n\t\t\t\t\tret.imagePath = view._opts.image || (view._img && view._img._map && view._img._map.url);\n\t\t\t\t\tif (ret.imagePath && ret.imagePath._map) {\n\t\t\t\t\t\tret.imagePath = ret.imagePath._map.url;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret.uuid = args.uid;\n\n\t\t\t\tret.description = (view.constructor.name || 'View') + ' ' + args.uid + '\\n' + view.getTag();\n\n\t\t\t\treq.respond(ret);\n\t\t\t});\n\n\t\t\tconn.onRequest.subscribe('SET_VIEW_PROP', this, function (req) {\n\t\t\t\tvar args = req.args;\n\t\t\t\tvar view = _DEBUG.getViewByID(args.uid);\n\t\t\t\tif (!view) {\n\t\t\t\t\treturn req.error(\"VIEW_NOT_FOUND\");\n\t\t\t\t}\n\n\t\t\t\tvar key = args.key;\n\t\t\t\tvar value = args.value;\n\t\t\t\tif (key in _propMap) {\n\t\t\t\t\tview.style[_propMap[key]] = value;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\tcase 'absX': break;\n\t\t\t\t\t\tcase 'absY': view.style.y = value; break;\n\t\t\t\t\t\tcase 'absWidth': view.style.width = value; break;\n\t\t\t\t\t\tcase 'absHeight': view.style.height = value; break;\n\t\t\t\t\t\tcase 'absScale': view.style.scale = value; break;\n\t\t\t\t\t\tcase 'padding': view.style.padding = value; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar _pollTimer = null;\n\t\t\tvar _pollView = null;\n\n\t\t\tconn.onEvent.subscribe('POLL_VIEW_POSITION', this, function (evt) {\n\n\t\t\t\tfunction poll() {\n\t\t\t\t\tif (_pollView) {\n\t\t\t\t\t\tvar eventData = _pollView.getPosition();\n\t\t\t\t\t\teventData.uid = _pollView.uid;\n\n\t\t\t\t\t\tconn.sendEvent('POLL_VIEW_POSITION', eventData);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_pollView = _DEBUG.getViewByID(evt.args.uid);\n\t\t\t\tif (!_pollTimer && _pollView) {\n\t\t\t\t\t_pollTimer = setInterval(poll, 100);\n\t\t\t\t}\n\n\t\t\t\tif (!_pollView) {\n\t\t\t\t\tclearInterval(poll);\n\t\t\t\t\t_pollTimer = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.setApp = function (app) {\n\t\t\tthis._conn.sendEvent('APP_READY', {uid: app.view.uid});\n\t\t\tapp.engine.unsubscribe('Render', this);\n\t\t\tapp.engine.subscribe('Render', this._overlay, 'render');\n\t\t}\n\t});\n\n\nDebugInputHandler=__class__;\tvar DebugInputHandler=DebugInputHandler(function DebugInputHandler(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\t\tjsio(\"import device\");\n\t\tvar _simulateMouseMove = device.simulating && document.body.addEventListener;\n\n\t\tthis.init = function (conn) {\n\t\t\tthis.conn = conn;\n\t\t\tthis.onMouseMoveCapture = bind(this, this.onMouseMoveCapture);\n\t\t\tthis.setShiftDown = bind(this, this.setShiftDown);\n\t\t\tthis.onContextMenu = bind(this, this.onContextMenu);\n\n\t\t\tif (_simulateMouseMove) {\n\t\t\t\twindow.addEventListener('mousemove', this.onMouseMoveCapture, true);\n\n\t\t\t}\n\n\t\t\t//exports._overlay.setSize(GC.app.view.style.width, GC.app.view.style.height);\n\n\t\t\t//hacky hack to determine if the shift was set or not\n\t\t\twindow.addEventListener('mousedown', this.setShiftDown, true);\n\t\t\twindow.addEventListener('contextmenu', this.onContextMenu, true);\n\n\t\t\tGC.app.view.subscribe('InputMoveCapture', this, 'onInputMoveCapture');\n\t\t\t//GC.app.view.subscribe('InputStartCapture', this, 'onInputSelectCapture');\n\t\t}\n\n\t\tthis.setShiftDown = function (e) {\n\t\t\tif (e.which === 3 || e.button === 2) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._shiftDown = !!e.shiftKey;\n\n\t\t\tif (this._shiftDown) {\n\t\t\t\tthis.onInputSelectCapture(e);\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tjsio(\"import event.input.dispatch as dispatch\");\n\n\t\tthis.onContextMenu = function (e) {\n\t\t\tvar data = {\n\t\t\t\tpt: {x: e.pageX, y: e.pageY}\n\t\t\t};\n\n\t\t\t//get the views under the pointer\n\t\t\tvar clickEvt = {pt: [], trace: [], depth: 0};\n\t\t\tvar clickPt = new Point(e.pageX, e.pageY);\n\t\t\tdispatch.traceEvt(GC.app.view, clickEvt, clickPt);\n\n\t\t\tif (!clickEvt.trace.length) return;\n\t\t\tdata.active = clickEvt.trace[0].uid;\n\n\t\t\t//get the views under the pointer\n\t\t\tvar mockEvt = {pt: [], trace: [], depth: 0};\n\t\t\tvar mockPt = new Point(e.pageX, e.pageY);\n\n\t\t\tthis.traceEvt(GC.app.view, mockEvt, mockPt);\n\n\t\t\tdata.trace = [];\n\t\t\t//convert to small objects\n\t\t\tfor (var i = mockEvt.trace.length - 1, item; item = mockEvt.trace[i]; --i) {\n\t\t\t\tdata.trace.push({\n\t\t\t\t\tuid: item.view.uid,\n\t\t\t\t\ttag: item.view.getTag(),\n\t\t\t\t\tdepth: item.depth\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.conn.sendEvent('INPUT_TRACE', data);\n\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.destroy = function () {\n\t\t\tif (_simulateMouseMove) {\n\t\t\t\twindow.removeEventListener('mousedown', this.onMouseDownCapture, true);\n\t\t\t}\n\n\t\t\twindow.removeEventListener('mousedown', this.setShiftDown, true);\n\t\t\tGC.app.view.unsubscribe('InputMoveCapture', this, 'onInputMoveCapture');\n\t\t\t//GC.app.view.unsubscribe('InputStartCapture', this, 'onInputSelectCapture');\n\t\t}\n\n\t\tthis.onInputMoveCapture = function (evt, pt, allEvt, allPt) {\n\t\t\tvar trace = [];\n\n\t\t\t//loop backwards through the trace\n\t\t\tfor (var i = evt.trace.length - 1, view; view = evt.trace[i]; --i) {\n\t\t\t\ttrace.push(view.uid);\n\n\t\t\t\tvar superview = view.getSuperview();\n\t\t\t\twhile (superview && superview != evt.trace[i + 1]) {\n\t\t\t\t\ttrace.push(superview.uid);\n\t\t\t\t\tsuperview = superview.getSuperview();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tx: pt.x,\n\t\t\t\ty: pt.y,\n\t\t\t\ttrace: trace\n\t\t\t};\n\n\t\t\tthis.conn.sendEvent('INPUT_MOVE', data);\n\t\t}\n\n\t\tthis.onInputSelectCapture = function (e) {\n\t\t\t//only send event if shift click\n\n\n\t\t\tvar evt = {pt: [], trace: [], depth: 0};\n\t\t\tvar pt = new Point(e.pageX, e.pageY);\n\t\t\tdispatch.traceEvt(GC.app.view, evt, pt);\n\n\t\t\tvar trace = [];\n\t\t\tfor (var i = evt.trace.length - 1, view; view = evt.trace[i]; --i) {\n\t\t\t\ttrace.push(view.uid);\n\n\t\t\t\tvar superview = view.getSuperview();\n\t\t\t\twhile (superview && superview != evt.trace[i + 1]) {\n\t\t\t\t\ttrace.push(superview.uid);\n\t\t\t\t\tsuperview = superview.getSuperview();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tx: pt.x,\n\t\t\t\ty: pt.y,\n\t\t\t\ttrace: trace\n\t\t\t};\n\n\t\t\tthis.conn.sendEvent('INPUT_SELECT', data);\n\t\t}\n\n\t\tthis.traceEvt = function(view, evt, pt, depth) {\n\t\t\tdepth = depth || 0;\n\n\t\t\tvar localPt = view.style.localizePoint(new Point(pt));\n\n\t\t\t//if the point is contained add it to the trace\n\t\t\tif (view.containsLocalPoint(localPt)) {\n\t\t\t\tevt.trace.unshift({view: view, depth: depth});\n\t\t\t\tevt.pt[view.uid] = localPt;\n\t\t\t}\n\n\t\t\tvar subviews = view.getSubviews();\n\t\t\tfor (var i = subviews.length - 1; i >= 0; --i) {\n\t\t\t\tif (subviews[i].style.visible) {\n\t\t\t\t\t\tthis.traceEvt(subviews[i], evt, localPt, depth + 1);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (subviews.length === 0) {\n\t\t\t\tevt.target = view;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t\tthis.onMouseMoveCapture = function (e) {\n\t\t\t//$.stopEvent(e);\n\n\t\t\t//get the event to the active target\n\t\t\tvar mockEvt = {pt: [], trace: [], depth: 0};\n\t\t\tvar mockPt = new Point(e.pageX, e.pageY);\n\t\t\tdispatch.traceEvt(GC.app.view, mockEvt, mockPt);\n\n\t\t\tthis.onInputMoveCapture(mockEvt, mockPt);\n\t\t}\n\t});\n}\n","pre":true},"sdk/gc/debugging/OverlayRenderer.js":{"path":"sdk/gc/debugging/OverlayRenderer.js","friendlyPath":".OverlayRenderer","directory":"sdk/gc/debugging/","filename":"OverlayRenderer.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// this whole file should not get included in release\nif (DEBUG) {\n\tjsio(\"import device\");\n\nvar sdk_gc_debugging_OverlayRenderer=__class__;\tvar OverlayRenderer = exports=sdk_gc_debugging_OverlayRenderer(function sdk_gc_debugging_OverlayRenderer(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\t\n\t\t// store the views we need to render\n\t\tthis._highlightViewUID = null;\n\t\tthis.setHighlight = function (uid) { this._highlightViewUID = uid; }\n\n\t\tthis._selectedViewUID = null;\n\t\tthis.setSelected = function (uid) { this._selectedViewUID = uid; }\n\n\t\tvar tick = 0;\n\t\tvar maxColor = 255;\n\t\tvar minColor = 100;\n\n\t\t//render the highlighted view\n\t\tvar _now = +new Date();\n\t\tvar _t = 0;\n\t\tfunction renderHighlight (pos, ctx) {\n\t\t\tif (!ctx) { return; }\n\t\t\tctx.save();\n\t\t\tctx.translate(pos.x, pos.y);\n\t\t\tctx.rotate(pos.r);\n\n\t\t\t// pulsate the blue\n\t\t\ttick += -(_now - (_now = new Date()));\n\n\t\t\tvar weight = (Math.sin(2 * Math.PI * tick / 1000) + 1) / 2;\n\t\t\tvar val = (weight * (maxColor - minColor)) + minColor | 0;\n\n\n\t\t\tvar color = '0,' + (val * .7 | 0) + ',' + (val | 0);\n\n\t\t\tctx.strokeStyle = 'rgba(' + color + ', 0.7)';\n\t\t\tctx.strokeRect(0, 0, pos.width, pos.height);\n\t\t\tctx.fillStyle = 'rgba(' + color + ', 0.6)';\n\t\t\tctx.fillRect(0, 0, pos.width, pos.height);\n\n\t\t\t//draw the cross hair\n\t\t\t//ctx.fillStyle = 'rgb(' + val + ',' + val + ',' + val +')';\n\t\t\tvar opacity = weight * (1 - 0.4) + 0.4;\n\t\t\tctx.fillStyle = 'rgba(255,255,255,' + (opacity.toFixed(2)) +')';\n\t\t\tctx.translate(pos.anchorX, pos.anchorY);\n\t\t\tctx.rotate(tick / 500);\n\n\t\t\tctx.fillRect(-0.5, -7, 1, 14);\n\t\t\tctx.fillRect(-7, -0.5, 14, 1);\n\n\t\t\tctx.restore();\n\t\t}\n\n\t\tfunction renderSelected(pos, ctx) {\n\t\t\tif (!ctx) { return; }\n\t\t\tctx.save();\n\t\t\tctx.translate(pos.x, pos.y);\n\t\t\tctx.rotate(pos.r);\n\t\t\tctx.strokeStyle = \"red\";\n\t\t\tctx.lineWidth = 1;\n\t\t\tctx.strokeRect(-0.5, -0.5, pos.width + 1, pos.height + 1);\n\t\t\tctx.restore();\n\t\t}\n\n\t\tif (!device.isMobile) {\n\t\t\tvar element = document.createElement('x');\n\t\t\tvar documentElement = document.documentElement;\n\t\t\tvar getComputedStyle = window.getComputedStyle;\n\t\t\tvar supportsPointerEvents = false;\n\t\t\tif('pointerEvents' in element.style) {\n\t\t\t\telement.style.pointerEvents = 'auto';\n\t\t\t\telement.style.pointerEvents = 'x';\n\t\t\t\tdocumentElement.appendChild(element);\n\t\t\t\tsupportsPointerEvents = getComputedStyle && getComputedStyle(element, '').pointerEvents === 'auto';\n\t\t\t\tdocumentElement.removeChild(element);\n\t\t\t}\n\n\t\t\tif (device.simulating && document.body && document.body.appendChild && supportsPointerEvents) {\n\t\t\t\tvar canvas = new (device.get('Canvas'))();\n\t\t\t\tcanvas.style.cssText = 'position: absolute; left: 0; top: 0; z-index: 1000; pointer-events: none;';\n\t\t\t\tdocument.body.appendChild(canvas);\n\n\t\t\t\tthis.constructor.ctx = canvas.getContext('2d');\n\t\t\t}\n\t\t}\n\n\t\t// used to drive renderer separately when app is paused\n\t\tthis.startTick = function () {\n\t\t\tthis.stopTick();\n\t\t\tthis._tick = setInterval(bind(this, 'render'), 1000 / 30);\n\t\t}\n\n\t\t// used to stop renderer's timer when app is unpaused\n\t\tthis.stopTick = function () {\n\t\t\tif (this._tick) {\n\t\t\t\tclearInterval(this._tick);\n\t\t\t}\n\t\t}\n\n\t\tthis.setEnabled = function (isEnabled) {\n\t\t\tthis._isEnabled = isEnabled;\n\t\t\tif (OverlayRenderer.ctx) {\n\t\t\t\tOverlayRenderer.ctx.clear();\n\t\t\t}\n\t\t}\n\n\t\tthis.render = function (ctx) {\n\t\t\tif (!ctx) { return; }\n\t\t\t// if (!this._isEnabled) { return; }\n\n\t\t\t// on simulated devices, we have our own canvas\n\t\t\t// so size it to fit the screen (clearing it too)\n\t\t\tif (OverlayRenderer.ctx) {\n\t\t\t\tctx = OverlayRenderer.ctx;\n\t\t\t\tctx.canvas.width = device.screen.width;\n\t\t\t\tctx.canvas.height = device.screen.height;\n\t\t\t}\n\n\t\t\t// render highlighted views\n\t\t\tif (this._highlightViewUID !== null) {\n\t\t\t\tvar view = _DEBUG.getViewByID(this._highlightViewUID);\n\t\t\t\tvar pos = view && view.getPosition();\n\t\t\t\tif (pos) renderHighlight(pos, ctx);\n\t\t\t}\n\n\t\t\t// render selected views\n\t\t\tif (this._selectedViewUID !== null) {\n\t\t\t\tvar view = _DEBUG.getViewByID(this._selectedViewUID);\n\t\t\t\tvar pos = view && view.getPosition();\n\t\t\t\tif (pos) renderSelected(pos, ctx);\n\t\t\t}\n\t\t}\n\t});\n}\n\n","pre":true},"sdk/gc/API.js":{"path":"sdk/gc/API.js","friendlyPath":"gc.API","directory":"sdk/gc/","filename":"API.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Import this before importing GC\n// _api.client.init sets up the GC object for the client apis\n\njsio(\"import lib.PubSub\");\njsio(\"import lib.Callback\");\njsio(\"import std.uri as URI\");\njsio(\"import ui.Engine\");\njsio(\"import ui.View\");\njsio(\"import ui.StackView\");\n\njsio(\"import device\");\n\nif (device.simulatingMobileNative) {\n\tjsio('import .debugging.nativeShim');\n}\n\nif (!GLOBAL.CONFIG) { GLOBAL.CONFIG = {}; }\nif (!GLOBAL.DEBUG) { GLOBAL.DEBUG = false; }\n\nif (GLOBAL.CONFIG.isMuted) {\n\tjsio(\"import AudioManager\");\n\tGLOBAL.ACCESSIBILITY.mute(true);\n}\n\nvar sdk_gc_API=__class__;exports=sdk_gc_API(function sdk_gc_API(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\n\tvar ua = navigator.userAgent;\n\tthis.isNative = /TeaLeaf/.test(ua);\n\tif (this.isNative) {\n\t\tthis.isIOS = /iPhone OS/.test(ua);\n\t\tthis.isAndroid = /Android/.test(ua);\n\t} else if (/(iPod|iPhone|iPad)/i.test(ua)) {\n\t\tthis.isMobileBrowser = true;\n\t\tthis.isIOS = true;\n\t\tthis.isUIWebView = !/Safari/.test(ua);\n\t} else if (/Android/.test(ua)) {\n\t\tthis.isMobileBrowser = true;\n\t\tthis.isAndroid = true;\n\t} else {\n\t\tthis.isDesktop = true;\n\t\tthis.isFacebook = GLOBAL.CONFIG.isFacebookApp;\n\t}\n\n\tthis.init = function (opts) {\n\t\tif (DEBUG) {\n\t\t\tif (GLOBAL.window && window.top) {\n\t\t\t\ttry {\n\t\t\t\t\twindow.top.GC = GLOBAL.GC;\n\t\t\t\t} catch (e) {\n\t\t\t\t\t//window.top is read-only in firefox\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (GLOBAL.ADDON_SOCIAL && ADDON_SOCIAL) {\n\t\t\tjsio(\"import GCSocial.GCSocial\", {suppressErrors: true});\n\t\t\tthis.social = GCSocial.GCSocial;\n\t\t\t\n\t\t\tGLOBAL.gcsocial = this.social; // deprecated\n\n\t\t\tthis.social.init({\n\t\t\t\tappID: GLOBAL.CONFIG.appID,\n\t\t\t\tshortName: GLOBAL.CONFIG.shortName,\n\t\t\t\tinviteURLTemplate: GLOBAL.CONFIG.inviteURLTemplate,\n\t\t\t\tendpoint: GLOBAL.CONFIG.servicesURL,\n\t\t\t});\n\n\t\t\tthis.track = gcsocial.tracker;\n\t\t}\n\n\t\twindow.addEventListener('pageshow', bind(this, '_onShow'), false);\n\n\t\twindow.addEventListener('pagehide', bind(this, '_onHide'), false);\n\n\t\tthis.isOnline = navigator.onLine;\n\n\t\twindow.addEventListener('online', bind(this, function() {\n\t\t\tif (!this.isOnline) {\n\t\t\t\tthis.isOnline = true;\n\t\t\t\tthis.publish('OnlineStateChanged', true);\n\t\t\t}\n\t\t}), false);\n\n\t\twindow.addEventListener('offline', bind(this, function() {\n\t\t\tif (this.isOnline) {\n\t\t\t\tthis.isOnline = false;\n\t\t\t\tthis.publish('OnlineStateChanged', false);\n\t\t\t}\n\t\t}), false);\n\n\t\t// var uri = new URI(window.location);\n\t\t// var campaign = uri.query('campaign') || \"NO CAMPAIGN\";\n\t\t//\n\t\t// XXX: The following lines cause a DOMException in some browsers\n\t\t// because we're using a <base> tag, which doesn't resolve the URL relative correctly.\n\t\t//get rid of it in case the game uses something\n\t\t// if (window.history && window.history.replaceState) {\n\t\t// \thistory.replaceState(null, null, uri.toString().replace(\"?campaign=\" + campaign, \"\"));\n\t\t// }\n\t\t//\n\t\t// if (!localStorage.getItem(\"campaignID\")) {\n\t\t// \tlocalStorage.setItem(\"campaignID\", campaign)\n\t\t// }\n\n\n\t\tif (CONFIG.version) {\n\t\t\tlogger.log('Version', CONFIG.version);\n\t\t}\n\t}\n\n\tGLOBAL.GC = new this.constructor();\n\n\tGC.Application = ui.StackView;\n\n\t// this.track({\n\t// \tname: \"campaignID\",\n\t// \tcategory: \"campaign\",\n\t// \tsubcategory: \"id\",\n\t// \tdata: campaign\n\t// });\n\n\tjsio(\"import .UI\");\n\tGC.ui = new UI();\n\n\t// import .OverlayAPI;\n\t// GC.overlay = new OverlayAPI(this.env);\n\t\n\tvar map;\n\n\ttry {\n\t\tif (GLOBAL.CACHE) {\n\t\t\tmap = JSON.parse(GLOBAL.CACHE['spritesheets/map.json']);\n\t\t}\n\t} catch (e) {\n\t\tlogger.warn(\"spritesheet map failed to parse\", e);\n\t}\n\t\t\n\tjsio(\"import ui.resource.loader\");\n\tGC.resources = ui.resource.loader;\n\tGC.resources.setMap(map);\n\n\tif (GC.env == 'browser') { setTimeout(bind(this, '_onShow'), 0); }\n\n\tthis._onHide = function() {\n\t\t// signal to the app that the window is going away\n\t\tthis.app && this.app.onPause && this.app.onPause();\n\n\t\tthis.publish('Hide');\n\t\tthis.publish('AfterHide');\n\n\t\tif (this.tracker) {\n\t\t\tthis.tracker.endSession();\n\t\t}\n\t};\n\n\tthis._onShow = function() {\n\t\tthis.app && this.app.onResume && this.app.onResume();\n\n\t\tthis.publish('Show');\n\t\tthis.publish('AfterShow');\n\t}\n\n\tthis.buildApp = function(entry) {\n\t\tjsio(\"import src.Application as Application\");\n\n\t\tApplication.prototype.__root = true;\n\t\tthis.app = new Application();\n\t\tthis.buildEngine({view: this.app});\n\t\treturn this.app;\n\t}\n\n\tthis.buildEngine = function (opts) {\n\t\tif (!opts) { opts = {}; }\n\t\tif (!opts.entry) { opts.entry = 'launchUI'; }\n\n\t\tvar view = opts.view;\n\t\tif (!view) {\n\t\t\tthrow \"a timestep.Engine must be created with a root view\";\n\t\t}\n\n\t\tif (!(view instanceof ui.View)) {\n\t\t\tthrow \"src/Application.js must export a Class that inherits from ui.View\";\n\t\t}\n\n\t\tview.subscribe('onLoadError', this, '_onAppLoadError');\n\n\t\tvar launch;\n\t\tif (typeof view[opts.entry] == 'function') {\n\t\t\tlaunch = bind(view, opts.entry);\n\t\t}\n\n\t\tview.view = view; // legacy, deprecated\n\t\tview.engine = new ui.Engine(opts);\n\t\tview.engine.show();\n\t\tview.engine.startLoop();\n\n\t\ttry {\n\t\t\tview.initUI && view.initUI();\n\n\t\t\tvar settings = view._settings || {};\n\t\t\tvar preload = settings.preload;\n\t\t\tvar autoHide = CONFIG.splash && (CONFIG.splash.autoHide !== false);\n\t\t\tif (preload && preload.length) {\n\t\t\t\tvar cb = new lib.Callback();\n\t\t\t\tfor (var i = 0, group; group = preload[i]; ++i) {\n\t\t\t\t\tGC.resources.preload(group, cb.chain());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// note that hidePreloader takes a null cb argument to avoid\n\t\t\t\t// forwarding the preloader result as the callback\n\t\t\t\tif (autoHide) { cb.run(GC, 'hidePreloader', null); }\n\t\t\t\tif (launch) { cb.run(launch); }\n\t\t\t} else {\n\t\t\t\tif (autoHide) { GC.hidePreloader(); }\n\t\t\t\tlaunch && launch();\n\t\t\t}\n\t\t} catch(error) {\n\t\t\tthis._onAppLoadError(error);\n\t\t\tthrow error;\n\t\t}\n\t};\n\n\tthis._onAppLoadError = function(error) {\n\t\tlogger.error('encountered error when creating src Application: ', JSON.stringify(error));\n\t\tvar splash = CONFIG.splash;\n\t\tif (splash && splash.onAppLoadError) {\n\t\t\tsplash.onAppLoadError(error);\n\t\t}\n\t};\n\n\tthis.hidePreloader = function(cb) {\n\t\tvar splash = CONFIG.splash;\n\t\tif (splash && splash.hide && !splash.hidden) {\n\t\t\tsplash.hide(cb);\n\t\t\tsplash.hidden = true;\n\t\t} else {\n\t\t\tcb && cb();\n\t\t}\n\t};\n});\n","pre":true},"sdk/gc/debugging/nativeShim.js":{"path":"sdk/gc/debugging/nativeShim.js","friendlyPath":".debugging.nativeShim","directory":"sdk/gc/debugging/","filename":"nativeShim.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"import lib.Callback\");\n\nvar testContactList = [\n];\n\n// for (var i = testContactList.length; i < 1000; ++i) {\n// \ttestContactList.push({id: i, name: username(), phones: [{number: '123456789'}]});\n// }\n\nexports.onBackButton = function () {};\n\nexports.dialogs = {\n\t\n\tshowDialog: function() {\n\t\tlogger.log(\"Showing a dialog!\");\n\t},\n\n\tshowAppRater: function() {\n\t\tlogger.log(\"Showing rate dialog!\");\n\t}\n\n};\n\n\nvar _withContacts = new lib.Callback();\n_withContacts.fire();\n\nexports.contacts = merge(new lib.PubSub(), {\n\t\n\tgetContactList: function() {\n\t\treturn testContactList;\n\t},\n\n\twithContacts: function() { _withContacts.forward(arguments); },\n\n\tsendAutomatedSMS: function(phone, msg, cb) {\n\t\tlogger.log('Send Automated SMS:', phone, msg);\n\t\tcb && cb();\n\t},\n\n\tsendSMS: function(phone, msg, cb) {\n\t\tlogger.log('Send SMS:', phone, msg);\n\t\tcb && cb();\n\t},\n\n\tgetPicture: function(id) {\n\t\treturn null;\n\t},\n\t\n\tgetPictures: function(ids) {\n\t\treturn null;\n\t},\n\n\tgetPictureBase64: function(id) {\n\t\treturn null;\n\t}\n\n});\n\nvar _withPhoneNumber = new lib.Callback();\n_withPhoneNumber.fire(null);\n\nvar _withPhoneNumber = new lib.Callback();\n_withPhoneNumber.fire(null);\n\nexports.profile = {\n\tfullName: \"\",\n\n\tgetPicture: function(id) {\n\t\treturn null;\n\t},\n\n\tgetPictureBase64: function(id) {\n\t\treturn null;\n\t},\n\n\twithPhoneNumber: function () { _withPhoneNumber.forward(arguments); }\n};\n\n\nexports.sound = {\n\tplaySound: function(url, volume) {\n\t\tlogger.log('this would play a sound on native');\n\t},\n\tloadSound: function(url) {\n\t\tlogger.log('this would load a sound on native');\n\t},\n\tpauseSound: function(url) {\n\t\tlogger.log('this would pause a sound on native');\n\t},\n\tstopSound: function(url) {\n\t\tlogger.log('this would stop a sound on native');\n\t},\n\tsetVolume: function(url, volume) {\n\t\tlogger.log('this would set the volume of a sound on native');\n\t},\n\tloadBackgroundMusic: function(url) {\n\t\tlogger.log('this would load background music on native');\n\t},\n\tplayBackgroundMusic: function(url) {\n\t\tlogger.log('this would play background music on native');\n\t}\n};\n\nexports.alerts = new lib.PubSub();\nmerge(exports.alerts, {\n\tonNotificationLoad: function () {},\n\tshowNotification: function () {\n\t\treturn -1;\n\t},\n\tshowRecurringNotification: function () {\n\t\tlogger.log(\"Setting up a recurring notification!\");\n\t\treturn -1;\n\t}\n});\n\nexports.social = new lib.PubSub();\n\n//import .auth.conn;\n//auth.conn.webAutoLogin();\n\nif (!GLOBAL.NATIVE) { GLOBAL.NATIVE = exports; }\n","pre":true},"sdk/gc/UI.js":{"path":"sdk/gc/UI.js","friendlyPath":".UI","directory":"sdk/gc/","filename":"UI.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"from util.browser import $\");\njsio(\"import std.uri\");\njsio(\"import std.js as JS\");\njsio(\"import lib.Iterator\");\njsio(\"import lib.Callback\");\njsio(\"import device\");\njsio(\"import ui.widget.Spinner as Spinner\"); \n\nvar config = window.CONFIG;\n\nlogger.log(\"ITS \", GLOBAL.HTMLCanvasElement);\nvar uiExports = {\n\tGCView: function() {\n\t\tjsio(\"import ui.View\");\n\t\treturn ui.View;\n\t},\n\tGCImage: function() {\n\t\tjsio(\"import ui.resource.Image\");\n\t\treturn ui.resource.Image;\n\t},\n\tGCImageView: function() {\n\t\tjsio(\"import ui.ImageView\");\n\t\treturn ui.ImageView;\n\t},\n\tGCCanvas: getCanvasCtor,\n\tGCSprite: function() {\n\t\tjsio(\"import ui.SpriteView\");\n\t\treturn ui.SpriteView;\n\t},\n\tGCResources: function() { // deprecated\n\t\tjsio(\"import ui.resource.loader\");\n\t\treturn ui.resource.loader;\n\t}\n};\n\nvar sdk_gc_UI=__class__;exports=sdk_gc_UI(function sdk_gc_UI(){return this.init&&this.init.apply(this,arguments)},function() {\n\tvar loader = null;\n\tthis.cssFile = function(path, cb) {\n\t\t//if (!loader) { loader = jsio('import squill.cssLoad'); }\n\n\t\t// load from cache\n\t\tvar textContent = CACHE[path];\n\t\tif (textContent) {\n\t\t\t$({tag: 'style', text: textContent, parent: document.getElementsByTagName('head')[0]});\n\t\t\tsetTimeout(cb, 0);\n\t\t}\n\t\t\n\t\t//loader.get(path, cb);\n\t}\n\t\n\tthis._spinnerCounter = 0;\n\n\tjsio(\"import device\");\n\n\tvar baseScale;\n\tif (navigator.displayMetrics) {\n\t\tbaseScale = navigator.displayMetrics.densityDpi / 160;\n\t} else if (!CONFIG.scaleDPR && device.isMobileBrowser) {\n\t\tbaseScale = 1;\n\t} else {\n\t\tbaseScale = window.devicePixelRatio || 1;\n\t}\n\n\tthis._scale = baseScale;\n\n\tthis.setTargetDensity = function (target) {\n\t\tswitch (target) {\n\t\t\tcase 'high':\n\t\t\t\tthis._scale = baseScale * 0.5;\n\t\t\t\tbreak;\n\t\t\tcase 'medium':\n\t\t\t\tthis._scale = baseScale * 0.75;\n\t\t\t\tbreak;\n\t\t\tcase 'low':\n\t\t\tdefault:\n\t\t\t\tthis._scale = baseScale;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlogger.log('scale:', this._scale);\n\t}\n\n\tthis.getScale = function () {\n\t\treturn this._scale;\n\t}\n\n\tthis.getIntValue = function (val) {\n\t\treturn Math.round(val * this._scale) / this._scale;\n\t}\n\n\tthis.showSpinner = function() {\n\t\tif (this._spinnerCounter) {\n\t\t\t++this._spinnerCounter;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar parent = GC.app.view;\n\t\tif (!parent) { return; }\n\t\t\n\t\t++this._spinnerCounter;\n\t\t\n\t\tif (!this._spinner) {\n\t\t\tvar dim = device.screen.devicePixelRatio * 50;\n\t\t\tthis._spinner = new Spinner({\n\t\t\t\twidth: dim,\n\t\t\t\theight: dim,\n\t\t\t\tx: parent.style.width / 2 - dim / 2,\n\t\t\t\ty: parent.style.height / 2 - dim / 2,\n\t\t\t\tparent: parent\n\t\t\t});\n\t\t} else {\n\t\t\tparent.addSubview(this._spinner);\n\t\t}\n\t}\n\t\n\tthis.hideSpinner = function() {\n\t\t--this._spinnerCounter;\n\t\tif (this._spinnerCounter <= 0) {\n\t\t\tthis._spinnerCounter = 0;\n\t\t\t\n\t\t\tthis._spinner && this._spinner.removeFromSuperview();\n\t\t}\n\t}\n\t\n\t// this.showDisplayNameDialog = function() {\n\t// \tthis.getDisplayNameDialog().show();\n\t// }\n\t\n\t// this.showAcceptInviteDialog = function(cb) {\n\t// \tGC.getConnection().withHandshake(this, function(err) {\n\t// \t\tif (err) { cb(err); return; }\n\t\t\t\n\t// \t\t// TODO: conn.getLoginDetails()\n\t// \t\tlogger.warn('put some real details in here');\n\n\t// \t\tvar details = {\n\t// \t\t\tfrom: 'Martin',\n\t// \t\t\tgame: 'Chess',\n\t// \t\t\tsummary: 'chess, 15 min, rated'\n\t// \t\t};\n\t\t\t\n\t// \t\tvar dialog = this.getAcceptInviteDialog();\n\t// \t\tdialog.setDetails(details);\n\t// \t\tdialog.delegate = function(action) {\n\t// \t\t\tswitch (action) {\n\t// \t\t\t\tcase 'accept':\n\t// \t\t\t\t\tGC.app.launchMultiplayerGame();\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\tcase 'decline':\n\t// \t\t\t\tdefault:\n\t// \t\t\t\t\tcb(action);\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t};\n\t\t\t\n\t// \t\tdialog.show();\n\t\t\t\n\t// \t\tcb && cb('opened');\n\t// \t});\n\t// }\n\t\n\t// this.showChat = function() {\n\t// \tif (!this._chatMenu) {\n\t// \t\timport GCMenus.Chat;\n\t// \t\tthis._chatMenu = new GCMenus.Chat();\n\t// \t}\n\t\t\n\t// \tvar menuController = this.getMenuController();\n\t// \tif (menuController.isVisible()) {\n\t// \t\tmenuController.push(this._chatMenu);\n\t// \t} else {\n\t// \t\tmenuController.push(this._chatMenu, true);\n\t// \t\tmenuController.fadeIn();\n\t// \t\tthis._chatMenu.subscribeOnce('BeforeHide', this, function() {\n\t// \t\t\tmenuController.fadeOut();\n\t// \t\t});\n\t// \t}\n\t// }\n\t\n\t// this.alert = function(msg) {\n\t// \tthis.showDialog({title: '', message: msg});\n\t// }\n\t\n\t// this.showError = function(opts) {\n\t// \tthis.showDialog(merge(opts, {title: 'Error:', message: \"Sorry!\"}));\n\t// }\n\t\n\t// this.showDialog = function(opts) {\n\t// \timport GCDialogs.AlertDialog;\n\t// \tvar dialog = new GCDialogs.AlertDialog(opts);\n\t// \tdialog.show();\n\t// \treturn dialog;\n\t// }\n\t\n\t// this.getAcceptInviteDialog = function() {\n\t// \tif (!this._acceptInviteDialog) {\n\t// \t\timport GCDialogs.AcceptInviteDialog;\n\t// \t\tthis._acceptInviteDialog = new GCDialogs.AcceptInviteDialog();\n\t// \t}\n\t\t\n\t// \treturn this._acceptInviteDialog;\n\t// }\n\t\n\t// this.getDisplayNameDialog = function() {\n\t// \tif (!this._displayNameDialog) {\n\t// \t\timport GCDialogs.DisplayNameDialog;\n\t// \t\tthis._displayNameDialog = new GCDialogs.DisplayNameDialog();\n\t// \t}\n\t\t\n\t// \treturn this._displayNameDialog;\n\t// }\n\t\n\t// this.getParentNode = function() {\n\t// \tif (!this._parentNode) {\n\t// \t\timport timestep.doc;\n\t// \t\tthis._parentNode = timestep.doc.getElement();\n\t// \t}\n\t// \treturn this._parentNode;\n\t// }\n\t\n\t// this.showMainMenu = function(opts) {\n\t// \topts = merge(opts, {\n\t// \t\tfade: true,\n\t// \t\tbackToGame: false\n\t// \t});\n\t\t\n\t// \tvar controller = this.getMenuController();\n\t// \tvar mainMenu = this.getMainMenu();\n\t// \tmainMenu.setGameRunning(opts.backToGame);\n\t// \tcontroller.push(mainMenu);\n\t// \tif (opts.fade) { controller.fadeIn(); }\n\t// }\n\t\n\t// this.fadeOutMenus = function() { this.getMenuController().fadeOut(); }\n\t// this.fadeInMenus = function() { this.getMenuController().fadeIn(); }\n\t\n\t// this.getMenuController = function() {\n\t// \tif (!this._menuController) {\n\t// \t\timport GCMenus.MainMenu;\n\t// \t\timport squill.MenuController;\n\t// \t\tthis._menuController = new squill.MenuController({\n\t// \t\t\tcontroller: this,\n\t// \t\t\tparent: this.getParentNode(),\n\t// \t\t\tdelegate: GCMenus.MainMenu.delegate,\n\t// \t\t\tid: 'mainMenuController'\n\t// \t\t});\n\t// \t}\n\t\t\n\t// \treturn this._menuController;\n\t// }\n\t\n\t// this.getMainMenu = function() {\n\t// \tif (!this._mainMenu) {\n\t// \t\timport GCMenus.MainMenu;\n\t// \t\tthis._mainMenu = new GCMenus.MainMenu(merge(this._mainMenuOpts, {\n\t// \t\t\tsupports: {} //MANIFEST.supports\n\t// \t\t}));\n\t// \t}\n\t\t\n\t// \treturn this._mainMenu;\n\t// }\n\t\n\t// this.setMainMenuOpts = function(opts) {\n\t// \tthis._mainMenu = null;\n\t// \tthis._mainMenuOpts = merge(opts, {\n\t// \t\ttitle: 'Welcome!',\n\t// \t\timgLogo: 'resources/images/logo.png',\n\t// \t\timgSingle: 'resources/images/btnSingle.png',\n\t// \t\timgMulti: 'resources/images/btnMulti.png',\n\t// \t\tshowInvites: true,\n\t// \t\tshowGames: true,\n\t// \t\tquitGameOnShow: false\n\t// \t});\n\t\t\n\t// \treturn this;\n\t// }\n\t\n\t// this.getMainMenuOpts = function() { return this._mainMenuOpts; }\n\t\n\t// this.hideCursor = function() {\n\t// \tvar el = GC.app.getCanvas().getElement();\n\t// \tif (el) { el.style.cursor = 'none'; }\n\t// }\n\t\n\t// this.showCursor = function(name) {\n\t// \tvar el = GC.app.getCanvas().getElement();\n\t// \tif (el) { el.style.cursor = name || 'default'; }\n\t// }\n});\n\nvar cache = {};\nfor (var key in uiExports) {\n\tvar getter = bind(GLOBAL, function(key) {\n\t\t\treturn cache[key] || (cache[key] = uiExports[key]());\n\t\t}, key);\n\t\n\tif (GLOBAL.__defineGetter__) {\n\t\tGLOBAL.__defineGetter__(key, getter);\n\t} else {\n\t\tif (Object.defineProperty) {\n\t\t\tObject.defineProperty(GLOBAL, key, {get: getter});\n\t\t}\n\t}\n}\n\nfunction AsyncImageLoader(url, callback) {\n\tvar img = new ui.resource.Image({url: url});\n\timg.doOnLoad(function(success) { callback(img); });\n}\n\nfunction getCanvasCtor() {\n\tjsio(\"import device\");\n\tvar ctor = device.get('Canvas');\n\treturn ctor;\n}\n","pre":true},"sdk/jsio/lib/Iterator.js":{"path":"sdk/jsio/lib/Iterator.js","friendlyPath":"lib.Iterator","directory":"sdk/jsio/lib/","filename":"Iterator.js","src":"\"use import\";\n\n/**\n * Summary: Provides an object for iterating over the keys and values of\n * an object or array.  \n * Methods: \n *  - init(src) - src is the object to iterate over\n *  - next(): returns the current value and advances the iterator to the next value\n *  - loop(cb): iterate over all items immediately, calling cb with each item\n *  - asyncLoop(cb): iterate over all items asynchronously.  First argument to\n *     the callback is the item.  Second argument is a function `nextItem` that, \n *     when called, will cause the iterator to advance to the next element and \n *     call cb again.\n * Usage notes: asyncLoop is implemented to not be vulnerable to stack overflows.\n *     If cb immediately calls the nextItem function, it will not immediately \n *     result in a call to cb -- the stack will unwind to the asyncLoop call \n *     before continuing.\n */\n\njsio(\"import std.js as JS\");\n\nvar sdk_jsio_lib_Iterator=__class__;exports=sdk_jsio_lib_Iterator(function sdk_jsio_lib_Iterator(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(src) {\n\t\tthis._src = src;\n\t\tthis._i = 0;\n\t\t\n\t\t// a call count prevents a stack overflow if the callback in\n\t\t// an aysncloop is called repeatedly for large arrays\n\t\tthis._calls = 0;\n\t\tif (JS.isArray(src)) {\n\t\t\tthis._isArray = true;\n\t\t} else if (Object.keys) {\n\t\t\tthis._keys = Object.keys(src);\n\t\t} else {\n\t\t\tvar k = this._keys = [];\n\t\t\tfor (var i in src) { if (src.hasOwnProperty(i)) { k.push(i); } }\n\t\t}\n\t}\n\t\n\tthis.nextKey = function() {\n\t\treturn this._keys[this._i++];\n\t}\n\t\n\tthis.next = function() {\n\t\tif (this._isArray) {\n\t\t\treturn this._src[this._i++] || exports.END_OF_LOOP;\n\t\t} else {\n\t\t\tvar key = this._keys[this._i++];\n\t\t\treturn key ? this._src[key] : exports.END_OF_LOOP;\n\t\t}\n\t}\n\t\n\tthis.loop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tvar next;\n\t\tif (this._isArray) {\n\t\t\twhile((next = this.next())) {\n\t\t\t\tcb(next);\n\t\t\t}\n\t\t} else {\n\t\t\twhile((next = this.nextKey())) {\n\t\t\t\tcb(this._src[next], next);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.asyncLoop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tthis._next = bind(this, '_onReturn', cb);\n\t\tthis._calls++;\n\t\tthis._asyncLoop(cb);\n\t}\n\t\n\tthis._asyncLoop = function(cb) {\n\t\tthis._inLoop = true;\n\t\twhile (this._calls) {\n\t\t\t--this._calls;\n\t\t\tcb(this.next(), this._next);\n\t\t}\n\t\tthis._inLoop = false;\n\t}\n\t\n\tthis._onReturn = function(cb) {\n\t\tthis._calls++;\n\t\tif (!this._inLoop) { this._asyncLoop(cb); }\n\t}\n});\n\nexports.END_OF_LOOP = new Error('jsio.Iterator.END_OF_LOOP');\n","pre":true},"sdk/timestep/ui/widget/Spinner.js":{"path":"sdk/timestep/ui/widget/Spinner.js","friendlyPath":"ui.widget.Spinner","directory":"sdk/timestep/ui/widget/","filename":"Spinner.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.widget.Spinner;\n */\njsio(\"import ui.View as View\");\n\nvar sdk_timestep_ui_widget_Spinner=__class__;exports=sdk_timestep_ui_widget_Spinner(function sdk_timestep_ui_widget_Spinner(){return this.init&&this.init.apply(this,arguments)},View, function (supr) {\n\n\tvar defaults = {\n\t\tcycles: 0.5,\n\t\tradius: 10,\n\t\tspokes: 20,\n\t\tthickness: 2,\n\t\ttrail: 10,\n\t\tcolor: '#ffffff',\n\t\tbackgroundColor: 'rgba(0, 0, 0, 0.5)',\n\t\tlayout: 'box'\n\t};\n\t\n\tthis.tag = 'Spinner';\n\tthis._t = 0;\n\t\n\tthis.init = function (opts) {\n\t\tthis._opts = merge(opts, defaults);\n\t\t\n\t\tthis._step = 2 * Math.PI / this._opts.spokes;\n\t\t\n\t\tsupr(this, 'init', [this._opts]);\n\t};\n\t\n\tthis.tick = function(dt) {\n\t\tthis._t += dt;\n\t\t\n\t\tvar r = (this._t / 1000 % (1 / this._opts.cycles)) * Math.PI;\n\t\t\n\t\tvar oldR = this._r;\n\t\tthis._r = r - (r % this._step);\n\t\t\n\t\tif (oldR != r) {\n\t\t\tthis.needsRepaint();\n\t\t}\n\t}\n\t\n\tthis.render = function(ctx) {\n\t\tctx.fillStyle = this._opts.backgroundColor;\n\t\t\n\t\tvar w = this.style.width,\n\t\t\t\th = this.style.height,\n\t\t\t\tradius = this._opts.radius,\n\t\t\t\ttrail = this._opts.trail,\n\t\t\t\tthickness = this._opts.thickness,\n\t\t\t\tx, y, i, j;\n\t\t\n\t\tfor (y = 0; y < radius; ++y) {\n\t\t\tj = y + 1;\n\t\t\tx = Math.round(radius - Math.sqrt(2 * j * radius - j * j));\n\t\t\tctx.fillRect(x, y, w - 2 * x, 1);\n\t\t}\n\t\t\n\t\ty = h - radius;\n\t\tctx.fillRect(0, radius, w, y - radius);\n\t\t\n\t\tfor (i = 0; i < radius; ++i) {\n\t\t\tj = radius - i;\n\t\t\tx = Math.round(radius - Math.sqrt(2 * j * radius - j * j));\n\t\t\tctx.fillRect(x, y + i, w - 2 * x, 1);\n\t\t}\n\t\t\n\t\tctx.fillStyle = this._opts.color;\n\t\tctx.translate(w / 2, h / 2);\n\t\tw /= 2;\n\t\tctx.rotate(this._r);\n\t\t\n\t\tfor (i = 0; i < this._opts.spokes; ++i) {\n\t\t\tctx.rotate(this._step);\n\t\t\tctx.globalAlpha = Math.max(0.1, (i - trail) / trail);\n\t\t\tctx.fillRect(10, -thickness / 2, w - 15, thickness);\n\t\t}\n\t}\n});\n","pre":true},"sdk/timestep/ui/SpriteView.js":{"path":"sdk/timestep/ui/SpriteView.js","friendlyPath":"ui.SpriteView","directory":"sdk/timestep/ui/","filename":"SpriteView.js","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @class ui.SpriteView\n * SpriteView pulls out sprited images and renders them at a given FPS\n * interval. A sprite consists of multiple *animations* (walk, run,\n * etc) which themselves consist of multiple *frames*.\n *\n * The sprite system pulls images from a given source format. Given\n * images like the following:\n *\n *     someFolder/spriteName-animationName-0001.png\n *     someFolder/spriteName-animationName-0002.png\n *\n * You'd instantiate a Sprite like so:\n * \n *     var mySprite = new SpriteView({url: \"someFolder/spriteName\"})\n * \n * The SpriteView class automatically find the images associated with that\n * sprite and generates the configuration for each of the animations.\n *\n * Then you would call this to start an animation:\n *\n *     mySprite.startAnimation(\"animationName\");\n *\n * @doc http://doc.gameclosure.com/api/ui-spriteview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/spriteview.md\n */\n\njsio(\"import ui.ImageView as ImageView\");\njsio(\"import ui.resource.Image as Image\");\njsio(\"import ui.resource.loader\");\n\nvar sdk_timestep_ui_SpriteView=__class__;var SpriteView = exports=sdk_timestep_ui_SpriteView(function sdk_timestep_ui_SpriteView(){return this.init&&this.init.apply(this,arguments)},\"SpriteView\", ImageView, function (logger, supr) {\n\t\n\tthis.defaults = {\n\t\turl: null, // specified as a filename prefix, without an animation name or frame count\n\t\tgroupID: \"default\",\n\t\tframeRate: 15,\n\t\tdelay: 0,\n\t\temitFrameEvents: false,\n\t\tautoStart: false,\n\t\tloop: true\n\t};\n\n\tvar GROUPS = {};\n\n\tthis.init = function(opts) {\n\t\tthis._opts = opts = merge(opts, this.defaults);\n\t\topts.visible = false;\n\t\tsupr(this, 'init', [opts]);\n\t\tthis.resetAllAnimations(opts);\n\t};\n\n\tthis.resetAllAnimations = function(opts) {\n\t\tthis.stopAnimation();\n\n\t\tthis._opts = opts = merge(opts, this.defaults);\n\n\t\tvar animations = SpriteView.allAnimations[opts.url];\n\t\t\n\t\tthis.groupID = opts.groupID;\n\t\tthis.frameRate = opts.frameRate;\n\t\t\n\t\tif (!GROUPS[this.groupID]) {\n\t\t\tGROUPS[this.groupID] = new Group();\n\t\t}\n\n\t\tthis._animations = {};\n\t\tvar autoSizeWidth = null;\n\t\tvar autoSizeHeight = null;\n\n\t\tfor (var animName in animations) {\n\t\t\tif (!this._opts.defaultAnimation) {\n\t\t\t\tthis._opts.defaultAnimation = animName;\n\t\t\t}\n\t\t\tthis.addAnimation(animName, animations[animName]);\n\t\t\tvar frameImages = this._animations[animName].frames;\n\t\t\tif (!autoSizeWidth && frameImages[0]) {\n\t\t\t\tautoSizeWidth = frameImages[0].getWidth();\n\t\t\t\tautoSizeHeight = frameImages[0].getHeight();\n\t\t\t}\n\t\t}\n\n\t\tif (opts.autoSize) {\n\t\t\tthis.style.width = autoSizeWidth;\n\t\t\tthis.style.height = autoSizeHeight;\n\t\t}\n\n\t\topts.autoStart && this.startAnimation(this._opts.defaultAnimation, opts);\n\t};\n\n\tthis.addAnimation = function(animName, frameData) {\n\t\tif ( ! isArray(frameData) ) {\n\t\t\tframeData = SpriteView.allAnimations[frameData][animName];\n\t\t}\n\t\tvar frameImages = [];\n\t\tfor (var i = 0, frame; frame = frameData[i]; i++) {\n\t\t\tframeImages.push(new Image({url: frame.url}));\n\t\t}\n\t\tthis._animations[animName] = {\n\t\t\tframes: frameImages\n\t\t};\n\t};\n\t\n\t/** Returns a ui.resource.Image for the given animation's frame. */\n\tthis.getFrame = function(animName, index) {\n\t\treturn this._animations[animName].frames[index];\n\t};\n\n\t/** Returns the number of frames in a given animation. */\n\tthis.getFrameCount = function(animName) {\n\t\treturn this._animations[animName].frames.length;\n\t};\n\n\tthis.getGroup = function(groupID) {\n\t\treturn GROUPS[groupID || this.groupID];\n\t};\n\n\t/**\n\t * Starts an animation. Default options:\n\t *     loop: false\n\t *     iterations: 1\n\t *     callback: null (called at the end of the animation)\n\t *     frame: 0 (frame to start on)\n\t *     randomFrame: false (start on a random frame of the animation)\n\t */\n\tthis.startAnimation = function (name, opts) {\n\t\topts = opts || {};\n\n\t\tif ( opts.randomFrame === true && opts.frame == null ) {\n\t\t\topts.frame = Math.random() * this._animations[name].frames.length | 0;\n\t\t}\n\n\t\tif (opts.loop === true) { opts.iterations = Infinity; }\n\n\t\tthis._iterationsLeft = opts.iterations || 1;\n\t\tthis._callback = opts.callback || null;\n\t\tthis._currentAnimationName = name;\n\t\tthis._currentFrame = opts.frame || 0;\n\t\tthis._dt = 0;\n\t\tthis._delay = 0;\n\n\t\tif (!this._animations[name]) {\n\t\t\tthrow new Error(\"Animation \" + name + \" does not exist: \" + this._opts.url + \".\");\n\t\t}\n\n\t\tif (!this.isPlaying) {\n\t\t\tGC.app.engine.subscribe('Tick', this, '_tickSprite');\n\t\t\tGROUPS[this.groupID].add(this);\n\t\t\tthis.isPlaying = this.running = true;\n\t\t\tthis.style.visible = true;\n\t\t}\n\n\t\t// align the image for the first time\n\t\tthis._tickSprite(0);\n\t};\n\n\t/** Stops the current animation. This will make the sprite invisible. */\n\tthis.stopAnimation = function() {\n\t\tif (this.isPlaying) {\n\t\t\tthis.style.visible = false;\n\t\t\tGC.app.engine.unsubscribe('Tick', this, '_tickSprite');\n\t\t\tthis.isPlaying = this.running = false;  //use isPlaying, this.running is deprecated\n\t\t\tthis.isPaused = this._isPaused = false; //use isPaused instead, _isPaused is deprecated\n\t\t\tGROUPS[this.groupID].remove(this.uid);\n\t\t}\n\t};\n\n\t/**\n\t * If this animation doesn't loop, stops the animation entirely.\n\t * Otherwise restarts the default animation. For instance, if you\n\t * had a default animation \"idle\", you could call\n\t *\n\t *     startAnimation('walk', {iterations: 2});\n\t *\n\t * and after 2 iterations of the 'walk' animation, it would go\n\t * back to the 'walk' animation.\n\t */\n\tthis.resetAnimation = function() {\n\t\tif (!this._opts.loop) {\n\t\t\tthis.stopAnimation();\n\t\t} else {\n\t\t\tthis.startAnimation(this._opts.defaultAnimation);\n\t\t}\n\t};\n\n\tthis.setFramerate = function(fps) {\n\t\tthis.frameRate = fps || 0.00001;\n\t};\n\n\tthis.pause = function() {\n\t\tthis.isPaused = this._isPaused = true;\n\t};\n\n\tthis.resume = function() {\n\t\tthis.isPaused = this._isPaused = false;\n\t};\n\n\tthis._tickSprite = function(dt) {\n\t\tif (this.isPaused) { return; }\n\n\t\tdt += this._dt;\n\n\t\tif (this._delay) {\n\t\t\tthis._delay -= dt;\n\t\t\tif (this._delay < 0) {\n\t\t\t\tthis._delay = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar anim = this._animations[this._currentAnimationName];\n\t\tvar stepTime = (1000 / this.frameRate);\n\t\tvar frameSteps = dt / stepTime | 0;\n\t\tvar prevFrame = this._currentFrame;\n\t\tthis._dt = dt - frameSteps * stepTime;\n\t\tthis._currentFrame = (this._currentFrame + frameSteps) % anim.frames.length;\n\n\t\tif (this._currentFrame < 0) {\n\t\t\tthis._currentFrame += anim.frames.length;\n\t\t}\n\t\t\n\t\tif (frameSteps !== 0 || dt === 0) {\n\t\t\tvar image = this._animations[this._currentAnimationName].frames[this._currentFrame];\n\t\t\tthis.setImage(image);\n\n\t\t\tif (this._opts.emitFrameEvents) {\n\t\t\t\tfor (var i = 0; i < frameSteps; i++) {\n\t\t\t\t\tvar frame = (prevFrame + i) % anim.frames.length;\n\t\t\t\t\tthis.publish(this._currentAnimationName + '_' + frame);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar iterationsCompleted = (prevFrame + frameSteps) / anim.frames.length | 0;\n\t\tif (iterationsCompleted) {\n\t\t\tthis._delay = this._opts.delay;\n\t\t\tif (--this._iterationsLeft <= 0) {\n\t\t\t\tvar cb = this._callback;\n\t\t\t\tthis._callback = null;\n\n\t\t\t\tthis.resetAnimation();\n\t\t\t\tif (cb) cb();\n\t\t\t}\n\t\t}\n\t};\n});\n\nSpriteView.allAnimations = {};\nSpriteView.getGroup = SpriteView.prototype.getGroup;\n\n(function loadAnimations() {\n\t// build the animation frame map\n\tvar resourceMap = ui.resource.loader.getMap();\n\tvar allAnimations = SpriteView.allAnimations;\n\n\t// Generate the animations from the filenames in resourceMap.\n\t// These names must be sorted ascending so that the frames end up\n\t// in the correct order.\n\tvar filenames = Object.keys(resourceMap);\n\tfilenames.sort();\n\n\t// Based on the filenames, add each image to an animation map (where applicable).\n\tfor (var i in filenames) {\n\t\tvar k = filenames[i];\n\t\t// split a filename like this: /resources/images/creature-walking-0001.png\n\t\t//       into parts like this: '    animKey     '  name  ' anim  ' #  '\n\t\tvar match = /((?:.*)\\/.*?)[-_ ](.*?)[-_ ](\\d+)/.exec(k);\n\t\tif (match) {\n\t\t\tvar animKey = match[1];\n\t\t\tvar name = match[2];\n\t\t\tvar frameNumber = match[3];\n\t\t\tvar anim = (allAnimations[animKey] || (allAnimations[animKey] = {}));\n\t\t\tvar frameList = (anim[name] || (anim[name] = []));\n\t\t\tvar info = resourceMap[k];\n\t\t\tinfo.url = k;\n\t\t\tframeList.push(info);\n\t\t}\n\t}\n})();\n\n\n/**\n * Group class\n */\nGroup=__class__;var Group=Group(function Group(){return this.init&&this.init.apply(this,arguments)},jsio.__filename, function(logger) {\n\n\tthis.init = function() {\n\t\tthis.sprites = {};\n\t};\n\n\tthis.add = function(sprite) {\n\t\tthis.sprites[sprite.uid] = sprite;\n\t};\n\n\tthis.remove = function(uid) {\n\t\tdelete this.sprites[uid];\n\t};\n\n\tthis.pause = function() {\n\t\tthis._forEachSprite('pause');\n\t};\n\n\tthis.resume = function() {\n\t\tthis._forEachSprite('resume');\n\t};\n\n\tthis.stopAnimation = function() {\n\t\tthis._forEachSprite('stopAnimation');\n\t};\n\n\tthis.resetAnimation = function() {\n\t\tthis._forEachSprite('resetAnimation');\n\t};\n\n\tthis._forEachSprite = function(method) {\n\t\tfor (var i in this.sprites) {\n\t\t\tthis.sprites[i][method]();\n\t\t}\n\t};\n});\n","pre":true},"./src/Application.js":{"path":"./src/Application.js","friendlyPath":"src.Application","directory":"./src/","filename":"Application.js","baseMod":"src","basePath":".","src":"/* @license\n * This file is part of the Game Closure SDK.\n *\n * The Game Closure SDK is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * The Game Closure SDK is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with the Game Closure SDK.  If not, see <http://www.gnu.org/licenses/>.\n */\n\njsio(\"import ui.TextView as TextView\");\n\nvar src_Application=__class__;exports=src_Application(function src_Application(){return this.init&&this.init.apply(this,arguments)},GC.Application, function () {\n\n\tthis.initUI = function () {\n\t\tvar textview = new TextView({\n\t\t\tsuperview: this.view,\n\t\t\tlayout: \"box\",\n\t\t\ttext: \"Hello, world!\",\n\t\t\tcolor: \"white\"\n\t\t});\n\t};\n\t\n\tthis.launchUI = function () {};\n});\n","pre":true}});; jsio('import gc.browser.launchClient');